Building Authentication with passport.js <link href="css/style.css" rel="stylesheet" type="text/css">  

# 使用 passport.js 构建身份验证

身份验证是任何应用程序的重要组成部分。 身份验证是保护我们构建的应用程序的一种方法。 每个应用程序都需要某种身份验证机制。 它帮助我们识别向应用服务器发出请求的用户。

在本章中，我们将讨论以下议题:

*   创建登录和注册页面
*   安装配置`passport.js`
*   了解更多关于`passport.js`策略，即**JSON Web Token**(**JWT**)策略的内容
*   了解更多关于`passport.js`本地策略
*   在应用服务器中创建处理注册和登录请求所需的端点

我们可以自己构建用户身份验证。 然而，它增加了许多配置和许多令人头疼的问题。 `passport.js`是一个包，它允许我们高效地配置身份验证，花费的时间非常少。 如果你想自己学习和发展，我鼓励你这样做。 这会让你更深入地了解事物是如何运作的。 然而，在本书中，我们将使用这个很棒的工具`passport.js`，它非常容易集成和学习。

到本章为止，我们已经创建了一个动态的 web 应用程序，它显示了我们通过 Movie Add 表单和主页上的 API 添加的所有电影。 我们也可以通过前端将这些电影添加到数据库中。 现在，由于这将是一个公共的 web 应用程序，我们不能允许每个人在没有登录的情况下自己添加电影。 只有登录的用户才能访问并添加电影。 此外，为了给电影评分，用户应该先登录，然后再给电影评分。

# 介绍 passport.js

`passport.js`是 Node.js 提供的用于身份验证的中间件。 `passport.js`的功能是对向服务器发出的请求进行身份验证。 它提供了几种身份验证策略。 `passport.js`提供策略，如本地策略、Facebook 策略、谷歌策略、Twitter 策略和 JWT 策略。 在本章中，我们将重点讨论使用 JWT 策略。

# JWT

JWT 是一种使用基于令牌的方法验证请求的方法。 有两种验证请求的方法:基于 cookie 的验证和基于令牌的验证。 基于 cookie 的身份验证机制将用户的会话 ID 保存在浏览器的 cookie 中，而基于令牌的机制使用的是一个签名令牌，看起来像这样:

```js
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6IjVhNjhhNDMzMDJkMWNlZDU5YjExNDg3MCIsImlhdCI6MTUxNzI0MjM1M30.5xY59iTIjpt9ukDmxseNAGbOdz6weWL1drJkeQzoO3M
```

然后在我们向`controllers`发出的每个请求上验证该令牌。

对于我们的应用程序，我们将使用两者的组合。 当用户请求登录应用程序时，我们将为他们创建一个已签名的令牌，然后将该令牌添加到浏览器的 cookie 中。 下一次当用户登录时，我们将从 cookie 中读取该令牌，并使用服务器中的`passport-jwt`模块验证该令牌，然后决定是否让该用户登录。

如果仔细查看前面的标记，您将看到标记有三个部分，由句号(`.`)分隔; 每个部分都有自己的含义:

*   第一部分表示头文件
*   第二部分表示有效负载
*   第三部分代表签名

为了能够使用这个 JWT，我们需要添加一个包。 要做到这一点，我们只需运行以下命令:

```js
$ npm install jsonwebtoken --save

```

为了开始使用这个包，让我们也在`server.js`中定义它:

```js
...
const morgan = require('morgan')
const fs = require('fs')
const jwt = require('jsonwebtoken');
...
```

# 安装 passport.js

就像其他的`npm`包一样，我们可以通过运行以下命令来安装`passport.js`:

```js
$ npm install passport --save
```

成功安装后，您应该在您的`package.json`中列出这些包:

```js
...
"nodemon": "^1.14.10",
"passport": "^0.4.0",
"sass-loader": "^6.0.6",
...
```

你也可以先将这个包添加到你的`package.json`文件中，然后运行以下命令:

```js
$ npm install
```

# 配置的护照

就像其他的`node`包一样，我们需要为`passport.js`配置包。 在我们的`server.js`文件中，添加以下代码行:

```js
...
const mongoose = require('mongoose');
const cors = require('cors');
const morgan = require('morgan');
const fs = require('fs');
const jwt = require('jsonwebtoken');
const passport = require('passport');

const app = express();
const router = express.Router();
app.use(morgan('combined'));
app.use(bodyParser.json());
app.use(cors());
app.use(passport.initialize());
...
```

前面的代码刚刚初始化了应用程序中的`passport.js`。 我们仍然需要配置一些东西来开始使用 JWT 身份验证机制。

# passport.js 策略

如前所述，`passport.js`提供了许多易于集成的策略。 我们将要使用的策略之一是 JWT 策略。 我们已经添加了`passport.js`并初始化了它。 现在，让我们也加入这个策略。

# 安装 passport-jwt 策略

仅仅安装护照模块是不够的。 `passport.js`在单独的`npm`包中提供其策略。 对于`jwt`认证，我们需要安装`passport-jwt`模块，如下:

```js
$ npm install passport-jwt --save
```

在成功安装后，您应该在应用程序的`package.json`文件中列出这些包:

```js
...
"nodemon": "^1.14.10",
"passport": "^0.4.0", "passport-jwt": "^3.0.1",
"sass-loader": "^6.0.6",
...

```

# 配置 passport-jwt 策略

现在我们已经拥有了所需的所有东西，让我们进入 JWT 策略的配置设置。 在`server.js`中添加以下代码行:

```js
...
const morgan = require('morgan');
const fs = require('fs');
const jwt = require('jsonwebtoken');
const passport = require('passport');
const passportJWT = require('passport-jwt');
const ExtractJwt = passportJWT.ExtractJwt;
const JwtStrategy = passportJWT.Strategy;
const jwtOptions = {}
jwtOptions.jwtFromRequest = ExtractJwt.fromAuthHeaderWithScheme('jwt');
jwtOptions.secretOrKey = 'movieratingapplicationsecretkey';

const app = express();
const router = express.Router();
...
```

前面的代码足以让我们开始。 我们将需要`passport.js`中的`JwtStrategy`，而`ExtractJwT`将用于提取`jwt`令牌中的有效负载数据。

我们还定义了一个变量来设置 JWT`auth`设置，它配置了一个密钥。 这个秘密密钥将用于签署任何请求的有效负载。

您还可以创建一个单独的文件来存储重要的密钥。

# 使用 JWT 策略

现在我们已经准备好使用`passport.js`提供的服务。 让我们快速回顾一下我们到目前为止所做的:

1.  安装护照，`passport-jwt`，`jsonwebtoken`
2.  配置这三个包的所有设置

接下来的步骤如下:

1.  创建我们的用户模型
2.  为用户实体创建 API 端点，即登录和注册
3.  构建我们的身份验证视图，即登录页面和注册页面
4.  使用 JWT 策略最终对请求进行身份验证

# 设置用户注册

让我们从添加注册用户到应用程序的功能开始。

# 创建用户模型

我们还没有一个集合来管理用户。 在我们的`User`模型中有三个参数:`name`、`email`和`password`。 让我们继续在`models`目录下创建`User`模型`User.js`:

```js
const mongoose = require('mongoose');

const Schema = mongoose.Schema;
const UserSchema = new Schema({
 name: String,
 email: String,
 password: String,
});

const User = mongoose.model('User', UserSchema);
module.exports = User;
```

如您所见，以下是用户的三个属性:`name`、`email`和`password`。

# Installing bcryptjs

现在，我们不能以明文形式保存这些用户的密码，因此我们需要一种机制来加密它们。 幸运的是，我们已经有了一个用于加密密码的包，即`bcryptjs`。 让我们首先将这个包添加到我们的应用程序:

```js
$ npm install bcryptjs --save
```

安装包后，让我们在`User.js`模型中添加初始化块:

```js
const mongoose = require('mongoose');
const bcryptjs = require('bcryptjs');

const Schema = mongoose.Schema;
const UserSchema = new Schema({
  name: String,
  email: String,
  password: String,
});

const User = mongoose.model('User', UserSchema);
module.exports = User;
```

现在，当我们保存一个用户时，我们应该创建自己的方法来将用户添加到数据库中，因为我们希望加密他们的密码。 因此，让我们将以下代码添加到`models/User.js`:

```js
...
const User = mongoose.model('User', UserSchema);
module.exports = User;

module.exports.createUser = (newUser, callback) => {
 bcryptjs.genSalt(10, (err, salt) => {
 bcryptjs.hash(newUser.password, salt, (error, hash) => {
 // store the hashed password
 const newUserResource = newUser;
 newUserResource.password = hash;
 newUserResource.save(callback);
 });
 });
};
...
```

在前面的代码中，我们使用了`bcrypt`库，该库使用`genSalt`机制将密码转换为加密的字符串。 前面的方法——`User`模型中的`createUser`获取`user`对象，将用户提供的密码转换为 bcrypted 密码，然后将其保存到数据库中。

# 添加 API 端点以注册用户

现在我们已经准备好了模型，让我们继续创建一个端点来创建一个用户。 为此，让我们首先在`controllers`文件夹中创建一个名为`users.js`的控制器来管理所有与用户相关的请求。 因为我们已经添加了一个代码块来初始化`server.js`中`controllers`目录中的所有文件，所以这里不需要这些文件。

在`users.js`中，用以下代码替换文件内容:

```js
const User = require('../models/User.js');

module.exports.controller = (app) => {
 // register a user
 app.post('/users/register', (req, res) => {
 const name = req.body.name;
 const email = req.body.email;
 const password = req.body.password;
 const newUser = new User({
 name,
 email,
 password,
 });
 User.createUser(newUser, (error, user) => {
 if (error) { console.log(error); }
 res.send({ user });
 });
 });
};
```

在前面的代码中，我们添加了一个端点，该端点向`http://localhost:8081/users/register`URL 发出 POST 请求，获取用户的`name`、`email`和`password`，并将它们保存到我们的数据库中。 在响应中，它返回刚刚创建的用户。 这很简单。

现在，让我们在 Postman 中测试这个端点。 你应该能够看到用户在响应中返回:

![](img/64757a12-83f6-4ab9-a3d9-a61e0f19b6fd.png)

# 创建注册视图页面

让我们添加一个视图页面供用户注册。 为此，我们需要创建一个采用`name`、`email`和`password`参数的表单。 在`src/components`中创建一个名为`Register.vue`的文件:

```js
<template>
 <v-form v-model="valid" ref="form" lazy-validation>
 <v-text-field
 label="Name"
 v-model="name"
 required
 ></v-text-field>
 <v-text-field
 label="Email"
 v-model="email"
 :rules="emailRules"
 required
 ></v-text-field>
 <v-text-field
 label="Password"
 v-model="password"
 required
 ></v-text-field>
 <v-text-field
 name="input-7-1"
 label="Confirm Password"
 v-model="confirm_password"
 ></v-text-field>
 <v-btn
 @click="submit"
 :disabled="!valid"
 >
 submit
 </v-btn>
 <v-btn @click="clear">clear</v-btn>
 </v-form>
</template>
```

`vue`文件是一个包含表单组件的简单模板文件。 下一步是为该文件添加一个路由。

在`src/router/index.js`中，添加以下代码行:

```js
import Vue from 'vue';
import Router from 'vue-router';
import Home from '@/components/Home';
import Contact from '@/components/Contact';
import AddMovie from '@/components/AddMovie';
import Movie from '@/components/Movie';
import Register from '@/components/Register';

Vue.use(Router);

export default new Router({
  mode: 'history',
  routes: [
    {
      path: '/',
      name: 'Home',
      component: Home,
    },
    {
      path: '/contact',
      name: 'Contact',
      component: Contact,
    },
    {
      path: '/movies/add',
      name: 'AddMovie',
      component: AddMovie,
    },{ path: '/movies/:id',name: 'Movie',component: Movie,},
 {
 path: '/users/register',
 name: 'Register',
 component: Register,
 },
  ],
});
```

就是这样! 现在，让我们浏览`http://localhost.com:8080/users/register`:

![](img/45360b7b-0695-4de3-a24c-25b3bcdf6448.png)

# 在注册表中增加提交和清除方法

下一步是向`submit`和`clear`方法添加功能。 让我们在`Register.vue`中添加一些方法:

```js
...
    <v-btn @click="clear">clear</v-btn>
  </v-form>
</template>
<script>
export default {
 data: () => ({
 valid: true,
 name: '',
 email: '',
 password: '',
 confirm_password: '',
 emailRules: [
 v => !!v || 'E-mail is required',
 v => /\S+@\S+\.\S+/.test(v) || 'E-mail must be valid',
 ],
 }),
 methods: {
 async submit() {
 if (this.$refs.form.validate()) {
 // add process here
 }
 },
 clear() {
 this.$refs.form.reset();
 },
 },
};
</script>
```

我们还在这里为注册表单添加了一些验证。 它根据给定的正则表达式验证用户提供的电子邮件。

我们增加了两个方法`submit`和`clear`。 `clear`方法重置表单值; 很简单,对吧? 现在，当我们点击`submit`按钮时，首先运行验证。 如果所有验证都通过了，那么只处理`submit`方法内部的逻辑。 在这里，我们需要使用`axios`发挥作用的用户参数向服务器发出请求。

# 引入 axios

axios 是一种向服务器发送请求数据的机制。 您可以将其视为 JavaScript 中的 AJAX 请求。 使用`axios`，我们可以有效地处理来自服务器的成功和错误响应。

使用实例安装`axios`:

```js
$ npm install axios --save
```

# 使用 axios

现在，让我们修改我们的`Register.vue`文件来实现`axios`-替换`script`标记内的内容，如下所示:

```js
...
</v-form>
</template>
<script>
import axios from 'axios';

export default {
  data: () => ({
    valid: true,
    name: '',
    email: '',
    password: '',
    confirm_password: '',
    emailRules: [
      v => !!v || 'E-mail is required',
      v => /\S+@\S+\.\S+/.test(v) || 'E-mail must be valid',
    ],
  }),
  methods: {
    async submit() {
 if (this.$refs.form.validate()) {
 return axios({
 method: 'post',
 data: {
 name: this.name,
 email: this.email,
 password: this.password,
 },
 url: 'http://localhost:8081/users/register',
 headers: {
 'Content-Type': 'application/json',
 },
 })
 .then(() => {
 this.$swal(
 'Great!',
 'You have been successfully registered!',
 'success',
 );
 this.$router.push({ name: 'Login' });
 })
 .catch((error) => {
 const message = error.response.data.message;
 this.$swal('Oh oo!', `${message}`, 'error');
 });
 }
 return true;
 },
 clear() {
 this.$refs.form.reset();
 },
  },
};
</script>
```

如果您熟悉`ajax`，您应该能够快速理解代码。 如果没有，也不要担心，这其实很简单。 方法接受重要的参数，例如`request`方法(在前面的例子中是`post`)、数据参数或有效载荷，以及要命中的 URL 端点。 它接受这些参数，并根据服务器的响应将它们路由到`then()`方法或`catch()`方法。

如果请求成功，则转到`then()`方法; 如果没有，则使用`catch()`方法。 现在，请求的成功和失败也可以根据我们的需要定制。 对于前面的场景，如果没有将`user`保存到数据库中，我们将简单地传递一个错误响应。 我们也可以在验证中这样做。

因此，让我们也修改`controller`方法内部的`users.js`来适应这些变化:

```js
const User = require('../models/User.js');

module.exports.controller = (app) => {
  // register a user
  app.post('/users/register', (req, res) => {
    const name = req.body.name;
    const email = req.body.email;
    const password = req.body.password;
    const newUser = new User({
      name,
      email,
      password,
    });
    User.createUser(newUser, (error, user) => {
      if (error) {
 res.status(422).json({
 message: 'Something went wrong. Please try again after some time!',
 });
 }
      res.send({ user });
    });
  });
};
```

正如您在前面的代码中看到的，如果请求中有一个失败，我们将发送一条消息`Something went wrong`。 我们还可以根据服务器的响应显示不同类型的消息。

# 设置用户登录

现在我们已经成功地为用户实现了登录过程，让我们开始构建让用户登录到我们的应用程序的功能。

# 修改 User 模型

为了让用户登录到应用程序，我们将获取以下两个参数:用户的电子邮件和他们的密码。 我们需要查询数据库，找到他们给出的电子邮件记录; 因此，让我们添加一个方法来根据用户名提取用户:

```js
...
const User = mongoose.model('User', UserSchema);
module.exports = User;

module.exports.createUser = (newUser, callback) => {
  bcryptjs.genSalt(10, (err, salt) => {
    bcryptjs.hash(newUser.password, salt, (error, hash) => {
      // store the hashed password
      const newUserResource = newUser;
      newUserResource.password = hash;
      newUserResource.save(callback);
    });
  });
};

module.exports.getUserByEmail = (email, callback) => {
 const query = { email };
 User.findOne(query, callback);
};
```

上述方法将返回拥有给定电子邮件的用户。

正如我提到的，我们需要检查的另一件事是密码。 让我们添加一个方法来比较用户在登录保存在数据库中的密码时提供的密码:

```js
...
module.exports.getUserByEmail = (email, callback) => {
  const query = { email };
  User.findOne(query, callback);
};

module.exports.comparePassword = (candidatePassword, hash, callback) => {
 bcryptjs.compare(candidatePassword, hash, (err, isMatch) => {
 if (err) throw err;
 callback(null, isMatch);
 });
};
```

前面的方法同时接受用户提供的密码和保存的密码，并根据密码是否匹配返回`true`或`false`。

现在，我们已经准备好进入控制器部分。

# 添加 API 端点以让用户登录

我们已经添加了用户登录所需的方法。 现在，这一章最重要的部分在这里。 我们需要设置 JWT`auth`机制来允许用户登录。

在`users.js`中，添加以下代码行:

```js
const User = require('../models/User.js');

const passportJWT = require('passport-jwt');
const jwt = require('jsonwebtoken');

const ExtractJwt = passportJWT.ExtractJwt;
const jwtOptions = {};
jwtOptions.jwtFromRequest = ExtractJwt.fromAuthHeaderWithScheme('jwt');
jwtOptions.secretOrKey = 'thisisthesecretkey';

module.exports.controller = (app) => {
  // register a user
  app.post('/users/register', (req, res) => {
    const name = req.body.name;
    const email = req.body.email;
    const password = req.body.password;
    const newUser = new User({
      name,
      email,
      password,
    });
    User.createUser(newUser, (error, user) => {
      if (error) {
        res.status(422).json({
          message: 'Something went wrong. Please try again after some time!',
        });
      }
      res.send({ user });
    });
  });

  // login a user
 app.post('/users/login', (req, res) => {
 if (req.body.email && req.body.password) {
 const email = req.body.email;
 const password = req.body.password;
 User.getUserByEmail(email, (err, user) => {
 if (!user) {
 res.status(404).json({ message: 'The user does not exist!' });
 } else {
 User.comparePassword(password, user.password, (error, isMatch) => {
 if (error) throw error;
 if (isMatch) {
 const payload = { id: user.id };
 const token = jwt.sign(payload, jwtOptions.secretOrKey);
 res.json({ message: 'ok', token });
 } else {
 res.status(401).json({ message: 'The password is incorrect!' });
 }
 });
 }
 });
 }
 });
};
```

由于 JWT 策略是`passport.js`的一部分，我们也需要初始化它。 我们还需要为 JWT 选项添加一些配置，以从有效负载提取数据，并对其进行非加密，然后在向服务器发出请求时再次加密。

密钥是可以配置的东西。 它基本上代表了应用程序的令牌。确保它不容易被猜测。

此外，我们还添加了一个端点，它向`localhost:8081/users/login`发出 POST 请求并获取用户的电子邮件和密码。 下面是这个方法所做的一些事情:

*   检查具有给定电子邮件的用户是否存在。 如果它不存在，它会发送一个状态码 404，说明该用户在我们的应用程序中不存在。
*   比较提供的密码和应用程序中我们用户的密码。如果不匹配，它发送一个错误响应，说明密码不匹配。
*   如果一切顺利，它将使用 JWT 签名对用户的有效负载进行签名，生成一个令牌，并使用该令牌进行响应。

现在，让我们在 Postman 中测试这个端点。 您应该能够看到响应中返回的令牌，如下所示:

![](img/9d43f252-4443-4cdb-b915-48e3fd30c63f.png)

在前面的屏幕截图中，请注意，JWT 获取有效负载，对其进行签名，并生成一个随机令牌。

# 创建注册视图页面

现在让我们添加一个视图页面供用户登录。 为此，就像我们在注册页面上做的那样，我们将需要创建一个接受电子邮件和密码参数的表单。 在`src/components`内部创建一个名为`Login.vue`的文件，如下所示:

```js
<template>
 <v-form v-model="valid" ref="form" lazy-validation>
 <v-text-field
 label="Email"
 v-model="email"
 :rules="emailRules"
 required
 ></v-text-field>
 <v-text-field
 label="Password"
 v-model="password"
 required
 ></v-text-field>
 <v-btn
 @click="submit"
 :disabled="!valid"
 >
 submit
 </v-btn>
 <v-btn @click="clear">clear</v-btn>
 </v-form>
</template>
```

`vue`文件是一个包含表单组件的简单模板文件。 接下来要做的是为该文件添加一个路由。

在`src/router/index.js`中添加以下代码:

```js
import Vue from 'vue';
import Router from 'vue-router';
import Home from '@/components/Home';
import Contact from '@/components/Contact';
import AddMovie from '@/components/AddMovie';
import Movie from '@/components/Movie';
import Register from '@/components/Register';
import Login from '@/components/Login';

Vue.use(Router);

export default new Router({
  mode: 'history',
  routes: [
    {
      path: '/',
      name: 'Home',
      component: Home,
    },
    {
      path: '/contact',
      name: 'Contact',
      component: Contact,
    },
    {
      path: '/movies/add',
      name: 'AddMovie',
      component: AddMovie,
    },
    {
      path: '/movies/:id',
      name: 'Movie',
      component: Movie,
    },
    {
      path: '/users/register',
      name: 'Register',
      component: Register,
    },
    {
 path: '/users/login',
 name: 'Login',
 component: Login,
 },
  ],
});
```

就是这样。 现在，让我们导航到`http://localhost.com:8080/users/login`:

![](img/36840d36-9b09-4219-9797-57ad3e10df90.png)

# 向登录表单添加 submit 和 clear 方法

下一步是在`submit`和`clear`方法中添加功能。 让我们在`Login.vue`中添加一些方法。 `clear`方法与注册页面相同。 对于`submit`方法，我们将在这里使用`axios`方法。 我们已经在控制器中对成功和错误消息进行了分类。 现在我们只需要确保它们在 UI 中显示:

```js
...
</v-form>
</template>
<script>
import axios from 'axios';

export default {
 data: () => ({
 valid: true,
 email: '',
 password: '',
 emailRules: [
 v => !!v || 'E-mail is required',
 v => /\S+@\S+\.\S+/.test(v) || 'E-mail must be valid',
 ],
 }),
 methods: {
 async submit() {
 return axios({
 method: 'post',
 data: {
 email: this.email,
 password: this.password,
 },
 url: 'http://localhost:8081/users/login',
 headers: {
 'Content-Type': 'application/json',
 },
 })
 .then((response) => {
 window.localStorage.setItem('auth', response.data.token);
 this.$swal('Great!', 'You are ready to start!', 'success');
 this.$router.push({ name: 'Home' });
 })
 .catch((error) => {
 const message = error.response.data.message;
 this.$swal('Oh oo!', `${message}`, 'error');
 this.$router.push({ name: 'Login' });
 });
 },
 clear() {
 this.$refs.form.reset();
 },
 },
};
</script>
```

验证与注册页上的相同。 我们增加了两个方法`submit`和`clear`。 `clear`方法重置表单值，`submit`方法简单地点击 API 端点，从表单中获取参数，然后用正确的消息进行响应，然后显示在 UI 中。 成功完成后，用户将被重定向到主页。

这里的重要部分是，由于我们是在客户端进行交互，因此需要将之前生成的 JWT 令牌保存在某个地方。 访问令牌的最佳方法是将其保存到浏览器的会话中。 因此，我们设置了一个名为`auth`的键，它将 JWT 令牌保存在本地存储中。 每当发出任何其他请求时，请求将首先检查它是否是一个有效的令牌，并相应地执行操作。

以下是我们目前所做的工作:

*   用户模型中增加了`getUserByEmail()`和`comparePassword()`
*   创建登录视图页面
*   增加了提交和清除表单的方法
*   生成一个 JWT 签名令牌，并将其保存到会话中，以便以后重用
*   显示成功和错误消息

# 在 Home.vue 中验证我们的用户

我们需要做的最后一件事是检查当前登录的用户是否具有查看电影列表页面的权限。 尽管让所有用户都可以访问主页(电影列表页面)是有意义的，但是出于学习的目的，让我们在用户访问主页时添加 JWT 授权。 让我们让不在我们应用程序中的外部用户无法访问主页。

在`movies.js`中，添加以下代码段:

```js
const MovieSchema = require('../models/Movie.js');
const Rating = require('../models/Rating.js');
const passport = require('passport');

module.exports.controller = (app) => {
  // fetch all movies
  app.get('/movies', passport.authenticate('jwt', { session: false }), (req, res) => {
    MovieSchema.find({}, 'name description release_year genre', (error, movies) => {
      if (error) { console.log(error); }
      res.send({
        movies,
      });
    });
  });
...
```

是的,就是这样! 我们将需要初始化护照，并只添加`passport.authenticate('jwt', { session: false })`。 我们必须通过 JWT 令牌和护照 JWT 策略自动验证当前用户。

现在，让我们在向电影列表页面发出请求的同时发送 JWT 令牌。 在`Home.vue`中，添加以下代码:

```js
...
<script>
import axios from 'axios';

export default {
  name: 'Movies',
  data() {
    return {
      movies: [],
    };
  },
  mounted() {
    this.fetchMovies();
  },
  methods: {
    async fetchMovies() {
 const token = window.localStorage.getItem('auth');
 return axios({
 method: 'get',
 url: 'http://localhost:8081/movies',
 headers: {
 Authorization: `JWT ${token}`,
 'Content-Type': 'application/json',
 },
 })
 .then((response) => {
 this.movies = response.data.movies;
 this.current_user = response.data.current_user;
 })
 .catch(() => {
 });
 },
  },
};
</script>
```

当进行`axios`调用时，我们必须在头文件中传递一个额外的参数。 我们需要从本地存储中读取令牌，并通过头将其传递给 movies API。

这样，任何没有登录到应用程序的用户将无法查看电影列表页面。

# 为 Vue 组件提供静态文件

在进入本地策略之前，让我们先了解一下如何静态地提供 Vue.js 组件。 由于我们使用独立的前端和后端，维护这两个版本可能是一项艰巨的任务，尤其是在部署应用程序时，它可能需要更长的时间来配置所有内容。 因此，为了更好地管理我们的应用程序，我们将构建 Vue.js 应用程序，这将是一个产品构建，并使用 Node.js 服务器只服务于文件。 为此，我们将使用一个单独的包 serve-static。 所以，让我们继续安装这个包:

```js
$ npm install serve-static --save 
```

现在，我们将以下内容添加到我们的`server.js`文件中:

```js
const express = require('express');
const bodyParser = require('body-parser');
const mongoose = require('mongoose');
const cors = require('cors');
const morgan = require('morgan');
const fs = require('fs');
const session = require('express-session');
const config = require('./config/Config');
const passport = require('passport');
const app = express();
const router = express.Router();
const serveStatic = require('serve-static');

app.use(morgan('combined'));
app.use(bodyParser.json());
app.use(cors());

...

// Include controllers
fs.readdirSync("controllers").forEach(function (file) {
  if(file.substr(-3) == ".js") {
    const route = require("./controllers/" + file)
    route.controller(app)
  }
})
app.use(serveStatic(__dirname + "/dist"));
...
```

现在，让我们用下面的命令构建我们的应用程序:

```js
$ npm run build 
```

前面的命令将在应用程序的`dist`文件夹中创建必要的静态文件，该文件将由 Node.js 服务器(位于 8081 端口)提供服务。 构建完成后，我们现在不需要运行以下命令:

```js
$ npm run dev 
```

此外，现在由于我们只运行节点服务器，应用程序应该在 URL`http://localhost:8081`处可用。

上面的命令启动我们的前端服务器。 我们只需要用下面的命令运行 Node.js 服务器:

```js
$ nodemon server.js
```

由于我们现在只有一个端口 8081，所以不需要像前面那样在每个后端 API 中添加前缀`/api`，我们也可以去掉这些前缀。 因此，让我们更新`controllers`和`vue`文件:

将`controllers/movies.js`中的内容替换如下:

```js
var Movie = require("../models/Movie");

module.exports.controller = (app) => {
  // fetch all movies
 app.get("/movies", function(req, res) {
    Movie.find({}, 'name description release_year genre', function 
    (error, movies) {
      if (error) { console.log(error); }
       res.send({
        movies: movies
      })
    })
  })

  // add a new movie
 app.post('/movies', (req, res) => {
    const movie = new Movie({
      name: req.body.name,
      description: req.body.description,
      release_year: req.body.release_year,
      genre: req.body.genre
    })

    movie.save(function (error, movie) {
      if (error) { console.log(error); }
      res.send(movie)
    })
  })
}
```

将`controllers/users.js`中的内容替换如下:

```js
const User = require("../models/User");
const config = require('./../config/Config');
const passport = require('passport');

module.exports.controller = (app) => {
  // local strategy
  const LocalStrategy = require('passport-local').Strategy;
  passport.use(new LocalStrategy({
      usernameField: 'email',
      passwordField: 'password'
    },
    function(email, password, done) {
      User.getUserByEmail(email, function(err, user){
        if (err) { return done(err); }
        if (!user) { return done(null, false); }
        User.comparePassword(password, user.password, function(err, 
        isMatch){
          if(isMatch) {
            return done(null, user);
          } else {
            return done(null, false);
          }
        })
      });
    }
  ));

 app.post('/users/login',
    passport.authenticate('local', { failureRedirect: '/users/login' }),
    function(req, res) {
      res.redirect('/');
    });

  passport.serializeUser(function(user, done) {
    done(null, user.id);
  });

  passport.deserializeUser(function(id, done) {
    User.findById(id, function(err, user){
      done(err, user)
    })
  });

  // register a user
 app.post('/users/register', (req, res) => {
    const email = req.body.email;
    const fullname = req.body.fullname;
    const password = req.body.password;
    const role = req.body.role || 'user';
    const newUser = new User({
      email: email,
      fullname: fullname,
      role: role,
      password: password
    })
    User.createUser(newUser, function(error, user) {
      if (error) {
        res.status(422).json({
          message: "Something went wrong. Please try again after some 
          time!"
        });
      }
      res.send({ user: user })
    })
  })
}
```

将`AddMovie.vue`的`script`标签内容替换为以下代码:

```js
<script>
import axios from 'axios';

export default {
  data: () => ({
    valid: true,
    name: '',
    description: '',
    genre: '',
    release_year: '',
    nameRules: [
      v => !!v || 'Movie name is required',
    ],
    genreRules: [
      v => !!v || 'Movie genre year is required',
      v => (v && v.length <= 80) || 'Genre must be less than equal to 
      80 characters.',
    ],
    releaseRules: [
      v => !!v || 'Movie release year is required',
    ],
    select: null,
    years: [
      '2018',
      '2017',
      '2016',
      '2015',
    ],
  }),
  methods: {
    submit() {
      if (this.$refs.form.validate()) {
        return axios({
          method: 'post',
          data: {
            name: this.name,
            description: this.description,
            release_year: this.release_year,
            genre: this.genre,
          },
 url: '/movies',
          headers: {
            'Content-Type': 'application/json',
          },
        })
          .then(() => {
            this.$swal(
              'Great!',
              'Movie added successfully!',
              'success',
            );
            this.$router.push({ name: 'Home' });
            this.$refs.form.reset();
          })
          .catch(() => {
            this.$swal(
              'Oh oo!',
              'Could not add the movie!',
              'error',
            );
          });
      }
      return true;
    },
    clear() {
      this.$refs.form.reset();
    },
  },
};
</script>
```

将`Home.vue`的`script`标签内容替换为以下代码:

```js
<script>
import axios from 'axios';

export default {
  name: 'Movies',
  data() {
    return {
      movies: [],
    };
  },
  mounted() {
    this.fetchMovies();
  },
  methods: {
    async fetchMovies() {
      return axios({
        method: 'get',
 url: '/movies',
      })
        .then((response) => {
          this.movies = response.data.movies;
        })
        .catch(() => {
        });
    },
  },
};
</script>
```

将`Login.vue`的`script`标签内容替换为以下代码:

```js
<script>
  import axios from 'axios';
  import bus from "./../bus.js";

  export default {
    data: () => ({
      valid: true,
      email: '',
      password: '',
      emailRules: [
        (v) => !!v || 'E-mail is required',
        (v) => /^\w+([\.-]?\w+)*@\w+([\.-]?\w+)*(\.\w{2,3})+$/.test(v) 
        || 'E-mail must be valid'
      ],
      passwordRules: [
        (v) => !!v || 'Password is required',
      ]
    }),
    methods: {
      async submit () {
        if (this.$refs.form.validate()) {
          return axios({
            method: 'post',
            data: {
              email: this.email,
              password: this.password
            },
 url: '/users/login',
            headers: {
              'Content-Type': 'application/json'
            }
          })
          .then((response) => {
            localStorage.setItem('jwtToken', response.data.token)
            this.$swal("Good job!", "You are ready to start!", 
            "success");
            bus.$emit("refreshUser");
            this.$router.push({ name: 'Home' });
          })
          .catch((error) => {
            const message = error.response.data.message;
            this.$swal("Oh oo!", `${message}`, "error")
          });
        }
      },
      clear () {
        this.$refs.form.reset()
      }
    }
  }
</script>
```

将`Register.vue`的`script`标签内容替换为以下代码:

```js
<script>
  import axios from 'axios';
  export default {
    data: () => ({
      e1: false,
      valid: true,
      fullname: '',
      email: '',
      password: '',
      confirm_password: '',
      fullnameRules: [
        (v) => !!v || 'Fullname is required'
      ],
      emailRules: [
        (v) => !!v || 'E-mail is required',
        (v) => /^\w+([\.-]?\w+)*@\w+([\.-]?\w+)*(\.\w{2,3})+$/.test(v) 
        || 'E-mail must be valid'
      ],
      passwordRules: [
        (v) => !!v || 'Password is required'
      ]
    }),
    methods: {
      async submit () {
        if (this.$refs.form.validate()) {
          return axios({
            method: 'post',
            data: {
              fullname: this.fullname,
              email: this.email,
              password: this.password
            },
 url: '/users/register',
            headers: {
              'Content-Type': 'application/json'
            }
          })
          .then((response) => {
            this.$swal(
              'Great!',
              `You have been successfully registered!`,
              'success'
            )
            this.$router.push({ name: 'Home' })
          })
          .catch((error) => {
            const message = error.response.data.message;
            this.$swal("Oh oo!", `${message}`, "error")
          });
        }
      },
      clear () {
        this.$refs.form.reset()
      }
    }
  }
</script>
```

最后，我们不再需要使用代理，所以我们可以从`webpack.dev.conf.js`中删除前面设置的代理。

用以下代码替换`devServer`内的内容:

```js
devServer: {
    clientLogLevel: 'warning',
    historyApiFallback: {
      rewrites: [
        { from: /.*/, to: path.posix.join(config.dev.assetsPublicPath, 
        'index.html') },
      ],
    },
    hot: true,
    contentBase: false, // since we use CopyWebpackPlugin.
    compress: true,
    host: HOST || config.dev.host,
    port: PORT || config.dev.port,
    open: config.dev.autoOpenBrowser,
    overlay: config.dev.errorOverlay
      ? { warnings: false, errors: true }
      : false,
    publicPath: config.dev.assetsPublicPath,
    quiet: true, // necessary for FriendlyErrorsPlugin
    watchOptions: {
      poll: config.dev.poll,
    }
  },
```

这些更新后，让我们用下面的命令再次构建我们的应用程序:

```js
$ npm run build
```

我们的应用程序应该像预期的那样工作。

由于我们的应用程序是一个**单页应用程序**(**SPA**)，当我们浏览嵌套路由并重新加载页面时，我们将得到一个错误。 例如，如果我们通过点击主页上的链接来浏览`http://localhost:8081/contact`页面，它就会工作。 但是，如果我们尝试直接导航到`http://localhost:8081/contact`页面，我们将得到一个错误，因为这是一个 SPA，这意味着浏览器只呈现静态的`index.html`文件。 当我们试图访问`/contact`页面时，它将查找名为`contact`的页面，该页面并不存在。

为此，我们需要添加一个中间件，当我们尝试直接重载页面或尝试使用动态 id 访问页面时，它作为回退并呈现相同的`index.html`文件。

`npm`提供了一个中间件来服务于我们的目的。 让我们继续并安装以下包:

```js
$ npm install connect-history-api-fallback --save
```

安装完成后，让我们修改我们的`server.js`文件来使用中间件:

```js
...
const passport = require('passport');
const serveStatic = require('serve-static');
const history = require('connect-history-api-fallback');
const app = express();
const router = express.Router();

...

// Include controllers
fs.readdirSync("controllers").forEach(function (file) {
  if(file.substr(-3) == ".js") {
    const route = require("./controllers/" + file)
    route.controller(app)
  }
})
app.use(history());
app.use(serveStatic(__dirname + "/dist"));
...
```

有了这些设施，我们现在应该可以直接进入所有的路线。 现在我们还可以重新加载页面。

Since we are building our Vue.js components and running our app solely on the Node.js server, whenever we make a change to the Vue.js components, we will need to build the application again with the `npm run build` command.

# 护照的本地策略

Passport 的本地战略很容易整合。 和往常一样，让我们按照如下方式开始安装这个策略。

# 安装护照的本地策略

我们可以通过运行以下命令来安装 passport 的 Local Strategy:

```js
$ npm install passport-local --save
```

下面的代码应该将这个包添加到您的包中。 json 文件:

```js
...
"node-sass": "^4.7.2",
"nodemon": "^1.14.10",
"passport": "^0.4.0",
"passport-local": "^1.0.0",
...
```

# 配置 Passport 的本地策略

配置 Passport 的本地策略有几个步骤。 我们将详细讨论每一步:

1.  为本地认证添加必要的路由。
2.  添加一个中间件方法来检查认证是否成功。

让我们深入了解前面每个步骤的细节。

# 为本地认证添加必要的路由

当我们点击登录按钮时，让我们继续添加必要的路由。 将`controllers/users.js`的内容替换为以下代码:

```js
const User = require('../models/User.js');
const passport = require('passport');
const LocalStrategy = require('passport-local').Strategy;

module.exports.controller = (app) => {
// local strategy
 passport.use(new LocalStrategy({
 usernameField: 'email',
 passwordField: 'password',
 }, (email, password, done) => {
 User.getUserByEmail(email, (err, user) => {
 if (err) { return done(err); }
 if (!user) { return done(null, false); }
 User.comparePassword(password, user.password, (error, isMatch) => {
 if (isMatch) {
 return done(null, user);
 }
 return done(null, false);
 });
 return true;
 });
 }));

// user login
 app.post('/users/login',
 passport.authenticate('local', { failureRedirect: '/users/login' }),
 (req, res) => {
 res.redirect('/');
 });

 passport.serializeUser((user, done) => {
 done(null, user.id);
 });

 passport.deserializeUser((id, done) => {
 User.findById(id, (err, user) => {
 done(err, user);
 });
 });

  // register a user
  app.post('/users/register', (req, res) => {
    const name = req.body.name;
    const email = req.body.email;
    const password = req.body.password;
    const newUser = new User({
      name,
      email,
      password,
    });
    User.createUser(newUser, (error, user) => {
      if (error) {
        res.status(422).json({
          message: 'Something went wrong. Please try again after some time!',
        });
      }
      res.send({ user });
    });
  });
};
```

这里，我们添加了一个用户登录的路由`/users/login`，然后使用`passport.js`本地身份验证机制将用户登录到应用程序。

此外，我们还配置了`passport.js`以在用户日志中使用`username`和`password`时使用 LocalStrategy。

# 安装 express-session

我们需要做的下一件事是设置一个`session`，以便当用户成功登录时，`user`数据可以存储在`session`中，并可以在我们发出其他请求时轻松检索这些数据。 为此，我们需要添加一个名为`express-session`的包。 让我们继续用下面的命令来安装这个包:

```js
$ npm install express-session --save
```

# 配置 express-session

现在，我们已经有了这个包，让我们配置这个包来满足我们在`session`中保存用户的需求。 在其中添加以下代码行。

如果`username`和`password`匹配，则用户对象保存在服务器会话中，并且可以在每次请求中通过`req.user`进行访问。

此外，让我们也更新我们的 vue 文件，因为我们现在不需要护照 JWT 策略。

用以下代码更新`server.js`中的内容:

```js
const express = require('express');
const bodyParser = require('body-parser');
const mongoose = require('mongoose');
const cors = require('cors');
const morgan = require('morgan');
const fs = require('fs');
const session = require('express-session');
const config = require('./config/Config');
const passport = require('passport');
const serveStatic = require('serve-static');
const history = require('connect-history-api-fallback');

const app = express();
const router = express.Router();
app.use(morgan('combined'));
app.use(bodyParser.json());
app.use(cors());

app.use(session({
 secret: config.SECRET,
 resave: true,
 saveUninitialized: true,
 cookie: { httpOnly: false }
}))
app.use(passport.initialize());
app.use(passport.session());

//connect to mongodb
mongoose.connect(config.DB, function() {
  console.log('Connection has been made');
})
.catch(err => {
  console.error('App starting error:', err.stack);
  process.exit(1);
});

// Include controllers
fs.readdirSync("controllers").forEach(function (file) {
  if(file.substr(-3) == '.js') {
    const route = require('./controllers/' + file);
    route.controller(app);
  }
})
app.use(history());
app.use(serveStatic(__dirname + "/dist"));

router.get('/api/current_user', isLoggedIn, function(req, res) {
 if(req.user) {
 res.send({ current_user: req.user })
 } else {
 res.status(403).send({ success: false, msg: 'Unauthorized.' });
 }
})

function isLoggedIn(req, res, next) {
 if (req.isAuthenticated())
 return next();

 res.redirect('/');
 console.log('error! auth failed')
}

router.get('/api/logout', function(req, res){
 req.logout();
 res.send();
});

router.get('/', function(req, res) {
  res.json({ message: 'API Initialized!'});
});

const port = process.env.API_PORT || 8081;
app.use('/', router);
var server = app.listen(port, function() {
  console.log(`api running on port ${port}`);
});

module.exports = server
```

这里，我们用下面的代码块添加了 express-session 的配置:

```js
app.use(session({
 secret: config.SECRET,
 resave: true,
 saveUninitialized: true,
 cookie: { httpOnly: false }
}))
app.use(passport.initialize());
app.use(passport.session());
```

上面的代码块使用保存用户详细信息所需的秘密令牌。 我们将在一个单独的文件中定义这个令牌，以便所有的配置令牌都驻留在一个地方。

因此，让我们继续在`config`目录中创建一个名为`Config.js`的文件，并使用以下代码行:

```js
module.exports = {
 DB: 'mongodb://localhost/movie_rating_app',
 SECRET: 'movieratingappsecretkey'
}
```

我们还添加了一个名为`/api/current_user`的`GET`路由来获取当前登录的用户详细信息。 这个 api 使用一个叫做`isLoggedIn`的中间件方法来检查用户的数据是否在会话中。 如果会话中存在用户数据，则将当前用户详细信息作为响应发回。

我们添加的另一个端点是`/logout`，它简单地注销用户并销毁会话。

因此，有了这个配置，现在我们应该能够使用`passport.js`Local 策略成功登录。

我们现在唯一的问题是无法知道用户是否成功登录。 为此，我们需要显示一些用户信息，如`email`，以表示登录的用户。

为此，我们需要将用户的信息从`Login.vue`传递到`App.vue`，以便在顶部栏中显示用户的电子邮件。 我们可以使用由`Vue`提供的`emit`方法，该方法用于在`Vue`组件之间传递信息。 让我们来配置它。

# 配置释放方法

让我们首先创建一个发送器，它可以在不同的 Vue 组件之间通信。 在`src`目录下创建一个名为`bus.js`的文件，并添加以下内容:

```js
import Vue from 'vue';

const bus = new Vue();

export default bus;
```

现在将`Login.vue`标签中的`script`内容替换为以下代码:

```js
...
<script>
import axios from 'axios';
import bus from './../bus';

export default {
  data: () => ({
    valid: true,
    email: '',
    password: '',
    emailRules: [
      v => !!v || 'E-mail is required',
      v => /\S+@\S+\.\S+/.test(v) || 'E-mail must be valid',
    ],
  }),
  methods: {
    async submit() {
      return axios({
        method: 'post',
        data: {
          email: this.email,
          password: this.password,
        },
        url: 'http://localhost:8081/users/login',
        headers: {
          'Content-Type': 'application/json',
        },
      })
        .then(() => {
          this.$swal('Great!', 'You are ready to start!', 'success');
          bus.$emit('refreshUser');
          this.$router.push({ name: 'Home' });
        })
        .catch((error) => {
          const message = error.response.data.message;
          this.$swal('Oh oo!', `${message}`, 'error');
          this.$router.push({ name: 'Login' });
        });
    },
    clear() {
      this.$refs.form.reset();
    },
  },
};
</script>
```

这里发出一个名为`refreshUser`的方法，该方法将在 App.vue 中定义。 将`App.vue`内内容替换为以下代码:

```js
<template>
  <v-app id="inspire">
    <v-navigation-drawer
      fixed
      v-model="drawer"
      app
    >
      <v-list dense>
        <router-link v-bind:to="{ name: 'Home' }" class="side_bar_link">
          <v-list-tile>
            <v-list-tile-action>
              <v-icon>home</v-icon>
            </v-list-tile-action>
            <v-list-tile-content>Home</v-list-tile-content>
          </v-list-tile>
        </router-link>
        <router-link v-bind:to="{ name: 'Contact' }" class="side_bar_link">
          <v-list-tile>
            <v-list-tile-action>
              <v-icon>contact_mail</v-icon>
            </v-list-tile-action>
            <v-list-tile-content>Contact</v-list-tile-content>
          </v-list-tile>
        </router-link>
      </v-list>
    </v-navigation-drawer>
    <v-toolbar color="indigo" dark fixed app>
      <v-toolbar-side-icon @click.stop="drawer = !drawer"></v-toolbar-side-icon>
      <v-toolbar-title>Home</v-toolbar-title>
      <v-spacer></v-spacer>
      <v-toolbar-items class="hidden-sm-and-down">
 <v-btn id="add_movie_link" flat v-bind:to="{ name: 'AddMovie' }"
 v-if="current_user">
 Add Movie
 </v-btn>
 <v-btn id="user_email" flat v-if="current_user">{{ current_user.email }}</v-btn>
 <v-btn flat v-bind:to="{ name: 'Register' }" v-if="!current_user" id="register_btn">
 Register
 </v-btn>
 <v-btn flat v-bind:to="{ name: 'Login' }" v-if="!current_user" id="login_btn">Login</v-btn>
 <v-btn id="logout_btn" flat v-if="current_user" @click="logout">Logout</v-btn>
 </v-toolbar-items>
    </v-toolbar>
    <v-content>
      <v-container fluid>
        <div id="app">
          <router-view/>
        </div>
      </v-container>
    </v-content>
    <v-footer color="indigo" app>
      <span class="white--text">&copy; 2018</span>
    </v-footer>
  </v-app>
</template>

<script>
import axios from 'axios';

import img/stylesheets/main.css';
import bus from './bus';

export default {
  data: () => ({
    drawer: null,
    current_user: null,
  }),
  props: {
    source: String,
  },
  mounted() {
 this.fetchUser();
 this.listenToEvents();
 },
  methods: {
    listenToEvents() {
 bus.$on('refreshUser', () => {
 this.fetchUser();
 });
 },
 async fetchUser() {
 return axios({
 method: 'get',
 url: '/api/current_user',
 })
 .then((response) => {
 this.current_user = response.data.current_user;
 })
 .catch(() => {
 });
 },
    logout() {
 return axios({
 method: 'get',
 url: '/api/logout',
 })
 .then(() => {
 bus.$emit('refreshUser');
 this.$router.push({ name: 'Home' });
 })
 .catch(() => {
 });
 },
  },
};
</script>
```

在这里，我们添加了名为`refreshUser`的方法，该方法正在装入的方法中由`App.vue`侦听。 每当用户登录应用程序时，`App.vue`中的`refreshUser`方法就会被调用，并获取登录用户的信息。

此外，我们在顶部栏中显示用户的电子邮件，以便我们可以知道用户是否已登录。

同样，让我们从电影控制器中删除 JWT 身份验证。 将`controllers/movies.js`中的内容替换为以下代码:

```js
const MovieSchema = require('../models/Movie.js');
const Rating = require('../models/Rating.js');

module.exports.controller = (app) => {
  // fetch all movies
  app.get('/movies', (req, res) => {
    MovieSchema.find({}, 'name description release_year genre', (error, movies) => {
      if (error) { console.log(error); }
      res.send({
        movies,
      });
    });
  });

  // fetch a single movie
  app.get('/api/movies/:id', (req, res) => {
    MovieSchema.findById(req.params.id, 'name description release_year genre', (error, movie) => {
      if (error) { console.error(error); }
      res.send(movie);
    });
  });

  // rate a movie
  app.post('/movies/rate/:id', (req, res) => {
    const newRating = new Rating({
      movie_id: req.params.id,
      user_id: req.body.user_id,
      rate: req.body.rate,
    });

    newRating.save((error, rating) => {
      if (error) { console.log(error); }
      res.send({
        movie_id: rating.movie_id,
        user_id: rating.user_id,
        rate: rating.rate,
      });
    });
  });

  // add a new movie
  app.post('/movies', (req, res) => {
    const newMovie = new MovieSchema({
      name: req.body.name,
      description: req.body.description,
      release_year: req.body.release_year,
      genre: req.body.genre,
    });

    newMovie.save((error, movie) => {
      if (error) { console.log(error); }
      res.send(movie);
    });
  });
};
```

有了这个，当用户登录应用程序时，我们应该能够看到以下屏幕:

![](img/2a7fa817-15de-4d8c-acf8-5d78928920ff.png)

# 总结

在本章中，我们介绍了`passport.js`及其工作原理。 我们还介绍了如何在 MEVN 应用程序中使用简单的 JWT 策略，并为用户处理注册和登录。

在下一章中，我们将深入探讨不同的`passport.js`策略，如 Facebook 策略、谷歌策略和 Twitter 策略。