Command Query Responsibility Separation (CQRS) <link rel="stylesheet" type="text/css" href="../Styles/epub.css">

# 第十二章。 命令查询职责分离(CQRS)

在本书中，我们已经使用 CRUD 模式构建了一个简单的博客应用程序:创建、检索、更新和删除。 我们在确保服务处理我们的业务逻辑方面做得很好，而我们的控制器只是进入这些服务的网关。 控制器负责验证请求，然后将请求传递给服务进行处理。 在像这样的小型应用程序中，CRUD 工作得非常好。

但是，当我们处理一个大型应用程序时，它可能具有独特而复杂的保存数据的业务逻辑，那么会发生什么情况呢? 或者我们可能希望在后台启动一些逻辑，这样 UI 就能够调用 api，而不必等待所有业务逻辑完成。 这些都是 CQRS 有意义的领域。 CQRS 可用于隔离和分解复杂的业务逻辑，以同步或异步方式启动该业务逻辑，并组合独立的部分以解决新的业务问题。

js 通过提供两个单独的流来处理 CQRS 的命令方面来实现这个模式:一个命令和一个事件总线，其中以 sagas 的形式添加了一些糖。 在本章中，我们将处理在博客条目中添加关键字元数据的问题。 我们当然可以使用 CRUD 模式来实现这一点，但是让 UI 进行多个 API 调用来存储一个博客条目及其所有关键字，或者甚至让我们的博客条目模块执行这一操作，都会使 UI 和应用程序的业务逻辑复杂化。

相反，我们将博客条目模块转换为使用 CQRS 命令，并使用命令`bus`来执行所有数据持久化，将其从博客条目模块中的服务中删除。 将为我们的关键字创建一个新的实体和模块。 关键字实体将维护最后更新的时间戳和对所有关联条目的引用。 将创建两个新的 api:一个提供“热门关键字”的列表，另一个提供与关键字相关的所有条目的列表。

为了确保 UI 不会遭受任何性能损失，所有关键字实体操作都将异步完成。 关键字将以字符串的形式存储在博客条目实体中，为 UI 提供快速引用，而无需在数据库中查询关键字表。 在开始之前，请确保您在项目中运行了`npm install @nestjs/cqrs`。 要想看到一个可行的例子，记住你可以克隆这本书附带的 Git 仓库:

`git clone https://github.com/backstopmedia/nest-book-example.git`

# 输入模块的命令

为了使更改条目模型的业务逻辑更容易扩展，我们首先需要提取模块服务中的方法，这些方法作为单独的命令更新数据库。 让我们从将博客条目`create`方法转换为 Nest.js CQRS 方式中的命令开始。

```
export class CreateEntryCommand implements ICommand {
    constructor(
        public readonly title: string,
        public readonly content: string,
        public readonly userId: number
    ) {}
}

```

我们的命令是一个实现了`ICommand`接口的简单对象。 `ICommand`接口是由 Nest.js 内部使用的，用来指示一个对象是一个命令。 该文件通常在模块的子目录中创建，模式类似于`commands/impl/`。 现在我们已经完成了一个示例，让我们完成注释模块的其余命令。

```
export class UpdateEntryCommand implements ICommand {
    constructor(
        public readonly id: number,
        public readonly title: string,
        public readonly content: string
    ) {}
}

export class DeleteEntryCommand implements ICommand {
    constructor(
        public readonly id: number
    ) {}
}

```

注意到更新和删除命令的一些区别吗? 对于 update 命令，我们需要知道要更新哪个数据库模型。 同样，对于 delete 命令，我们只需要知道要删除的数据库模型的 id。 在这两种情况下，拥有`userId`都没有意义，因为博客条目永远不能移动到其他用户，而且`userId`对博客条目的删除没有影响。

## 命令处理程序

现在我们有了用于数据库写操作的命令，我们需要一些命令处理程序。 每个命令都应该有一个一对一的伴随处理程序。 命令处理程序很像我们当前的博客条目服务。 它将负责所有的数据库操作。 通常，命令处理程序被放置在模块的子目录中，类似于`commands/handlers`。

```
@CommandHandler(CreateEntryCommand)
export class CreateEntryCommandHandler implements ICommandHandler<CreateEntryCommand> {
    constructor(
        @Inject('EntryRepository') private readonly entryRepository: typeof Entry,
        @Inject('SequelizeInstance') private readonly sequelizeInstance
    ) { }

    async execute(command: CreateEntryCommand, resolve: () => void) {
    }
}

```

命令处理程序是具有单个方法`execute`的简单类，该方法负责处理命令。 实现`ICommandHandler<CreateEntryCommand>`接口有助于确保我们正确地编写命令处理程序。 在我们的例子中，Nest.js 使用了`@CommandHandler`注释来知道这个类是用来处理新的`CreateEntryCommand`命令的。

由于命令处理程序将作为模块服务的临时替代品，因此命令处理程序还需要访问我们的数据库。 这可能取决于您使用的 ORM 和应用程序的配置方式。 此时，我们的命令处理程序实际上不做任何事情。 事实上，使用它会破坏应用程序，因为我们还没有实现`execute`方法的细节。

```
async execute(command: CreateEntryCommand, resolve: () => void) {
    await this.sequelizeInstance.transaction(async transaction => {
        return await this.entryRepository.create<Entry>(command, {
            returning: true,
            transaction
        });
    });

    resolve();
}

```

如果您正在跟踪示例项目，您可能会注意到我们的`execute`方法与博客条目服务的`create`方法非常相似。 事实上，命令处理程序的几乎所有代码都是直接从博客条目服务复制的。 最大的区别是我们不返回值。 相反，所有命令处理程序的`execute`方法都将一个回调方法作为其第二个参数。

js 允许我们用它提供给`execute`方法的回调做一些不同的事情。 在我们的示例中，我们使用 ORM 创建并持久化一个新的博客条目。 一旦事务解决，我们调用`resolve`回调，让 Nest.js 知道我们的命令已经执行完毕。 如果这看起来很眼熟，那是因为在后台的 Nest.js 将我们的`execute`包装在 Promise 中，并将 Promise 自己的`resolve`回调作为`execute`方法的第二个参数传入。

请注意，我们没有获得传递给命令处理程序的`reject`回调。 在调用命令处理程序时，Nest.js 不执行任何类型的错误处理。 由于我们的命令处理程序正在调用我们的 ORM 来将数据存储在数据库中，因此很有可能抛出异常。 如果这种情况发生在当前编写命令处理程序的方式上(取决于所使用的 NodeJS 的版本)，一个`UnhandledPromiseRejectionWarning`警告将被记录到控制台，UI 将一直等待 API 返回，直到它超时。 为了防止这种情况，我们应该将命令处理程序逻辑包装在一个`try...catch`块中。

```
async execute(command: CreateEntryCommand, resolve: () => void) {
    try {
        await this.sequelizeInstance.transaction(async transaction => {
            return await this.entryRepository.create<Entry>(command, {
                returning: true,
                transaction
            });
        });
    } catch (error) {

    } finally {
        resolve();
    }
}

```

注意，我们在`finally`块中调用了`resolve`回调。 这样做是为了确保无论结果如何，命令处理程序都将完成执行，API 也将完成处理。 但是当一个异常从我们的 ORM 中抛出时会发生什么呢? 博客条目没有保存到数据库中，但是由于 API 控制器不知道发生了错误，它将向 UI 返回一个 200 HTTP 状态。 为了防止这种情况，我们可以捕获错误并将其作为参数传递给`resolve`方法。 这可能与 CQRS 模式不一致，但让 UI 知道出了问题比假设 blog 条目已经保存要好。

```
async execute(command: CreateEntryCommand, resolve: (error?: Error) => void) {
    let caught: Error;

    try {
        await this.sequelizeInstance.transaction(async transaction => {
            return await this.entryRepository.create<Entry>(command, {
                returning: true,
                transaction
            });
        });
    } catch (error) {
        caught = error
    } finally {
        resolve(caught);
    }
}

```

**注:**Nest.js 没有提供任何何时必须调用回调方法的规定。 我们可以在`execute`方法的开头调用回调。 js 会将 processing 返回给控制器，这样 UI 就会立即更新，然后再处理`execute`方法的其余部分。

让我们通过创建命令来处理数据库中博客条目的更新和删除，从而完成将博客条目模块转换为 CQRS。

```
@CommandHandler(UpdateEntryCommand)
export class UpdateEntryCommandHandler implements ICommandHandler<UpdateEntryCommand> {
    constructor(
        @Inject('EntryRepository') private readonly entryRepository: typeof Entry,
        @Inject('SequelizeInstance') private readonly sequelizeInstance: Sequelize,
        private readonly databaseUtilitiesService: DatabaseUtilitiesService
    ) { }

    async execute(command: UpdateEntryCommand, resolve: (error?: Error) => void) {
        let caught: Error;

        try {
            await this.sequelizeInstance.transaction(async transaction => {
                let entry = await this.entryRepository.findById<Entry>(command.id, { transaction });
                if (!entry) throw new Error('The blog entry was not found.');

                entry = this.databaseUtilitiesService.assign(
                    entry,
                    {
                        ...command,
                        id: undefined
                    }
                );
                return await entry.save({
                    returning: true,
                    transaction,
                });
            });
        } catch (error) {
            caught = error
        } finally {
            resolve(caught);
        }
    }
}

```

我们的`UpdateEntryCommand`命令的命令处理程序需要对博客条目服务进行一些更改。 由于我们的命令包含正在更新的博客条目的所有数据，包括`id`，所以我们需要剥离`id`，并在将其保存回数据库之前将命令中剩余的值应用到实体。 与上一个命令处理程序一样，我们使用`try...catch`来处理错误，并将抛出的任何异常作为参数传递回`resolve`回调函数。

```
@CommandHandler(DeleteEntryCommand)
export class DeleteEntryCommandHandler implements ICommandHandler<DeleteEntryCommand> {
    constructor(
        @Inject('EntryRepository') private readonly entryRepository: typeof Entry,
        @Inject('SequelizeInstance') private readonly sequelizeInstance: Sequelize
    ) { }

    async execute(command: DeleteEntryCommand, resolve: (error?: Error) => void) {
        let caught: Error;

        try {
            await this.sequelizeInstance.transaction(async transaction => {
                return await this.entryRepository.destroy({
                    where: { id: command.id },
                    transaction,
                });
            });
        } catch (error) {
            caught = error
        } finally {
            resolve(caught);
        }

        resolve();
    }
}

```

我们的`DeleteEntryCommand`的命令处理程序几乎是博客条目服务中的`delete`方法的副本。 现在，我们有三个新命令及其相应的处理程序。 剩下的就是把它们连接起来并开始使用它们。 在这样做之前，我们必须决定在哪里调用这些新命令。

## 调用命令处理程序

文档和关于在 NodeJS 应用程序中分离关注点的普遍共识可能要求我们从博客条目服务调用我们的命令。 这样做会让控制器像现在一样简单，但不会简化服务。 另外，我们将采用的方法是降低服务的复杂性，以便严格地将其用于数据检索和从控制器调用我们的命令。 不管采用哪种方法，使用新命令的第一步是注入 Nest.js`CommandBus`。

**注:**您计划在哪里使用您的命令，无论是控制器还是服务，对实现没有影响。 尽情尝试吧。

```
@Controller()
export class EntryController {
    constructor(
        private readonly entryService: EntryService,
        private readonly commandBus: CommandBus
    ) { }

    @Post('entries')
    public async create(@User() user: IUser, @Body() body: any, @Res() res) {
        if (!body || (body && Object.keys(body).length === 0)) return res.status(HttpStatus.BAD_REQUEST).send('Missing some information.');

        const error = await this.commandBus.execute(new CreateEntryCommand(
            body.title,
            body.content,
            user.id
        ));

        if (error) {
            return res.status(HttpStatus.INTERNAL_SERVER_ERROR).send(result);
        } else {
            return res.set('location', `/entries/${result.id}`).status(HttpStatus.CREATED).send();
        }
    }

```

上面的示例包含两个关键的更改。 首先，我们将`commandBus`添加到构造器中。 Nest.js 将负责为我们注入一个`CommandBus`的实例到这个变量中。 最后一个变化是`create`控制器方法。 我们没有调用博客条目服务中的`create`方法，而是使用命令总线创建并执行一个新的`CreateEntryCommand`。 博客条目控制器的其余实现细节遵循与`create`方法几乎相同的模式。

```
@Controller()
export class EntryController {
    constructor(
        private readonly entryService: EntryService,
        private readonly commandBus: CommandBus
    ) { }

    @Get('entries')
    public async index(@User() user: IUser, @Res() res) {
        const entries = await this.entryService.findAll();
        return res.status(HttpStatus.OK).json(entries);
    }

    @Post('entries')
    public async create(@User() user: IUser, @Body() body: any, @Res() res) {
        if (!body || (body && Object.keys(body).length === 0)) return res.status(HttpStatus.BAD_REQUEST).send('Missing some information.');

        const error = await this.commandBus.execute(new CreateEntryCommand(
            body.title,
            body.content,
            user.id
        ));

        if (error) {
            return res.status(HttpStatus.INTERNAL_SERVER_ERROR).send(result);
        } else {
            return res.set('location', `/entries/${result.id}`).status(HttpStatus.CREATED).send();
        }
    }

    @Get('entries/:entryId')
    public async show(@User() user: IUser, @Entry() entry: IEntry, @Res() res) {
        return res.status(HttpStatus.OK).json(entry);
    }

    @Put('entries/:entryId')
    public async update(@User() user: IUser, @Entry() entry: IEntry, @Param('entryId') entryId: number, @Body() body: any, @Res() res) {
        if (user.id !== entry.userId) return res.status(HttpStatus.NOT_FOUND).send('Unable to find the entry.');
        const error = await this.commandBus.execute(new UpdateEntryCommand(
            entryId,
            body.title,
            body.content,
            user.id
        ));

        if (error) {
            return res.status(HttpStatus.INTERNAL_SERVER_ERROR).send(error);
        } else {
            return res.status(HttpStatus.OK).send();
        }
    }

    @Delete('entries/:entryId')
    public async delete(@User() user: IUser, @Entry() entry: IEntry, @Param('entryId') entryId: number, @Res() res) {
        if (user.id !== entry.userId) return res.status(HttpStatus.NOT_FOUND).send('Unable to find the entry.');
        const error = await this.commandBus.execute(new DeleteEntryCommand(entryId));

        if (error) {
            return res.status(HttpStatus.INTERNAL_SERVER_ERROR).send(error);
        } else {
            return res.status(HttpStatus.OK).send();
        }
    }
}

```

从示例中可以看到，控制器已经更新，因此 blog 条目服务只用于检索，所有修改方法现在都在命令总线上分派命令。 最后需要配置的是博客条目模块。 为了更简单，让我们先设置一个 Typescript 桶，将所有的处理程序作为一个变量导出。

```
export const entryCommandHandlers = [
    CreateEntryCommandHandler,
    UpdateEntryCommandHandler,
    DeleteEntryCommandHandler
];

```

将桶导入博客条目模块，并将模块连接到命令总线。

```
@Module({
    imports: [CQRSModule, EntryModule],
    controllers: [CommentController],
    components: [commentProvider, CommentService, ...CommentCommandHandlers],
    exports: [CommentService]
})
export class EntryModule implements NestModule, OnModuleInit {
    public constructor(
        private readonly moduleRef: ModuleRef,
        private readonly commandBus: CommandBus
    ) {}

    public onModuleInit() {
        this.commandBus.setModuleRef(this.moduleRef);
        this.commandBus.register(CommentCommandHandlers);
    }
}

```

为了将模块连接到命令总线，我们将`CQRSModule`导入到模块定义中，并将`ModuleRef`和`CommandBus`注入到模块类构造函数中。 模块类还需要实现`OnModuleInit`接口。 最后，神奇的事情发生在`onModuleInit`生命周期钩子中。 在实例化我们的模块类之后，Nest.js 会立即执行这个方法。 在方法内部，我们使用`setModuleRef`和`register`将博客条目命令处理程序注册到为该模块创建的命令总线。

**注:**如果您遵循并实现了控制器中命令的调用，您可以从注释服务中删除`create`、`update`和`delete`方法。

![CQRS Comments Flow](../Images/CQRSFlow001.png)

上面的图提供了如何划分入口控制器的命令和查询方面的可视化表示。 当用户向`create`控制器方法发送请求时，处理通过 CQRS 命令总线执行，但仍然使用 ORM 更新数据库。 当用户希望检索所有条目时，条目控制器使用`EntryService`，然后使用 ORM 查询数据库。 CQRS 中的所有命令(`C`)现在都通过命令总线处理，而 CQRS 中的所有查询(`Q`)则继续通过输入服务处理。

# 链接关键词与事件

现在我们已经展示了在 Nest.js CQRS 中创建命令和使用命令总线的基础知识，接下来我们需要处理存储与博客条目相关的关键字。 关键字可以在创建和删除博客条目时添加。 我们可以为关键字创建一个新实体，并让条目实体与关键字实体保持一对多的关系。 然而，这将要求我们的数据库查找从更多的表中拉入更多的数据，并且发送回 UI 的响应将变得更大。 相反，让我们从在博客条目实体上以 JSON 字符串的形式存储关键字开始。 为此，我们需要更新博客条目实体并添加一个新字段。

```
@Table(tableOptions)
export class Entry extends Model<Entry> {

    @Column({
        type: DataType.TEXT,
        allowNull: true,

    })
    public keywords: string;

}

```

新数据库列的 ORM 定义将取决于所使用的 ORM 和数据库服务器。 这里，我们使用的是`TEXT`数据类型。 这种数据类型在许多不同的数据库服务器中得到广泛支持，并对我们可以存储的数据量提供了很大的限制。 例如，Microsoft SQL Server 限制该字段最多为 2^30 - 1 个字符，而 Postgres 没有限制。 由于我们在迁移中使用 ORM，我们还需要创建迁移脚本。 如果您不确定如何做到这一点，请参考 TypeORM 或 Sequelize 章节。

```
export async function up(sequelize) {
    // language=PostgreSQL
    await sequelize.query(`
        ALTER TABLE entries ADD COLUMN keywords TEXT;
    `);

    console.log('*keywords column added to entries table*');
}

export async function down(sequelize) {
    // language=PostgreSQL
    await sequelize.query(`
        ALTER TABLE entries DROP COLUMN keywords;
    `);
}

```

如果您按照下面的步骤操作，条目数据库表现在应该有一个关键字列。 在 blog 条目控制器中测试`index`API 现在应该返回带有关键字值的对象。 我们仍然需要更新博客条目命令、命令处理程序和控制器，以处理新的和更新的博客条目的关键字。

```
@Controller()
export class EntryController {

    @Post('entries')
    public async create(@User() user: IUser, @Body() body: any, @Res() res) {
        if (!body || (body && Object.keys(body).length === 0)) return res.status(HttpStatus.BAD_REQUEST).send('Missing some information.');

        const error = await this.commandBus.execute(new CreateEntryCommand(
            body.title,
            body.content,
            body.keywords,
            user.id
        ));

        if (error) {
            return res.status(HttpStatus.INTERNAL_SERVER_ERROR).send(result);
        } else {
            return res.set('location', `/entries/${result.id}`).status(HttpStatus.CREATED).send();
        }
    }

    @Put('entries/:entryId')
    public async update(@User() user: IUser, @Entry() entry: IEntry, @Param('entryId') entryId: number, @Body() body: any, @Res() res) {
        if (user.id !== entry.userId) return res.status(HttpStatus.NOT_FOUND).send('Unable to find the entry.');
        const error = await this.commandBus.execute(new UpdateEntryCommand(
            entryId,
            body.title,
            body.content,
            body.keywords,
            user.id
        ));

        if (error) {
            return res.status(HttpStatus.INTERNAL_SERVER_ERROR).send(error);
        } else {
            return res.status(HttpStatus.OK).send();
        }
    }
}

```

博客条目控制器将接受关键字作为字符串数组。 这将有助于保持 UI 的简单性，并防止 UI 不得不执行任意字符串解析。

```
export class CreateEntryCommand implements ICommand, IEntry {
    constructor(
        public readonly title: string,
        public readonly content: string,
        public readonly keywords: string[],
        public readonly userId: number
    ) {}
}

export class UpdateEntryCommand implements ICommand, IEntry {
    constructor(
        public readonly id: number,
        public readonly title: string,
        public readonly content: string,
        public readonly keywords: string[],
        public readonly userId: number
    ) {}
}

```

更新`CreateEntryCommand`和`UpdateEntryCommand`命令以接受新属性`keywords`。 我们维护字符串数组类型，以便将命令的处理工作转移给命令处理程序。

```
@CommandHandler(CreateEntryCommand)
export class CreateEntryCommandHandler implements ICommandHandler<CreateEntryCommand> {

    async execute(command: CreateEntryCommand, resolve: (error?: Error) => void) {
        let caught: Error;

        try {
            await this.sequelizeInstance.transaction(async transaction => {
                return await this.EntryRepository.create<Entry>({
                    ...command,
                    keywords: JSON.stringify(command.keywords)
                }, {
                    returning: true,
                    transaction
                });
            });
        } catch (error) {
            caught = error;
        } finally {
            resolve(caught);
        }
    }
}

@CommandHandler(UpdateEntryCommand)
export class UpdateEntryCommandHandler implements ICommandHandler<UpdateEntryCommand> {

    async execute(command: UpdateEntryCommand, resolve: (error?: Error) => void) {
        let caught: Error;

        try {
            await this.sequelizeInstance.transaction(async transaction => {
                let comment = await this.EntryRepository.findById<Entry>(command.id, { transaction });
                if (!comment) throw new Error('The comment was not found.');

                comment = this.databaseUtilitiesService.assign(
                    comment,
                    {
                        ...command,
                        id: undefined,
                        keywords: JSON.stringify(command.keywords)
                    }
                );
                return await comment.save({
                    returning: true,
                    transaction,
                });
            });
        } catch (error) {
            caught = error;
        } finally {
            resolve(caught);
        }
    }
}

```

已经更新了`CreateEntryCommandHandler`和`UpdateEntryCommandHandler`命令处理程序，将关键字字符串数组转换为 JSON 字符串。 关键字还需要单独存储在它们自己的表中，表中包含它们所应用的博客条目列表和最近更新的日期。 为此，我们需要创建一个带有实体的 new Nest.js 模块。 稍后我们将回来添加更多的功能。 首先，创建新的实体。

```
const tableOptions: IDefineOptions = { timestamp: true, tableName: 'keywords' } as IDefineOptions;

@DefaultScope({
    include: [() => Entry]
})
@Table(tableOptions)
export class Keyword extends Model<Keyword> {
    @PrimaryKey
    @AutoIncrement
    @Column(DataType.BIGINT)
    public id: number;

    @Column({
        type: DataType.STRING,
        allowNull: false,
        validate: {
            isUnique: async (value: string, next: any): Promise<any> => {
                const isExist = await Keyword.findOne({ where: { keyword: value } });
                if (isExist) {
                    const error = new Error('The keyword already exists.');
                    next(error);
                }
                next();
            },
        },
    })
    public keyword: string;

    @CreatedAt
    public createdAt: Date;

    @UpdatedAt
    public updatedAt: Date;

    @DeletedAt
    public deletedAt: Date;

    @BelongsToMany(() => Entry, () => KeywordEntry)
    public entries: Entry[];

    @BeforeValidate
    public static validateData(entry: Entry, options: any) {
        if (!options.transaction) throw new Error('Missing transaction.');
    }
}

```

`BelongsToMany`装饰器用于将关键字连接到许多不同的博客条目。 我们不会在博客条目表中放置`BelongsToMany`列，因为我们使用字符串列来保持快速查找。 参数`() => KeywordEntry`告诉 ORM，我们将使用`KeywordEntry`实体来存储关联。 我们还需要创建实体。

```
const tableOptions: IDefineOptions = { timestamp: true, tableName: 'keywords_entries', deletedAt: false, updatedAt: false } as IDefineOptions;

@Table(tableOptions)
export class KeywordEntry extends Model<KeywordEntry> {
    @ForeignKey(() => Keyword)
    @Column({
        type: DataType.BIGINT,
        allowNull: false
    })
    public keywordId: number;

    @ForeignKey(() => Entry)
    @Column({
        type: DataType.BIGINT,
        allowNull: false
    })
    public entryId: number;

    @CreatedAt
    public createdAt: Date;
}

```

ORM 将使用`@ForeignKey`装饰器将数据库表中的条目链接到`keywords`和`entries`表。 我们还增加了一个`createdAt`专栏，帮助我们找到链接到博客条目的最新关键字。 我们将使用它来创建“热门关键字”列表。 接下来，创建迁移脚本，将新表添加到数据库中。

```
export async function up(sequelize) {
    // language=PostgreSQL
    await sequelize.query(`
        CREATE TABLE "keywords" (
            "id" SERIAL UNIQUE PRIMARY KEY NOT NULL,
            "keyword" VARCHAR(30) UNIQUE NOT NULL,
            "createdAt" TIMESTAMP NOT NULL,
            "updatedAt" TIMESTAMP NOT NULL,
            "deletedAt" TIMESTAMP
        );
        CREATE TABLE "keywords_entries" (
            "keywordId" INTEGER NOT NULL
                CONSTRAINT "keywords_entries_keywordId_fkey"
                REFERENCES keywords
                ON UPDATE CASCADE ON DELETE CASCADE,
            "entryId" INTEGER NOT NULL
                CONSTRAINT "keywords_entries_entryId_fkey"
                REFERENCES entries
                ON UPDATE CASCADE ON DELETE CASCADE,
            "createdAt" TIMESTAMP NOT NULL,
            UNIQUE("keywordId", "entryId")
        );
  `);

    console.log('*Table keywords created!*');
}

export async function down(sequelize) {
    // language=PostgreSQL
    await sequelize.query(`DROP TABLE keywords_entries`);
    await sequelize.query(`DROP TABLE keywords`);
}

```

我们的迁移脚本在`keywords_entries`表中包含一个惟一的约束，以确保我们不会多次链接相同的关键字和博客条目。 列定义的`ON DELETE CASCADE`部分将确保在删除博客条目时，关键字链接也将被删除。 这意味着当博客条目被删除时，我们不需要创建任何代码来处理断开链接的关键字。 请确保将新的数据库实体添加到数据库提供程序中。

```
export const databaseProvider = {
    provide: 'SequelizeInstance',
    useFactory: async () => {
        let config;
        switch (process.env.NODE_ENV) {
            case 'prod':
            case 'production':
            case 'dev':
            case 'development':
            default:
                config = databaseConfig.development;
        }

        const sequelize = new Sequelize(config);
        sequelize.addModels([User, Entry, Comment, Keyword, KeywordEntry]);
        /* await sequelize.sync(); */
        return sequelize;
    },
};

```

最后，创建关键字 provider 和模块。

```
export const keywordProvider = {
    provide: 'KeywordRepository',
    useValue: Keyword,
};

export const keywordEntryProvider = {
    provide: 'KeywordEntryRepository',
    useValue: KeywordEntry
};

@Module({
    imports: [],
    controllers: [],
    components: [keywordProvider, keywordEntryProvider],
    exports: []
})
export class KeywordModule {}

```

现在我们有了一个工作的关键字模块，我们可以开始考虑如何构造用于存储关键字的应用程序逻辑。 为了保持 CQRS 模式，我们可以在关键字模块中创建新的命令和命令处理程序。 然而，Nest.js 在命令总线的所有实例上强加了模块隔离。 这意味着命令处理程序必须在执行命令的同一个模块中注册。 例如，如果我们试图从博客条目控制器执行一个关键字命令，Nest.js 将抛出一个异常，指示没有为该命令注册处理程序。 这就是 Nest.js CQRS 中的事件发挥作用的地方。 事件总线不是孤立的。 事实上，事件总线允许从任何模块执行事件，无论是否为它们注册了处理程序。

## 关键字的事件

事件可以被认为是有一些区别的命令。 除了不在模块范围内，它们还是异步的，通常由模型或实体分派，每个事件可以有任意数量的事件处理程序。 这使得它们非常适合在创建和更新博客条目时处理关键字数据库表的后台更新。

在开始编写代码之前，让我们先考虑一下我们希望应用程序如何工作。 当创建一个新的博客条目时，应用程序需要通知关键字模块一个博客条目已经与一个关键字相关联。 我们应该让关键字模块来决定关键字是新的、需要创建还是已经存在、只需要更新。 同样的逻辑应该适用于对博客条目的更新，但如果我们不尝试确定哪些关键字是新的，哪些已经删除，我们可以使博客条目的更新过程更简单。 为了支持这两种场景，我们应该创建一个通用事件来更新博客条目的所有关键字链接。

现在，我们已经基本了解了我们试图实现的逻辑，我们可以构建事件类。 就像命令一样，CQRS 事件特性需要事件的基本类。 事件文件通常以类似于`events/impl/`的模式在模块的子目录中创建。

```
export class UpdateKeywordLinksEvent implements IEvent {
    constructor(
        public readonly entryId: number,
        public readonly keywords: string[]
    ) { }
}

```

事件类应该与我们在本章前面编写的命令类非常相似。 不同之处在于事件类实现了`IEvent`接口，让 Nest.js 知道这些类的实例是 CQRS 事件。 我们还需要为这些事件设置处理程序。 就像命令处理程序一样，我们的事件处理程序将负责所有的数据库操作。 通常，事件处理程序被放置在模块的子目录中，类似于`events/handlers`。

```
@EventsHandler(UpdateKeywordLinksEvent)
export class UpdateKeywordLinksEventHandler implements IEventHandler<UpdateKeywordLinksEvent> {
    constructor(
        @Inject('KeywordRepository') private readonly keywordRepository: typeof Keyword,
        @Inject('SequelizeInstance') private readonly sequelizeInstance: Sequelize,
    ) { }

    async handle(event: UpdateKeywordLinksEvent) {
    }
}

```

事件处理程序是具有单个方法`handle`的简单类，该方法负责处理事件。 实现`IEventHandler<UpdateKeywordLinksEvent>`接口有助于确保正确地编写事件处理程序。 在我们的例子中，Nest.js 使用了`@EventsHandler`注释来知道这个类是用来处理新的`UpdateKeywordLinksEvent`事件的。

我们的事件处理程序与命令处理程序之间的一个关键区别是，事件处理程序不获取回调方法作为第二个参数。 Nest.js 将异步调用`handle`方法。 它不会等待它完成，它不会尝试捕获任何返回值，它不会捕获或处理调用我们的`handle`方法可能导致的任何错误。 这并不是说我们不应该使用`try...catch`来防止任何类型的错误导致 NodeJS 的问题。

对于更新链接事件处理程序，我们应该将逻辑拆分为单独的方法，以使类更易于阅读和管理。 让我们编写`handle`方法，以便它遍历所有关键字，并确保关键字存在，并且博客条目与关键字相关联。 最后，我们应该确保博客条目不与任何不在事件`keywords`数组中的关键字相关联。

```
@EventsHandler(UpdateKeywordLinksEvent)
export class UpdateKeywordLinksEventHandler implements IEventHandler<UpdateKeywordLinksEvent> {
    constructor(
        @Inject('KeywordRepository') private readonly keywordRepository: typeof Keyword,
        @Inject('SequelizeInstance') private readonly sequelizeInstance: Sequelize,
    ) { }

    async handle(event: UpdateKeywordLinksEvent) {
        try {
            await this.sequelizeInstance.transaction(async transaction => {
                let newKeywords: string[] = [];
                let removedKeywords: Keyword[] = [];

                const keywordEntities = await this.keywordRepository.findAll({
                    include: [{ model: Entry, where: { id: event.entryId }}],
                    transaction
                });

                keywordEntities.forEach(keywordEntity => {
                    if (event.keywords.indexOf(keywordEntity.keyword) === -1) {
                        removedKeywords.push(keywordEntity);
                    }
                });

                event.keywords.forEach(keyword => {
                    if (keywordEntities.findIndex(keywordEntity => keywordEntity.keyword === keyword) === -1) {
                        newKeywords.push(keyword)
                    }
                });

                await Promise.all(
                    newKeywords.map(
                        keyword => this.ensureKeywordLinkExists(transaction, keyword, event.entryId)
                    )
                );
                await Promise.all(
                    removedKeywords.map(
                        keyword => keyword.$remove('entries', event.entryId, { transaction })
                    )
                );
            });
        } catch (error) {
            console.log(error);
        }
    }

    async ensureKeywordLinkExists(transaction: Transaction, keyword: string, entryId: number) {
        const keywordEntity = await this.ensureKeywordExists(transaction, keyword);
        await keywordEntity.$add('entries', entryId, { transaction });
    }

    async ensureKeywordExists(transaction: Transaction, keyword: string): Promise<Keyword> {
        const result = await this.keywordRepository.findOrCreate<Keyword>({
            where: { keyword },
            transaction
        });
        return result[0];
    }
}

```

事件处理程序逻辑从查找博客条目当前链接到的所有关键字开始。 我们循环遍历这些，并取出任何不在新关键字数组中的内容。 为了找到所有新的关键字，我们在事件中循环遍历关键字数组，以找到那些不在`keywordEntities`数组中的关键字。 通过`ensureKeywordLinkExists`方法处理新的关键词。 `ensureKeywordLinkExists`使用`ensureKeywordExists`在关键字数据库表中创建或查找关键字，并将博客条目添加到关键字条目数组中。 `$add`和`$remove`方法由`sequelize-typescript`提供，用于快速添加和删除博客条目，而无需查询博客条目。 所有处理都使用事务来完成，以确保任何错误都会取消所有数据库更新。 如果发生错误，数据库将失去同步，但由于我们处理的是元数据，这不是什么大问题。 我们将错误注销，以便应用程序管理员知道他们需要重新同步元数据。

即使我们只有一个事件处理程序，我们仍然应该创建一个 Typescript 桶来将它导出到一个数组中。 这将确保以后添加新事件是一个简单的过程。

```
export const keywordEventHandlers = [
    UpdateKeywordLinksEventHandler,
    RemoveKeywordLinksEventHandler
];

```

在关键字模块中导入桶并连接事件总线。

```
@Module({
    imports: [CQRSModule],
    controllers: [],
    components: [keywordProvider, ...keywordEventHandlers],
    exports: []
})
export class KeywordModule implements OnModuleInit {
    public constructor(
        private readonly moduleRef: ModuleRef,
        private readonly eventBus: EventBus
    ) {}

    public onModuleInit() {
        this.eventBus.setModuleRef(this.moduleRef);
        this.eventBus.register(keywordEventHandlers);
    }
}

```

在模块中，导入`CQRSModule`并添加`ModuleRef`和`EventBus`作为构造函数参数。 实现`OnModuleInit`接口，创建`onModuleInit`方法。 在`onModuleInit`方法中，我们使用`setModuleRef`将事件总线的模块引用设置为当前模块，并使用`register`注册所有的事件处理程序。 记住也要将事件处理程序添加到`components`数组中，否则 Nest.js 将无法实例化事件处理程序。 现在，我们已经在关键字模块中编写并链接了事件和事件处理程序，现在可以开始调用事件来存储和更新数据库中的关键字链接了。

## 调用事件处理程序

事件处理程序是从数据模型调用的。 数据模型通常是表示存储在数据库中的数据的简单类。 Nest.js 对数据模型的一个规定是，它们必须扩展`AggregateRoot`抽象类。 根据您正在使用的 ORM 以及它的配置方式，您可能能够也可能不能为此目的重用现有的数据模型。 因为我们的示例使用 Sequelize，所以`sequelize-typescript`包需要我们的数据模型扩展`Model`类。 在 Typescript 中，类只能扩展另一个类。 我们需要创建一个单独的数据模型来调用事件处理程序。

```
export class EntryModel extends AggregateRoot {
  constructor(private readonly id: number) {
    super();
  }

  updateKeywordLinks(keywords: string[]) {
    this.apply(new UpdateKeywordLinksEvent(this.id, keywords));
  }
}

```

我们在博客条目模块中创建数据模型，因为我们将在创建和更新博客条目时调用事件。 该数据模型包含一个方法`updateKeywordLinks,`，用于在创建或更新 blog 条目时刷新 blog 条目的关键字链接。 如果需要新的事件，我们将向模型中添加更多的方法来处理调用这些事件。 `updateKeywordLinks`方法实例化我们创建的事件，并使用事件实例调用`AggregateRoot`抽象类中的`apply`方法。

对于命令，我们使用命令总线直接`execute`到我们的命令。 对于事件，我们采取一种不那么直接的方法，使用`EventPublisher`将数据模型链接到事件总线，然后将在数据模型中创建的方法调用到`apply`事件。 让我们更新`CreateEntryCommandHandler`以更好地了解正在发生的事情。

```
@CommandHandler(CreateEntryCommand)
export class CreateEntryCommandHandler implements ICommandHandler<CreateEntryCommand> {
    constructor(
        @Inject('EntryRepository') private readonly EntryRepository: typeof Entry,
        @Inject('SequelizeInstance') private readonly sequelizeInstance: Sequelize,
        private readonly eventPublisher: EventPublisher
    ) { }

    async execute(command: CreateEntryCommand, resolve: (error?: Error) => void) {
        let caught: Error;

        try {
            const entry = await this.sequelizeInstance.transaction(async transaction => {
                return await this.EntryRepository.create<Entry>({
                    ...command,
                    keywords: JSON.stringify(command.keywords)
                }, {
                    returning: true,
                    transaction
                });
            });

            const entryModel = this.eventPublisher.mergeObjectContext(new EntryModel(entry.id));
            entryModel.updateKeywordLinks(command.keywords);
            entryModel.commit();
        } catch (error) {
            caught = error;
        } finally {
            resolve(caught);
        }
    }
}

```

命令处理程序构造函数已经更新，以注入一个 Nest.js`EventPublisher`实例。 `EventPublisher`有两个我们关心的方法:`mergeClassContext`和`mergeObjectContext`。 这两种方法都可以实现相同的结果，只是方式不同。 在我们的示例中，我们使用`mergeObjectContext`将数据模型的新实例与事件总线合并。 这为数据模型实例提供了一个`publish`方法，该方法在抽象`AggregateRoot`类中用于事件总线上的`publish`新事件。

事件永远不会立即被发送。 当调用`updateKeywordLinks`时，所创建的事件被放入一个队列中。 当我们调用数据模型上的`commit`方法时，事件队列将被刷新。 如果发现事件处理程序没有触发，请检查以确保您已经调用了数据模型上的`commit`方法。

我们可以在事件发布器上使用`mergeClassContext`方法来实现相同的功能。

```
const Model = this.eventPublisher.mergeClassContext(EntryModel);
const entryModel = new Model(entry.id);
entryModel.updateKeywordLinks(command.keywords);
entryModel.commit();

```

需要对`UpdateEntryCommandHandler`命令处理程序进行相同的更新，以便在更新博客条目时更新关键字链接。

```
@CommandHandler(UpdateEntryCommand)
export class UpdateEntryCommandHandler implements ICommandHandler<UpdateEntryCommand> {
    constructor(
        @Inject('EntryRepository') private readonly EntryRepository: typeof Entry,
        @Inject('SequelizeInstance') private readonly sequelizeInstance: Sequelize,
        private readonly databaseUtilitiesService: DatabaseUtilitiesService,
        private readonly eventPublisher: EventPublisher
    ) { }

    async execute(command: UpdateEntryCommand, resolve: (error?: Error) => void) {
        let caught: Error;

        try {
            await this.sequelizeInstance.transaction(async transaction => {
                let entry = await this.EntryRepository.findById<Entry>(command.id, { transaction });
                if (!entry) throw new Error('The comment was not found.');

                entry = this.databaseUtilitiesService.assign(
                    entry,
                    {
                        ...command,
                        id: undefined,
                        keywords: JSON.stringify(command.keywords)
                    }
                );
                return await entry.save({
                    returning: true,
                    transaction,
                });
            });

            const entryModel = this.eventPublisher.mergeObjectContext(new EntryModel(command.id));
            entryModel.updateKeywordLinks(command.keywords);
            entryModel.commit();
        } catch (error) {
            caught = error;
        } finally {
            resolve(caught);
        }
    }
}

```

如果您已经在自己的项目中进行了后续工作，那么现在应该能够使用新的或现有的关键字创建或更新博客条目，并看到在数据库中创建、更新和删除关键字链接。 当然，我们可以通过添加一个新的 API 来返回它们链接到的所有关键字和博客条目，从而使这些更改更容易查看。

![CQRS Keywords Flow](../Images/CQRSFlow002.png)

上面的图提供了一个关于输入命令处理程序如何工作以保持关键字更新的可视化表示。 注意，控制流是单向的。 命令处理程序使用输入模型调用事件，然后忘记它。 这就是 Nest.js CQRS 中事件总线的异步特性。

# 检索关键字 api

我们需要在关键字模块中创建一个新的控制器和服务，以支持检索关键字。 我们希望允许 UI 列出所有关键字，获得一个特定关键字，并获得一个“热门关键字”列表。 让我们先创建服务。

```
@Injectable()
export class KeywordService implements IKeywordService {
    constructor(@Inject('KeywordRepository') private readonly keywordRepository: typeof Keyword,
                @Inject('KeywordEntryRepository') private readonly keywordEntryRepository: typeof KeywordEntry) { }

    public async findAll(search?: string, limit?: number): Promise<Array<Keyword>> {
        let options: IFindOptions<Keyword> = {};

        if (search) {
            if (!limit || limit < 1 || limit === NaN) {
                limit = 10;
            }

            options = {
                where: {
                    keyword: {
                        [Op.like]: `%${search}%`
                    }
                },
                limit
            }
        }

        return await this.keywordRepository.findAll<Keyword>(options);
    }

    public async findById(id: number): Promise<Keyword | null> {
        return await this.keywordRepository.findById<Keyword>(id);
    }

    public async findHotLinks(): Promise<Array<Keyword>> {
        // Find the latest 5 keyword links
        const latest5 = await this.keywordEntryRepository.findAll<KeywordEntry>({
            attributes: {
                exclude: ['entryId', 'createdAt']
            },
            group: ['keywordId'],
            order: [[fn('max', col('createdAt')), 'DESC']],
            limit: 5
        } as IFindOptions<any>);

        // Find the 5 keywords with the most links
        const biggest5 = await this.keywordEntryRepository.findAll<KeywordEntry>({
            attributes: {
                exclude: ['entryId', 'createdAt']
            },
            group: 'keywordId',
            order: [[fn('count', 'entryId'), 'DESC']],
            limit: 5,
            where: {
                keywordId: {
                    // Filter out keywords that already exist in the latest5
                    [Op.notIn]: latest5.map(keywordEntry => keywordEntry.keywordId)
                }
            }
        } as IFindOptions<any>);

        // Load the keyword table data
        const result = await Promise.all(
            [...latest5, ...biggest5].map(keywordEntry => this.findById(keywordEntry.keywordId))
        );

        return result;
    }
}

```

`findAll`方法接受可选的搜索字符串和限制，可用于过滤关键字。 UI 可以使用它来支持关键字搜索自动完成。 如果搜索时没有指定限制，服务将自动将搜索结果限制为 10 项。 方法将支持加载单个关键字的所有信息，包括相关的条目。 这些方法在其他模块的服务中是比较基本的和模拟的方法。 然而，`findHotLinks`方法有点复杂。

`findHotLinks`方法负责返回最新使用的关键字以及链接最多的博客条目的关键字。 为此，我们需要合并连接表(即`KeywordEntry`数据模型)的 ORM 提供者。 连接表包含关键字和博客条目之间的实际链接，以及我们加入它们的日期。 对于`latest5`，我们根据最大`createdAt`日期对列表排序，以获得一个最新的关键字列表。 `biggest5`按`entryId`的数量排序，生成一个列表，首先包含链接最多的博客条目的关键字。 在这两个列表中，我们按`keywordId`进行分组，以产生一个独特的关键字列表，并将结果限制在前 5 名。 为了确保不产生有重叠的列表，`biggest5`还包含一个 where 子句，以不包含已经包含在`latest5`列表中的任何关键字。

一旦有了这两个列表，我们就重用服务的`findById`方法来为所有找到的关键字加载完整的数据记录。 然后返回这个列表，其中的关键字链接最新，顺序从最新到最老，然后是链接最多的关键字，顺序从最多到最少。 剩下的就是创建一个控制器，这样 UI 就可以利用我们的新查询方法。

**注:**注意`as IFindOptions<any>`。 这是为了解决由`sequelize-typescript`引起的 linting 错误。 你的申请中可能需要这个，也可能不需要。

```
@Controller()
export class KeywordController {
    constructor(
        private readonly keywordService: KeywordService
    ) { }

    @Get('keywords')
    public async index(@Query('search') search: string, @Query('limit') limit: string, @Res() res) {
        const keywords = await this.keywordService.findAll(search, Number(limit));
        return res.status(HttpStatus.OK).json(keywords);
    }

    @Get('keywords/hot')
    public async hot(@Res() res) {
        const keywords = await this.keywordService.findHotLinks();
        return res.status(HttpStatus.OK).json(keywords);
    }

    @Get('keywords/:keywordId')
    public async show(@Param('keywordId') keywordId: string, @Res() res) {
        const keyword = await this.keywordService.findById(Number(keywordId));
        return res.status(HttpStatus.OK).json(keyword);
    }
}

```

控制器包含三个方法，对应于服务中的三个查询方法。 在这三种方法中，我们在服务中调用适当的方法并以 JSON 的形式返回结果。 请注意，`hot`方法列在`show`方法之前。 如果顺序颠倒，调用`/keywords/hot`API 将导致`show`方法执行。 因为 Nest.js 运行在 ExpressJS 之上，所以我们声明控制器方法的顺序很重要。 ExpressJS 总是执行与 UI 请求的路径匹配的第一个路由控制器。

现在，我们有一个应用程序使用了 Nest.js CQRS 来分解业务逻辑，并在异步的环境中实现其中的部分。 应用程序能够对博客条目的创建和更新做出响应，从而改变关键字元数据。 这一切都是通过使用事件而实现的。 但是，还有另一种方法可以使用 sagas 而不是我们创建的事件处理程序来实现同样的目标。

# 链接关键词与传奇

saga 可以被认为是返回命令的特殊事件处理程序。 Sagas 通过利用 RxJS 来接收和响应所有发布到事件总线的事件。 使用`UpdateKeywordLinksEvent`事件处理程序，我们可以在逻辑上将工作划分为两个单独的命令:一个创建关键字链接，另一个删除关键字链接。 由于 saga 返回命令，saga 和命令必须在同一个模块中创建。 否则，命令模块范围将成为一个问题，并且当我们的 saga 试图返回在不同模块中找到的命令时，Nest.js 将抛出异常。 首先，我们需要设置命令和命令处理程序，它们将取代单个事件处理程序。

## 关键字传奇命令

仅仅因为我们使用 sagas 来执行我们的新命令并不会改变我们如何编写这些命令和命令处理程序。 我们将在关键字模块中将`UpdateKeywordLinksEvent`分成两个单独的命令。

```
export class LinkKeywordEntryCommand implements ICommand {
    constructor(
        public readonly keyword: string,
        public readonly entryId: number
    ) { }
}

export class UnlinkKeywordEntryCommand implements ICommand {
    constructor(
        public readonly keyword: string,
        public readonly entryId: number
    ) { }
}

```

这些命令有两个属性:一个`keyword`和一个`entryId`。 这些命令采用一个简单的`keyword`字符串，因为命令处理程序不应该假设关键字已经存在于数据库中。 因为`entryId`是`UpdateKeywordLinksEvent`事件的一个参数，所以已经知道`entryId`存在。

```
@CommandHandler(LinkKeywordEntryCommand)
export class LinkKeywordEntryCommandHandler implements ICommandHandler<LinkKeywordEntryCommand> {
    constructor(
        @Inject('KeywordRepository') private readonly keywordRepository: typeof Keyword,
        @Inject('SequelizeInstance') private readonly sequelizeInstance: Sequelize
    ) { }

    async execute(command: LinkKeywordEntryCommand, resolve: (error?: Error) => void) {
        let caught: Error;

        try {
            await this.sequelizeInstance.transaction(async transaction => {
                const keyword = await this.keywordRepository.findOrCreate({
                    where: {
                        keyword: command.keyword
                    },
                    transaction
                });

                await keyword[0].$add('entries', command.entryId, { transaction });
            });
        } catch (error) {
            caught = error;
        } finally {
            resolve(caught);
        }
    }
}

```

`LinkKeywordEntryCommandHandler`命令处理程序负责确保关键字存在于数据库中，然后使用`sequelize-typescript`提供的`$add`方法通过关键字的 id 将博客条目链接到关键字。

```
@CommandHandler(UnlinkKeywordEntryCommand)
export class UnlinkKeywordEntryCommandHandler implements ICommandHandler<UnlinkKeywordEntryCommand> {
    constructor(
        @Inject('KeywordRepository') private readonly keywordRepository: typeof Keyword,
        @Inject('SequelizeInstance') private readonly sequelizeInstance: Sequelize
    ) { }

    async execute(command: UnlinkKeywordEntryCommand, resolve: (error?: Error) => void) {
        let caught: Error;

        try {
            await this.sequelizeInstance.transaction(async transaction => {
                const keyword = await this.keywordRepository.findOrCreate<Keyword>({
                    where: {
                        keyword: command.keyword
                    },
                    transaction
                });

                await keyword[0].$remove('entries', command.entryId, { transaction });
            });
        } catch (error) {
            caught = error;
        } finally {
            resolve(caught);
        }
    }
}

```

`UnlinkKeywordEntryCommandHandler`命令处理程序负责确保关键字存在于数据库中，然后使用`sequelize-typescript`提供的`$remove`方法根据关键字 id 删除博客条目到该关键字的链接。 这些命令比`UpdateKeywordLinksEventHandler`事件处理程序简单得多。 他们有一个单一的目的，链接或取消链接一个关键字和博客条目。 决定哪些关键字连接和断开连接的繁重工作是为 saga 保留的。 不要忘记在关键字模块中连接命令处理程序。

```
export const keywordCommandHandlers = [
    LinkKeywordEntryCommandHandler,
    UnlinkKeywordEntryCommandHandler
];

@Module({
    imports: [CQRSModule],
    controllers: [KeywordController],
    components: [keywordProvider, keywordEntryProvider, ...keywordEventHandlers, KeywordService, ...keywordCommandHandlers],
    exports: []
})
export class KeywordModule implements OnModuleInit {
    public constructor(
        private readonly moduleRef: ModuleRef,
        private readonly eventBus: EventBus,
        private readonly commandBus: CommandBus
    ) {}

    public onModuleInit() {
        this.commandBus.setModuleRef(this.moduleRef);
        this.commandBus.register(keywordCommandHandlers);
        this.eventBus.setModuleRef(this.moduleRef);
        this.eventBus.register(keywordEventHandlers);
    }
}

```

就像入口模块一样，我们创建了一个 Typescript 桶来将命令处理程序作为数组导出。 它被导入到模块定义中并使用`register`方法注册到命令总线。

## 关键字的传奇

Sagas 总是作为组件类中的公共方法编写，以允许依赖注入。 通常，您将为希望在其中实现 saga 的每个模块创建单个 saga 类，但是在分解复杂的业务逻辑时，多个类是有意义的。 对于更新关键字 saga，我们需要一个 saga 方法来接受`UpdateKeywordLinksEvent`事件并输出多个`LinkKeywordEntryCommand`和`UnlinkKeywordEntryCommand`命令。

```
@Injectable()
export class KeywordSagas {
    constructor(
        @Inject('KeywordRepository') private readonly keywordRepository: typeof Keyword,
        @Inject('SequelizeInstance') private readonly sequelizeInstance: Sequelize,
    ) { }

    public updateKeywordLinks(events$: EventObservable<any>) {
        return events$.ofType(UpdateKeywordLinksEvent).pipe(
            mergeMap(event =>
                merge( // From the rxjs package
                    this.getUnlinkCommands(event),
                    this.getLinkCommands(event)
                )
            )
        );
    }
}

```

`KeywordSagas`类包含单个 saga`updateKeywordLinks`，并使用依赖注入来获取对关键字存储库和 Sequelize 实例的引用。 传递给`updateKeywordLinks`saga 的参数是由 Nest.js 的 CQRS 事件总线提供的。 `EventObservable`是 Nest.js CQRS 提供的一个特殊的观察对象，它包含`ofType`方法。 我们使用这个方法来过滤`events$`可观察对象，所以我们的 saga 将只处理`UpdateKeywordLinksEvent`事件。 如果您忘记使用`ofType`方法，那么您的 saga 将针对应用程序中发布的每个事件被触发。

剩下的部分是严格的 RxJS 功能。 您可以自由地使用任何 RxJS 操作符，只要 saga 发出一个或多个 CQRS 命令。 在我们的传奇中，我们将使用`mergeMap`来平化内部可观察命令流。 不要在这里使用`switchMap`，否则，如果 API 处于高负载下，由于`switchMap`在外部可观察对象多次触发时被取消，命令可能会丢失。 内部可观察对象是两个不同的可观察流的合并:`this.getUnlinkCommands(event)`是一个由`UnlinkKeywordEntryCommand`命令组成的流，`this.getLinkCommands(event)`是一个由`LinkKeywordEntryCommand`命令组成的流。

```
private getUnlinkCommands(event: UpdateKeywordLinksEvent) {
    return from(this.keywordRepository.findAll({
        include: [{ model: Entry, where: { id: event.entryId }}]
    })).pipe(
        // Filter keywordEntities so only those being removed are left
        map(keywordEntities =>
            keywordEntities.filter(keywordEntity => event.keywords.indexOf(keywordEntity.keyword) === -1)
        ),
        // Create new commands for each keywordEntity
        map(keywordEntities => keywordEntities.map(keywordEntity => new UnlinkKeywordEntryCommand(keywordEntity.keyword, event.entryId))),
        switchMap(commands => Observable.of(...commands))
    );
}

private getLinkCommands(event: UpdateKeywordLinksEvent) {
    return from(this.keywordRepository.findAll({
        include: [{ model: Entry, where: { id: event.entryId }}]
    })).pipe(
        // Filter keywordEntities so only those being add are left
        map(keywordEntities =>
            event.keywords.filter(keyword => keywordEntities.findIndex(keywordEntity => keywordEntity.keyword === keyword) === -1)
        ),
        // Create new commands for each keyword
        map(keywords => keywords.map(keyword => new LinkKeywordEntryCommand(keyword, event.entryId))),
        switchMap(commands => Observable.of(...commands))
    );
}

```

`getUnlinkCommands`和`getLinkCommands`方法首先获取现有关键字博客条目链接列表。 我们使用`Observable.fromPromise`是因为我们需要从这些方法中返回一个可观察对象。 这两个命令之间的区别在于过滤的工作方式。 在`getUnlinkCommands`中，我们需要过滤现有关键字博客条目链接列表，以找到那些在事件的关键字数组中不存在的链接。 我们反转`getLinkCommands`中的逻辑并过滤事件中的关键字列表，以找到那些尚未链接到博客条目的关键字。 最后，我们将数组映射为命令并使用`switchMap(commands => Observable.of(...commands))`，这样我们的可观察流就会发出所有的命令，而不是命令数组。 因为唯一的区别是过滤，所以我们可以清理这些，这样就不会查询数据库了。

```
public updateKeywordLinks(events$: EventObservable<any>) {
    return events$.ofType(UpdateKeywordLinksEvent).pipe(
        mergeMap(event => this.compileKeywordLinkCommands(event))
    );
}

private compileKeywordLinkCommands(event: UpdateKeywordLinksEvent) {
    return from(this.keywordRepository.findAll({
        include: [{ model: Entry, where: { id: event.entryId }}]
    })).pipe(
        switchMap(keywordEntities =>
            of(
                ...this.getUnlinkCommands(event, keywordEntities),
                ...this.getLinkCommands(event, keywordEntities)
            )
        )
    );
}

private getUnlinkCommands(event: UpdateKeywordLinksEvent, keywordEntities: Keyword[]) {
    return keywordEntities
        .filter(keywordEntity => event.keywords.indexOf(keywordEntity.keyword) === -1)
        .map(keywordEntity => new UnlinkKeywordEntryCommand(keywordEntity.keyword, event.entryId));
}

private getLinkCommands(event: UpdateKeywordLinksEvent, keywordEntities: Keyword[]) {
    return event.keywords
        .filter(keyword => keywordEntities.findIndex(keywordEntity => keywordEntity.keyword === keyword) === -1)
        .map(keyword => new LinkKeywordEntryCommand(keyword, event.entryId));
}

```

现在我们的 saga 只在数据库中查询一次现有的关键字博客条目链接，并且`getUnlinkCommands`和`getLinkCommands`方法已经大大简化。 这些方法现在获取事件和现有关键字博客条目链接的列表，并返回需要执行的命令数组。 检索现有关键字博客条目链接的繁重工作已经转移到`compileKeywordLinkCommands`方法。 该方法使用`switchMap`将数据库的结果投影到`getUnlinkCommands`和`getLinkCommands`中。 `Observable.of`仍然用于获取命令数组并每次发出一个。 创建和更新博客条目现在将通过 saga 和关键字命令处理所有关键字链接和解除链接。

![CQRS Event Sagas Flow](../Images/CQRSFlow003.png)

上面的图直观地表示了我们的新 sagas 如何将数据库更新的处理返回到关键字模块中的命令总线。 一旦执行了更新关键字链接的事件，saga 将查询数据库以确定要链接和取消链接的关键字，并最终返回适当的命令。 记住，命令处理程序包含一个回调方法，因此它不是显式异步的。 然而，由于它们是从事件总线调用的，因此任何响应都不会传递回 sage 或入口命令总线。

# 总结

CQRS 不仅仅是一个 Nest.js 包。 它是用于设计和布局应用程序的模式。 它要求您将命令、数据的创建和更新、查询、数据的检索和应用程序的各个方面分开。 对于小型应用程序，CQRS 可能会增加很多不必要的复杂性，因此它并不适用于每个应用程序。 对于中型和大型应用程序，CQRS 可以帮助将复杂的业务逻辑分解为更易于管理的部分。

js 提供了两种实现 CQRS 模式的方法，命令和事件总线，并以 sagas 的形式添加了一些糖份。 命令总线将命令执行隔离到每个模块，这意味着命令只能在注册的同一模块中执行。 命令处理程序并不总是异步的，并且限制了应用程序的其他部分对更改做出响应。 为此，Nest.js 提供了事件总线。 事件总线不是与单个模块隔离的，它为同一应用程序的不同模块提供了一种方法，以响应其他模块发布的事件。 事实上，事件可以有任意数量的处理程序，允许业务逻辑在不更改现有代码的情况下轻松扩展。

传说是对模块内事件作出反应的一种不同方式。 Sagas 是一个简单的函数，它侦听事件总线上的事件，并通过返回要执行的命令进行响应。 虽然看起来很简单，但 sagas 允许您使用 RxJS 的强大功能来确定应用程序是否以及如何响应事件。 正如我们在示例应用程序中所做的那样，sagas 并不局限于只返回一种或甚至一种命令类型。

下一次，当您发现自己要编写复杂的代码来执行一些基于用户与应用程序交互方式的业务逻辑时，请考虑尝试 CQRS 模式。 模式的复杂性可能会被应用程序业务逻辑的复杂性或最终复杂性所抵消。

在下一章中，我们将研究两种不同类型项目的架构:服务器应用，以及使用`Angular universal`和 Nest.js 和 Angular 6 的应用。