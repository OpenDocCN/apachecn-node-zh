Node Fundamentals – Part 1  

# 节点基础–第 1 部分

在本章中，您将学习大量有关构建节点应用程序的知识，并将实际构建第一个节点应用程序。这是所有真正有趣的事情开始的地方。

我们将首先了解节点内置的所有模块。这些对象和函数可以让您使用 JavaScript 完成以前无法完成的任务。我们将学习如何做一些事情，例如从文件系统读写，我们将在节点的应用程序中使用这些文件系统来持久化数据。

我们还将关注第三方 npm 模块；这是 Node 如此流行的一个重要原因。npm 模块为您提供了大量可供使用的第三方库，它们也存在一些常见问题。所以你不必一遍又一遍地重写样板代码。在本章中，我们将使用第三方模块来帮助从用户获取输入。

本章将具体涵盖以下主题：

*   模块基础
*   需要自己的文件
*   第三方模块
*   全局模块
*   获取输入

# 模块基础

在本节中，您将最终了解一些 Node.js 代码，我们将通过讨论 Node 中的模块开始讨论。模块是功能的单位，所以假设我创建了一些做类似事情的函数，比如一些有助于解决数学问题的函数，例如，加法、减法和除法。我可以把它们打包成一个模块，称之为 Andrew math，其他人可以利用它。

现在，我们将不讨论如何制作我们自己的模块；事实上，我们将研究如何使用模块，这将通过使用节点中名为`require()`的函数来实现。`require()`函数让我们做三件事：

*   让我们先把 js 节点和它捆绑起来。其中包括 HTTP 模块，它允许我们创建一个 web 服务器，以及`fs`模块，它允许我们访问机器的文件系统。

We will also be using `require()` in later sections to load in third-party libraries, such as Express and Sequelize, which will let us write less code.

*   我们将能够使用预先编写的库来处理复杂的问题，我们所需要做的就是通过调用一些方法来实现`require()`。
*   我们将使用`require()`来要求我们自己的文件。它将使我们能够将应用程序分解为多个更小的文件，这对于构建真实世界的应用程序至关重要。

如果您将所有代码都放在一个文件中，那么测试、维护和更新将非常困难。现在，`require()`没那么糟糕。在本节中，我们将探讨`require()`的第一个用例。

# require（）的用例

我们将看两个内置模块；我们将找出如何需要它们以及如何使用它们，然后我们将开始构建该节点应用程序的过程。

# 应用程序的初始化

我们将在终端内部采取的第一步是创建一个目录来存储所有这些文件。我们将使用`cd Desktop`命令从主目录导航到桌面：

```
cd Desktop
```

然后，我们将创建一个文件夹来存储此项目的所有课程文件。

Now, these lesson files will be available in the resources section for every section, so if you get stuck or your code just isn't working for some reason, you can download the lesson files, compare your files, and figure out where things went wrong.

现在，我们将使用`mkdir`命令创建该文件夹，这是**生成目录**的缩写形式。我们调用文件夹`notes-node`，如下代码所示：

```
mkdir notes-node
```

我们将在 Node 中制作一个 note 应用程序，以便`notes-node`看起来合适。然后我们将`cd`转换为`notes-node`，我们可以开始使用一些内置模块：

```
cd notes-node
```

这些模块是内置的，所以不需要在终端中安装任何东西。我们只需要将它们放在节点文件中即可。

该过程的下一步是在 Atom 文本编辑器中打开该目录。因此，打开我们刚刚在桌面上创建的目录，您将在那里找到它，如以下屏幕截图所示：

![](assets/0c1f5e61-9318-4a46-8fb2-994408a8d2d1.png)

现在，我们需要创建一个文件，并将该文件放在项目的根目录中：

![](assets/9ef115c8-64d7-428a-b25d-28f3441d2057.png)

我们将此文件称为`app.js`，我们的应用程序将从这里开始：

![](assets/9fdc5112-279d-4049-8f40-c7a820d516d2.png)

我们将编写在整个应用程序中使用的其他文件，但这是我们从终端运行的唯一文件。这是我们应用程序的初始化文件。

# 要使用的内置模块 require（）

现在，首先要做的就是使用`console.log`打印`Starting app`，如下代码所示：

```
console.log('Starting app');
```

The only reason we'll do this is to keep track of how our files are executing, and we'll do this only for the first project. Down the line, once you're comfortable with how files get loaded and how they run, we'll be able to remove these `console.log` statements, as they won't be necessary.

调用`console.log`启动应用程序后，我们将使用`require()`加载一个内置模块。

We can get a complete list of all of the built-in modules in the Node.js API docs.

要查看 Node.js API 文档，请访问[nodejs.org/API](http://nodejs.org/api)。当您转到这个 URL 时，会看到一长串内置模块。使用**文件系统**模块，我们将创建一个新文件和**OS**模块。操作系统模块将允许我们获取诸如当前登录用户的用户名之类的内容。

# 在文件系统模块中创建和附加文件

不过，首先，我们将从文件系统模块开始。我们将完成创建文件并附加到文件的过程：

![](assets/5b1f68c0-b22d-4a77-b215-07276083f00c.png)

当您查看内置模块（无论是文件系统还是其他模块）的文档页面时，您将看到一个长长的列表，其中列出了所有可用的不同功能和属性。我们将在本节中使用的是`fs.appendFile`。

如果您点击它，它将带您进入特定的文档，在这里我们可以了解如何使用`appendFile`，如以下屏幕截图所示：

![](assets/83a4ce04-2434-462b-a603-e6a46de862b6.png)

现在，`appendFile`非常简单。我们将向其传递两个字符串参数（如前面的屏幕截图所示）：

*   一个是文件名
*   另一个是我们想要附加到文件中的数据

这就是我们调用`fs.appendFile`所需的全部内容。在我们调用`fs.appendFile`之前，我们需要它。要求的全部要点是让我们加载其他模块。在这种情况下，我们将从`app.js`加载`fs`模块。

让我们使用`const`创建一个常量变量。

Since we'll not be manipulating the code the module sends back, there's no need to use the `var` keyword; we will use the `const` keyword.

然后我们将给它一个名称，`fs`并将其设置为等于`require()`，如下代码所示：

```
const fs = require()
```

在这里，`require()`是一个在 Node.js 文件中可以使用的函数。您不必做任何特殊的事情来调用它，只需按照前面的代码所示调用它即可。在参数列表中，我们只传递一个字符串。

Now, every time you call `require()`, whether you're loading a built-in module, a third-party module, or your own file, you just pass in one string.

在本例中，我们将传入模块名，即`fs`，并在末尾插入分号，如下代码所示：

```
const fs = require('fs');
```

这将告诉节点您想要获取`fs`模块的所有内容并将它们存储在`fs`变量中。此时，我们可以访问`fs`模块上的所有可用功能，我们在文档中对此进行了探讨，包括`fs.appendFile`。

回到 Atom 中，我们可以通过调用`fs.appendFile`来调用`appendFile`，传入我们将使用的两个参数；第一个是文件名，所以我们添加了`greetings.txt`，第二个是要附加到文件中的文本。在本例中，我们将追加`Hello world!`，如下代码所示：

```
fs.appendFile('greetings.txt', 'Hello world!');
```

让我们保存该文件，如前面的命令所示，并从终端运行它以查看发生了什么。

**Warning when running the program on Node v7** If you're running Node v7 or greater, you'll get a little warning when you run the program inside Terminal. Now, on v7, it'll still work, it's just a warning, but you can get rid of it using the following code:

```
// Orignal line 
fs.appendFile('greetings.txt', 'Hello world!');

// Option one
fs.appendFile('greetings.txt', 'Hello world!', function (err){
  if (err) { 
    console.log('Unable to write to file');
  }
});

// Option two
fs.appendFileSync('greetings.txt', 'Hello world!');
```

在前面的代码中，我们有程序中的原始行。

在`Option one`中，这里将添加一个回调作为追加文件的第三个参数。当发生错误或文件也成功写入时，将执行此回调。在选项一中，我们有一个`if`声明；如果出现错误，我们只需在屏幕上打印一条消息，`Unable to write to file`。

现在，前面代码中的第二个选项`Option two`是调用`appendFileSync`，这是一种同步方法（我们将在后面详细讨论）；此函数不接受第三个参数。您可以按前面代码中所示的方式键入它，您将不会得到警告。

因此，如果您看到警告，请选择这两个选项之一；两者的工作原理基本相同。

若您使用的是 v6，那个么您可以继续使用前面代码顶部显示的原始行，尽管您也可以使用该行下面的两个选项中的一个，使您的代码更加经得起未来的考验。

不用担心，我们将在本书中广泛讨论异步和同步函数以及回调函数。我在代码中给你的只是一个模板，你可以在你的文件中写一些东西来删除这个错误。在几章中，您将确切了解这两种方法是什么以及它们是如何工作的。

如果我们在终端`node app.js`中进行附加，我们将看到一些非常酷的东西：

![](assets/2ec51c4b-ece3-4ce3-bb59-73b569219a36.png)

如前面的代码所示，我们得到一条`console.log`语句`Starting app.`。所以我们知道应用程序启动正确。另外，如果我们进入 Atom，我们会看到一个全新的`greetings.txt`文件，如下面的代码所示。这是由`fs.appendFile`创建的文本文件：

```
console.log('Starting app.');

const fs = require('fs');

fs.appendFile('greetings.txt', 'Hello world!');
```

这里，`fs.appendFile`尝试将`greetings.txt`追加到文件中；如果文件不存在，它只会创建它：

![](assets/91fe0afc-82be-45e7-8cf1-71ab8ac7e2c8.png)

你可以看到我们的信息，`Hello world!`在`greetings.txt`文件中，打印到屏幕上。只需几分钟，我们就可以加载一个内置的节点模块，并调用一个函数来创建一个全新的文件。

如果我们通过使用向上箭头键和 e*ENTR*键重新运行命令来调用它，然后我们返回到`greetings.txt`的内容，您可以看到这一次我们有`Hello world!`两次，如下所示：

![](assets/e87eb337-f0a8-4c89-b798-9b58b7a5739d.png)

每次我们运行程序时，它都会追加一次`Hello world!`。我们有一个应用程序可以在文件系统上创建一个全新的文件，如果该文件已经存在，它只需添加到文件系统中即可。

# require（）中的操作系统模块

一旦我们创建并附加了`greetings.txt`文件，我们将定制这个`greeting.txt`文件。为此，我们将探索另一个内置模块。未来我们将使用的不仅仅是`appendFile`。我们将探索其他方法。对于本节，真正的目标是理解`require()`。`require()`函数允许我们加载模块的功能，以便调用它。

我们将使用的第二个模块是操作系统，我们可以在文档中查看它。在操作系统模块中，我们将使用最底层定义的方法 OS.userInfo（[options]）：

![](assets/4701cb5a-ce45-40d1-8cbe-10c9dcdff9b4.png)

将调用 os.userInfo（[options]）方法并返回有关当前登录用户的各种信息，例如用户名，这就是我们将要实现的：

![](assets/dfff1585-133a-45cb-b109-74c1c8c9b000.png)

使用来自操作系统的用户名，我们可以自定义`greeting.txt`文件，这样它就可以说`Hello Gary!`，而不是`Hello world!`。

要开始，我们需要操作系统。这意味着我们将回到原子内部。现在，就在我创建`fs`常量的下方，我将创建一个名为`os`的新常量，将其设置为`require()`；这将作为函数调用，并传递一个参数，即模块名`os`，如下所示：

```
console.log('Starting app.');

const fs = require('fs');
const os = require('os');

fs.appendFile('greetings.txt', 'Hello world!');
```

从这里，我们可以开始调用 OS 模块上可用的方法，例如 OS.userInfo（[可选]）。

让我们创建一个名为`user`的新变量来存储结果。变量用户将被设置为等于`os.userInfo`，我们可以调用`userInfo`而无需任何参数：

```
console.log('Starting app.');

const fs = require('fs');
const os = require('os');

var user = os.userInfo();

fs.appendFile('greetings.txt', 'Hello world!');
```

现在，在我们对`fs.appendFile`行进行任何操作之前，我将对其进行注释，并使用`console.log`打印用户变量的内容：

```
console.log('Starting app.');

const fs = require('fs');
const os = require('os');

var user = os.userInfo();
console.log(user);
// fs.appendFile('greetings.txt', 'Hello world!');
```

这将让我们准确地探索我们得到了什么。在终端中，我们可以使用向上箭头键和 e*nter*键重新运行程序，在下面的代码中，您可以看到我们有一个具有一些属性的对象：

![](assets/e8e6025d-09b3-4c9e-9e0d-5d65e2a43a74.png)

我们有`uid`、`gid`、`username`、`homedir`和`shell`。根据您的操作系统，您不会拥有所有这些，但您应该始终拥有`username`属性。这是我们关心的问题。

这意味着回到原子内部，我们可以使用`appendFile`内部的`user.username`。我将删除`console.log`语句并取消对`fs.appendFile`调用的注释：

```
console.log('Starting app.');

const fs = require('fs');
const os = require('os');

var user = os.userInfo();

fs.appendFile('greetings.txt', 'Hello world!');
```

现在，在`fs.appendFile`中有`world`的地方，我们将其与`user.username`交换。我们有两种方法可以做到这一点。

# 连接 user.username

第一种方法是删除`world!`并连接`user.username`。然后我们可以使用`+`（加号）运算符连接另一个字符串，如以下代码所示：

```
console.log('Starting app.');

const fs = require('fs');
const os = require('os');

var user = os.userInfo();

fs.appendFile('greetings.txt', 'Hello' + user.username + '!');
```

现在，如果我们运行这个，一切都会按预期进行。在终端上，我们可以重新运行我们的应用程序。打印`Starting app`：

![](assets/eeb699b5-0250-46f4-b4f4-45f16076b0c1.png)

在`greetings.txt`文件中，您应该会看到类似`Hello Gary!`的内容打印到屏幕上，如下所示：

![](assets/48ca995f-4076-461a-8e60-c817922f81d8.png)

使用`fs`模块和`os`模块，我们能够获取用户的用户名，创建一个新文件并存储它。

# 使用模板字符串

第二种方法是使用称为模板字符串的 ES6 特性将`world`与`fs.appendFile`中的`user.username`交换。模板字符串以```（勾号）操作符开始和结束，该操作符位于键盘上*1*键的左侧。然后你像平常一样打字。

这意味着我们将首先键入`hello`，然后添加一个带有`!`（感叹号）的空格，在`!`之前，我们将输入名称：

```
console.log('Starting app.');

const fs = require('fs');
const os = require('os');

var user = os.userInfo();

fs.appendFile('greetings.txt', `Hello !`);
```

要在模板字符串中插入 JavaScript 变量，可以使用`$`（美元）符号，后跟大括号的开头和结尾。然后我们将只引用一个变量，如`user.username`：

```
console.log('Starting app.');

const fs = require('fs');
const os = require('os');

var user = os.userInfo();

fs.appendFile('greetings.txt', `Hello ${user.username}!`);
```

Notice that the Atom editor actually picks up on the syntax of curly braces.

这就是使用模板字符串所需要的全部内容；这是一个 ES6 功能，因为您使用的是 NodeV6。这种语法比我们前面看到的字符串/连接版本更容易理解和更新。

如果您运行代码，它将产生完全相同的输出。我们可以运行它，查看文本文件，这次我们有两次`Hello Gary!`，这就是我们想要的：

![](assets/3f725d56-9605-46bb-84cb-dd044a1308d7.png)

至此，我们已经完成了最基本的示例，我们准备开始为 notes 应用程序创建自己的文件，并在下一节的`app.js`中要求这些文件。

首先，您了解到我们可以使用`require`加载模块。这使我们能够利用节点开发人员、第三方库或我们自己编写的现有功能，并将其加载到文件中，以便可以重用。创建可重用代码对于构建大型应用程序至关重要。如果每次都要在应用程序中构建所有内容，那么没有人会完成任何事情，因为他们会在构建基本内容时陷入困境，比如 HTTP 服务器和 web 服务器。已经有了这些东西的模块，我们将利用伟大的 npm 社区。在本例中，我们使用了两个内置模块，`fs`和`os`。我们使用 require 加载它们，并将模块结果存储在两个变量中。这些变量存储模块提供给我们的所有信息；在`fs`的情况下，我们使用`appendFile`方法，在 OS 的情况下，我们使用`userInfo`方法。我们一起抓取用户名并将其保存到一个文件中，这真是太棒了。

# 需要自己的文件

在本节中，您将学习如何使用`require()`加载您在项目中创建的其他文件。这将允许您将`app.js`之外的函数移动到更具体的文件中；这将使您的应用程序更易于扩展、测试和更新。首先，我们要做的第一件事是创建一个新文件。

# 创建新文件以加载其他文件

在我们的 notes 应用程序的上下文中，新文件将存储书写和阅读笔记的各种功能。到目前为止，您不必担心该功能，因为我们将在本节后面的部分中详细介绍，但我们将创建文件，它最终将位于其中。此文件将为`notes.js`，我们将其保存在应用程序的根目录中，与`app.js`和`greetings.txt`一起，如下所示：

![](assets/37116f0e-f983-4ff1-a0b8-54ff1f419b0a.png)

目前，我们在`notes`中要做的就是使用`console.log`打印一个小日志，显示文件已使用以下代码执行：

```
console.log('Starting notes.js');
```

现在，我们在`notes`的顶部有`console.log`，在`app.js`的顶部有一个。我将把`app.js`中的`console.log`从`Starting app.`改为`Starting app.js`。有了这个，我们现在可以需要 notes 文件了。它不会导出任何功能，但这很好。

By the way, when I say export, I mean the notes file doesn't have any functions or properties that another file can take advantage of.

我们将在本节后面介绍如何导出内容。不过现在，我们将以与加载内置节点模块大致相同的方式加载模块。

让我们做`const`；我将此调用 notes 并将其设置为等于`require()`的返回结果：

```
console.log('Starting app.js');

const fs = require('fs');
const os = require('os');
const notes = require('');

var user = os.userInfo();

fs.appendFile('greetings.txt', `Hello ${user.username}!`);
```

在括号内，我们将传入一个参数，该参数将是一个字符串，但会有一点不同。在上一节中，我们输入了模块名，但在本例中，我们得到的不是模块，而是一个文件`notes.js`。我们需要做的是使用相对路径告诉节点该文件所在的位置。

现在，相对路径以`./`（点正斜杠）开始，它指向文件所在的当前目录。在本例中，这将指向`app.js`目录，它是我们项目`notes-node`的根目录。从这里，我们无需进入任何其他文件夹即可访问`notes.js`，它位于我们项目的根目录中，因此我们可以键入其名称，如下代码所示：

```
console.log('Starting app.js');

const fs = require('fs');
const os = require('os');
const notes = require('./notes.js');

var user = os.userInfo();

fs.appendFile('greetings.txt', `Hello ${user.username}!`);
```

有了它，我们现在可以保存`app.js`并查看运行应用程序时会发生什么。我将使用`node app.js`命令运行应用程序：

![](assets/037c3e53-2739-4a42-ae40-953bee14a3ca.png)

如前面的代码输出所示，我们得到了两个日志。首先，我们得到`Starting app.js`，然后我们得到`Starting notes.js`。现在，`Starting notes.js`来自`note.js`文件，它之所以运行是因为我们需要`app.js`中的文件。

从`app.js`文件中注释掉该命令行，如下所示：

```
console.log('Starting app.js');

const fs = require('fs');
const os = require('os');
// const notes = require('./notes.js');

var user = os.userInfo();

fs.appendFile('greetings.txt', `Hello ${user.username}!`);
```

保存文件，并从终端重新运行；您可以看到`notes.js`文件从未执行，因为我们从未显式地接触过它。

我们从来没有像在前面的例子中那样在终端内部调用它，我们也从来没有要求。

但是现在，我们需要它，所以我将取消注释这一行。

By the way, I'm using command / (forward slash) to comment and uncomment lines quickly. This is a keyboard shortcut available in most text editors; if you're on Windows or Linux, it might not be *command*, it might be *Ctrl* or something else.

# 从 note.js 导出文件以在 app.js 中使用

不过，现在的重点是从`notes.js`导出一些我们可以在`app.js`中使用的东西。在`notes.js`（实际上，在我们所有的节点文件中）中，我们可以访问一个名为`module`的变量。我将使用`console.log`将`module`打印到屏幕上，以便我们可以在终端上浏览，如下所示：

```
console.log('Starting notes.js');

console.log(module);
```

让我们重新运行该文件以浏览它。如下面的截图所示，我们得到了一个相当大的对象，即与`notes.js`文件相关的不同属性：

![](assets/a98531ef-4b8b-4456-99b1-5c2e44de387a.png)

现在，说实话，我们不会使用这些属性中的大部分。我们有像`id`、`exports`、`parent`和`filename`这样的东西。在本书中，我们将使用的唯一属性是`exports`。

`module`属性上的`exports`对象以及此对象上的所有内容都将导出。此对象被设置为`const`变量`notes`。这意味着我们可以在其上设置属性，它们将在 notes 上设置，我们可以在`app.js`中使用它们。

# exports 对象工作的一个简单示例

让我们来看看它是如何工作的。我们要做的是使用`module.exports`定义`age`属性，这是我们在 Terminal 中刚刚探索过的对象。此外，我们知道它是一个对象，因为我们可以在前面的屏幕截图（`exports: {}`中看到它）；这意味着我可以添加一个属性`age`，并将其设置为等于我的年龄，即`25`，如下所示：

```
console.log('Starting notes.js');

module.exports.age = 25;
```

然后我可以保存这个文件并移动到`app.js`以利用这个新的`age`属性。`const`变量注释将存储我所有的导出，在本例中，仅存储年龄。

在`fs.appendFile`中，在`greeting.txt`文件之后，我将添加`You are`，后跟年龄。在模板字符串中，我们将使用带花括号的`$`、`notes.age`和结尾的句点，如下所示：

```
console.log('Starting app.js');

const fs = require('fs');
const os = require('os');
const notes = require('./notes.js');

var user = os.userInfo();

fs.appendFile('greetings.txt', `Hello ${user.username}! You are ${notes.age}.`);
```

现在我们的问候语应该是`Hello Gary! You are 25`。它从我们单独的文件（即，`note.js`中获取`25`值，这太棒了。

让我们花一点时间在终端上使用上箭头键和 E

![](assets/093236f1-6c23-40e7-8649-618d90932157.png)

回到应用程序内部，我们可以打开`greetings.txt`，如下图所示，我们有`Hello Gary! You are 25`：

![](assets/087ca523-8167-4c0d-8ae4-0617bed2c9a0.png)

使用`require()`，我们可以要求创建一个文件，该文件存储了一些对项目其余部分有利的属性。

# 导出函数

很明显，前面的例子很做作。我们不会输出静态数字；导出的真正目标是能够导出在`app.js`中使用的函数。让我们快速地导出两个函数。在`notes.js`文件中，我将`module.exports.addnote`设置为一个函数；`function`关键字后跟开始括号和结束括号，后面跟大括号：

```
console.log('Starting notes.js');

module.exports.addNote = function () {

} 
```

现在，在整个课程中，我将尽可能使用箭头函数，如前面的代码所示。要将常规 ES5 函数转换为 arrow 函数，只需删除`function`关键字，并将其替换为括号和大括号之间的`=>`符号，如下所示：

```
console.log('Starting notes.js');

module.exports.addNote = () => {

} 
```

Now, there are some more subtleties to arrow functions that we'll be talking about throughout the book, but if you have an anonymous function, you can swap it with an arrow function without any problems. The big difference is that the arrow function is not going to bind the `() => {}` keyword or the arguments array, which we'll be exploring throughout the book. So if you do get some errors, it's good to know that the arrow function could be the cause.

不过现在，我们将保持简单，使用`console.log`打印`addNote`。这将让我们知道调用了`addNote`函数。我们将返回一个字符串`'New note'`，如下所示：

```
console.log('Starting notes.js');

module.exports.addNote = () => {
  console.log('addNote');
  return 'New note';
};
```

现在，`addNote`函数是在`notes.js`中定义的，但我们可以在`app.js`中利用它。

让我们快速地评论一下 Tyt T1:

```
console.log('Starting app.js');

const fs = require('fs');
const os = require('os');
const notes = require('./notes.js');

// var user = os.userInfo();
//
// fs.appendFile('greetings.txt', `Hello ${user.username}! You are ${notes.age}.`);
```

我将添加一个变量，调用结果（`res`简称），并将其设置为等于`notes.addNote`返回的结果：

```
console.log('Starting app.js');

const fs = require('fs');
const os = require('os');
const notes = require('./notes.js');

var res = notes.addNote();

// var user = os.userInfo();
//
// fs.appendFile('greetings.txt', `Hello ${user.username}! You are ${notes.age}.`);
```

现在，`addNote`函数暂时是一个伪函数。它不接受任何参数，实际上也不做任何事情，所以我们可以在没有任何参数的情况下调用它。

然后我们将打印结果变量，如下面的代码所示，我们希望结果变量等于`New note`字符串：

```
console.log('Starting app.js');

const fs = require('fs');
const os = require('os');
const notes = require('./notes.js');

var res = notes.addNote();
console.log(res);

// var user = os.userInfo();
//
// fs.appendFile('greetings.txt', `Hello ${user.username}! You are ${notes.age}.`);
```

如果我保存了我的两个文件（`app.js`和`notes.js`，并从终端重新运行，您可以看到`New note`在最后和`addNote`打印之前打印到屏幕上：

![](assets/effc1e66-5430-4eda-a5b0-9c0496ffcaa5.png)

这意味着我们成功地请求了名为`addNote`的 notes 文件，其返回结果成功地返回到`app.js`。

使用这种精确的模式，我们将能够在`notes.js`文件中定义添加和删除注释的函数，但我们可以在应用程序中的任何位置调用它们，包括`app.js`中。

# 练习–向导出对象添加新函数

现在是进行快速挑战的时候了。我想让你做的是在`notes.js`中创建一个新函数，名为`add`。此`add`功能将在`exports`对象上设置。

Remember, `exports` is an object, so you can set multiple properties.

此`add`函数将接受两个参数`a`和`b`；它会将它们相加并返回结果。然后在`app.js`中，我想让你调用`add`函数，传入两个数字，不管你喜欢什么，比如`9`和`-2`，然后将结果打印到屏幕上，确保它正常工作。

You can get started by removing the call to `addNote` since this will not be needed for the challenge.

因此，花点时间，在`notes.js`中创建`add`函数，在`app.js`中调用它，并确保正确的结果打印到屏幕上。进展如何？希望您能够创建该函数并从`app.js`调用它。

# 演习的解决办法

该过程的第一步是定义新函数。在`notes.js`中，我将`module.exports.add`设置为该函数，如下所示：

```
console.log('Starting notes.js');

module.exports.addNote = () => {
  console.log('addNote');
  return 'New note';
}; 

module.exports.add =
```

让我们把它设为一个箭头函数。如果你使用一个正则函数，那很好，我只是喜欢在可能的时候使用 arrow 函数。另外，在括号内，我们将得到两个参数，我们将得到`a`和`b`，如下所示：

```
console.log('Starting notes.js');

module.exports.addNote = () => {
  console.log('addNote');
  return 'New note';
}; 

module.exports.add = (a, b) => {

};
```

我们需要做的就是返回结果，这非常简单。所以我们将进入`return a + b`：

```
console.log('Starting notes.js');

module.exports.addNote = () => {
  console.log('addNote');
  return 'New note';
}; 

module.exports.add = (a, b) => {
  return a + b;
};
```

现在，这是你挑战的第一部分，在`notes.js`中定义一个效用函数；第二部分是在`app.js`中实际使用它。

在`app.js`中，我们可以通过使用冒号`:`打印`console.log`结果来使用我们的函数（这只是为了格式化）。作为第二个参数，我们将打印实际结果，`notes.add`。然后，我们将两个数字相加；我们将添加`9`和`-2`，如下代码所示：

```
console.log('Starting app.js');

const fs = require('fs');
const os = require('os');
const notes = require('./notes.js');

console.log('Result:', notes.add(9, -2));

// var user = os.userInfo();
//
// fs.appendFile('greetings.txt', `Hello ${user.username}! You are ${notes.age}.`);
```

本例中的结果应为`7`。如果我们运行该程序，您可以看到，我们得到的只是，`7`打印到屏幕上：

![](assets/2d99dcfd-a8d3-4bee-9ed0-3cb9376d14e6.png)

如果您能够获得这个，恭喜您，您成功地完成了您的第一个挑战之一。这些挑战将贯穿整本书，它们将变得越来越复杂。但别担心，我们会让挑战变得非常明确；我会告诉你我到底想要什么，我到底想怎么做。现在，您可以使用不同的方法来实现它，真正的目标是让您独立于他人的指导编写代码。这就是真正的学习发生的地方。

在下一节中，我们将探讨如何使用第三方模块。从这里开始，我们将开始构建 notes 应用程序。

# 第三方模块

您现在知道了使用`require()`的三种方法中的两种，在本节中，我们将探讨最后一种方法，即要求您从 npm 安装一个包。正如我在第一章中提到的，npm 是使 Node 如此奇妙的一个重要部分。有一个庞大的开发人员社区已经创建了数千个包，这些包已经解决了节点应用程序中一些最常见的问题。我们将在整本书中利用相当多的软件包。

# 使用 npm 模块创建项目

现在，在 npm 包中，没有什么神奇的，它是旨在解决特定问题的常规节点代码。你想要使用它的原因是，你不必花费所有的时间来编写这些已经存在的实用函数；它们不仅存在，而且经过测试，被证明有效，其他人也使用并记录了它们。

现在，说了这么多，我们如何开始？首先，我们实际上需要从终端运行一个命令，告诉我们的应用程序我们想要使用 npm 模块。此命令将在终端中运行。确保已在项目文件夹和`notes-node`目录中导航。现在，当您安装 Node 时，您还安装了一个名为 npm 的东西。

At one point, npm stood for **Node package manager**, but that's now a running joke because there are plenty of things on npm that are not specific to Node. A lot of frontend frameworks, such as jQuery and react, now live on npm as well, so they've pretty much ditched the Node package manager explanation and now on their site, they cycle through a bunch of hilarious things that happen to match up with npm.

我们将运行一些 npm 命令，您可以通过运行`npm`、空格和`-v`（我们使用`v`标志运行 npm）来测试是否安装了它。这将打印版本，如以下代码所示：

![](assets/2fbd827c-06bf-47f8-b0cd-c92078d62e5d.png)

如果你的版本稍有不同也没关系，这并不重要；重要的是您安装了 npm。

现在，我们将在终端中运行名为`npm init`的命令。此命令将提示我们填写有关 npm 项目的一些问题。我们可以运行该命令并循环回答问题，如以下屏幕截图所示：

![](assets/fa3bdede-390d-4877-b36f-fab82a4d2bbb.png)

在前面的屏幕截图中，顶部是正在发生的事情的快速描述，下面将开始问您一些问题，如以下屏幕截图所示：

![](assets/8d36696c-4caf-408a-b352-db86a16cf7e7.png)

这些问题包括：

*   名称：您的名称不能包含大写字符或空格；例如，您可以使用`notes-node`。您可以点击*输入*使用括号中的默认值。
*   版本：1.0.0 也可以正常工作；我们将保留其中大部分的默认值。
*   描述：我们现在可以把这个空着。
*   入口点：这将是`app.js`，确保正确显示。
*   test 命令：我们将在本书后面部分探讨测试，因此现在，我们可以将其留空。
*   git 存储库：我们现在也将它保留为空。
*   关键词：这些用于搜索模块。我们不会发布此模块，因此可以将其保留为空。
*   作者：你不妨键入你的名字。
*   许可证：对于许可证，我们目前将坚持使用 ISC；既然我们没有出版，那就没关系了。

回答完这些问题后，如果我们点击 e*nter*，我们将在屏幕上看到以下内容和最后一个问题：

![](assets/e71f1d89-0400-4a57-8405-8cbfceead0f6.png)

现在，我想澄清一个神话，即这个命令有什么神奇的作用。这个命令所做的只是在项目中创建一个文件。它将位于项目的根目录中，名为`package.json`，该文件将与前面的屏幕截图完全相同。

对于最后一个问题，如上图所示，您可以点击 e*ENTR*或键入`yes`确认这是您想要做的：

![](assets/9be2c9e8-b3f9-4a8b-a116-058652e2f3e7.jpg)

现在我们已经创建了这个文件，我们可以在项目中查看它了。如下面代码所示，我们有`package.json`文件：

```
{
  "name": "notes-node",
  "version": "1.0.0",
  "description": "",
  "main": "app.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "author": "",
  "license": "ISC"
}
```

这就是它的全部，它是对您的应用程序的简单描述。现在，正如我提到的，我们不会将我们的应用程序发布到 npm，所以很多信息对我们来说并不重要。然而，重要的是，`package.json`是我们定义要在应用程序中安装的第三方模块的地方。

# 在我们的应用程序中安装 lodash 模块

要在应用程序中安装模块，我们将在终端中运行命令。在本章中，我们将安装一个名为`lodash`的模块。`lodash`模块附带了大量实用方法和函数，使得在节点或 JavaScript 内部开发变得非常简单。为了了解我们到底在做什么，让我们进入浏览器。

我们要去[https://www.npmjs.com](https://www.npmjs.com) 。然后我们将搜索包`lodash`，您可以看到它出现了，如下面的屏幕截图所示：

![](assets/76628499-5b5d-48cd-af2b-adbb78842b1a.png)

当您单击它时，您将进入软件包页面，软件包页面将向您显示有关模块和文档的大量统计信息，如下所示：

![](assets/3d77137e-bdad-4eb0-a259-d73aedbdbe5f.png)

现在，我在寻找新模块时使用`lodash`包页面；我想看看它有多少下载量以及上次更新的时间。在 package 页面上，您可以看到它最近进行了更新，这很好，这意味着该软件包很可能与 Node 的最新版本兼容，如果您进一步深入页面，您可以看到这实际上是最流行的 npm 软件包之一，每天的下载量超过 100 万次。我们将使用本模块探索如何安装 npm 模块以及如何在项目中实际使用它们。

# 安装 lodash

要安装`lodash`，首先需要抓取的只是模块名，即`lodash`。一旦你有了这些信息，你就可以安装了。

来到终点站，我们将运行`npm install`命令。安装后，我们将指定模块`lodash`。现在，只有这个命令才能起作用；不过，我们还将提供`save`标志。

`npm install lodash`命令将安装模块，`save`标志`--`（两个）连字符后跟`save`将更新`package.json`文件的内容。让我们运行以下命令：

```
npm install loadsh --save
```

前面的命令将发送到 npm 服务器，获取代码并将其安装到项目中，并且无论何时安装 npm 模块，它都将位于项目的`node_modules`文件夹中。

现在，如果您打开该`node_modules`文件夹，您将看到`lodash`文件夹，如下代码所示。这是我们刚刚安装的模块：

```
{
  "name": "notes-node",
  "version": "1.0.0",
  "description": "",
  "main": "app.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "author": "",
  "license": "ISC",
  "dependencies": {
    "lodash": "^4.17.4"
  }
}
```

如上图`package.json`所示，我们还自动进行了一些更新。有一个新的`dependencies`属性，它有一个带有键值对的对象，其中键是我们希望在项目中使用的模块，值是版本号，在本例中，是最新的版本`4.17.4`。有了这个，我们现在可以在项目中需要我们的模块了。

在`app.js`内部，我们可以通过同样的要求过程来利用`lodash`中的一切。我们将创建一个`const`，我们将其命名为`const _`（这是`lodash`实用程序库的常用名称），并将其设置为`require()`。在 require 括号内，我们将传入模块名称，与`package.json`文件中显示的名称完全相同。这与您运行`npm install`时使用的模块名称相同。然后，我们将键入`lodash`，如下所示：

```
console.log('Starting app.js');

const fs = require('fs');
const os = require('os');
const _ = require('lodash');
const notes = require('./notes.js');

console.log('Result:', notes.add(9, -2));

// var user = os.userInfo();
//
// fs.appendFile('greetings.txt', `Hello ${user.username}! You are ${notes.age}.`);
```

现在，操作顺序在这里非常重要。节点将首先查找名为`lodash`的核心模块。它找不到一个，因为没有核心模块，所以下一个要查找的地方是`node_modules`文件夹。如以下代码所示，它将找到`lodash`并加载该模块，返回它提供的任何导出：

```
console.log('Starting app.js');

const fs = require('fs');
const os = require('os');
const _ = require('lodash');
const notes = require('./notes.js');

console.log('Result:', notes.add(9, -2));

// var user = os.userInfo();
//
// fs.appendFile('greetings.txt', `Hello ${user.username}! You are ${notes.age}.`);
```

# 使用 lodash 的实用程序

随着出口到位，我们现在可以利用 Lodash 附带的一些公用设施。在本节中，我们将快速探索其中两个，并且我们将在本书中探索更多内容，因为 Lodash 基本上只是一组非常方便的实用程序。在开始之前，我们应该先看一下文档，这样我们就可以确切地知道我们要做什么。

This is a really common step when you're using an npm module: first, you install it; second, you've got to look at those docs and make sure that you can get done what you want to get done.

在 npm 页面上，单击此处给出的 lodash 链接，或转到[lodash.com](https://lodash.com)并单击 API 文档页面，如下所示：

![](assets/7e1fe429-f974-4343-b6d8-c522192df5d9.png)

您可以查看所有可用的各种方法，如以下屏幕截图所示：

![](assets/1396d946-2797-48fe-ba6a-877176597a7f.png)

在我们的例子中，我们将使用*命令*+*F*（*Ctrl*+*F*用于 Windows 用户）来搜索`_.isString`。然后在文档中，我们可以单击它，在主页面中打开它，如以下屏幕截图所示：

![](assets/cb9b613b-b3cf-438e-94c1-2e3cef5ad7af.png)

`_.isString`是`lodash`附带的实用程序，如果传入的变量是字符串，则返回`true`，如果传入的值不是字符串，则返回`false`。我们可以通过在原子中使用它来证明这一点。让我们用这个。

# 使用 u.isString 实用程序

要使用`_.isString`实用程序，我们将在`app.js`中添加`console.log`以将结果显示在屏幕上，并使用`_.isString`，传入两个值。我们先传入`true`，然后我们可以复制这一行，传入一个字符串，比如`Gary`，如下所示：

```
console.log('Starting app.js');

const fs = require('fs');
const os = require('os');
const _ = require('lodash');
const notes = require('./notes.js');

console.log(_.isString(true));
console.log(_.isString('Gary'));

// console.log('Result:', notes.add(9, -2));

// var user = os.userInfo();
//
// fs.appendFile('greetings.txt', `Hello ${user.username}! You are ${notes.age}.`);
```

我们可以使用之前使用的相同命令`node app.js`在终端上运行我们的项目，以运行我们的文件：

![](assets/9561c991-5646-4e82-a72e-3ccbb9a76eb6.png)

当我们运行该文件时，我们会得到两个提示，即我们已经启动了这两个文件，然后会得到`false`和`true`。`false`的出现是因为布尔值不是字符串，`true`的出现是因为`Gary`确实是字符串，所以通过了`_.isString`的测试。这是`lodash`附带的众多实用功能之一。

现在，`lodash`可以做的不仅仅是简单的类型检查。它附带了一系列我们可以利用的其他实用方法。让我们再探讨一个实用程序。

# 使用 uq.uniq

回到浏览器内部，我们可以再次使用 c*ommand+F*来搜索一个新的实用程序，即`_.uniq`：

![](assets/d4ce4612-1d7d-40cb-8d7e-67113d61f06b.png)

这个独特的方法只需获取一个数组，然后返回该数组并删除所有重复项。这意味着，如果我有相同的数字几次或相同的字符串，它将删除任何重复。让我们运行这个。

回到 Atom 内部，我们可以将这个实用程序添加到我们的项目中，我们将注释掉我们的`_.isString`调用，并创建一个名为`filteredArray`的变量。这将是没有重复项的数组，我们将在等号之后调用`_.uniq`。

现在，我们知道，这需要一个数组。由于我们试图使用 unique 函数，所以我们将传入一个包含一些重复项的数组。将你的名字作为字符串使用两次；我将使用我的名字一次，后面跟数字`1`，然后再跟我的名字。然后我可以使用`1`、`2`、`3`和`4`，如下所示：

```
console.log('Starting app.js');

const fs = require('fs');
const os = require('os');
const _ = require('lodash');
const notes = require('./notes.js');

// console.log(_.isString(true));
// console.log(_.isString('Gary'));
var filteredArray = _.uniq(['Gary', 1, 'Gary', 1, 2, 3, 4]);
console.log();

// console.log('Result:', notes.add(9, -2));

// var user = os.userInfo();
//
// fs.appendFile('greetings.txt', `Hello ${user.username}! You are ${notes.age}.`);
```

现在，如果一切按计划进行，我们应该得到一个移除所有重复项的数组，这意味着我们将有一个`Gary`、一个`1`实例，然后是`2`、`3`和`4`，它们没有重复项。

最后一件事是使用`console.log`打印，以便我们可以在终端内部查看。我将把这个`filteredArray`变量传递给我们的`console.log`语句，如下代码所示：

```
console.log('Starting app.js');

const fs = require('fs');
const os = require('os');
const _ = require('lodash');
const notes = require('./notes.js');

// console.log(_.isString(true));
// console.log(_.isString('Gary'));
var filteredArray = _.uniq(['Gary', 1, 'Gary', 1, 2, 3, 4]);
console.log(filteredArray);

// console.log('Result:', notes.add(9, -2));

// var user = os.userInfo();
//
// fs.appendFile('greetings.txt', `Hello ${user.username}! You are ${notes.age}.`);
```

从这里，我们可以在节点内运行项目。我将使用最后一个命令，然后我可以按下 e*ENTR*键，您可以看到我们得到了所有重复项都已删除的数组，如以下代码输出所示：

![](assets/36269bde-30dd-40e0-83e2-54aeaaba939a.png)

我们有一个字符串`Gary`的实例，一个数字`1`的实例，然后我们有`2`、`3`、`4`，这正是我们所期望的。

`lodash`效用真的是无穷无尽的。有太多的函数，一开始可能有点难以探索，但是当你开始创建更多的 JavaScript 和节点项目时，你会发现自己在排序、过滤或类型检查方面一次又一次地解决了许多相同的问题，在这种情况下，最好使用`lodash`这样的实用工具来完成提升。`lodash`实用程序之所以很棒，原因如下：

*   你不必一直重写你的方法
*   它经过了很好的测试，并已在生产中试用

如果有什么问题，现在已经解决了。

# node_modules 文件夹

既然您知道了如何使用第三方模块，那么我还想讨论一件事。这通常就是`node_modules`文件夹。当你把你的节点项目放在 GitHub 上，或者你在复制它或者把它发送给朋友时，`node_modules`文件夹真的不应该随身携带。

`node_modules`文件夹包含生成的代码。这不是您编写的代码，您不应该对节点模块内的文件进行任何更新，因为下次安装某些模块时，它们很有可能被覆盖。

在我们的例子中，我们已经定义了`package.json`中的模块和版本，如下代码所示，因为我们使用了方便的`save`标志：

```
{
  "name": "notes-node",
  "version": "1.0.0",
  "description": "",
  "main": "app.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "author": "",
  "license": "ISC",
  "dependencies": {
    "lodash": "^4.17.4"
  }
}
```

这实际上意味着我们可以完全删除`node_modules`文件夹。现在，我们可以复制文件夹并将其交给朋友，我们可以将其放在 GitHub 上，或者我们想做的任何事情。当我们想要取回`node_modules`文件夹时，我们在终端内部所要做的就是运行`npm install`命令，而不使用任何模块名称或标志。

此命令在没有任何名称或标志的情况下运行时，将加载到您的`package.json`文件中，获取所有依赖项并安装它们。运行此命令后，`node_modules`文件夹的外观将与我们删除它之前的外观完全相同。现在，当您使用 Git 和 GitHub 时，您不需要删除`node_modules`文件夹，只需要从存储库中忽略它。

现在，我们到目前为止所探索的是一个过程，我们将在本书中经历更多。因此，如果 npm 看起来仍然是外来的，或者您不太确定它为什么有用，那么随着我们更多地使用第三方模块，而不仅仅是类型检查或在数组中查找唯一的项，这一点就会变得很清楚。npm 社区背后蕴藏着巨大的力量，我们将在制作真实世界的应用程序时充分利用这些力量。

# 全局模块

我收到的一个主要投诉是，每当学生想看到他们在文本编辑器中所做的更改时，他们都必须从终端重新启动应用程序。因此，在本节中，我们将了解如何在更改文件时自动重新启动应用程序。这意味着如果我从`Gary`更改为`Mike`并保存，它将在终端中自动重新启动。

# 安装 nodemon 模块

现在，要在对文件进行更改时自动重新启动应用程序，我们必须安装一个命令行实用程序，我们将使用 npm 来实现这一点。首先，我们将转到 Google Chrome（或您正在使用的浏览器）并转到[https://www.npmjs.com](https://www.npmjs.com) ，正如我们之前在应用程序部分中安装*lodash**模块时所做的，我们正在寻找的模块名为**nodemon**。*

nodemon 将负责监视我们的应用程序的更改，并在这些更改发生时重新启动应用程序。在这里，正如我们在下面的屏幕截图中看到的，我们可以查看 nodemon 的文档以及各种其他内容，如当前版本号等：

![](assets/a70450e3-59e6-400c-9696-682c4daebf72.png)

你也会注意到它是一个非常流行的模块，每天有超过 30000 次下载。现在，这个模块与我们在上一节中使用的模块有点不同，即，`lodash`。`lodash`已安装并添加到我们项目的`package.json`文件中，如下代码块所示：

```
{
 "name": "notes-node",
 "version": "1.0.0",
 "description": "",
 "main": "app.js",
 "scripts": {
 "test": "echo \"Error: no test specified\" && exit 1"
 },
 "author": "",
 "license": "ISC",
 "dependencies": {
 "lodash": "^4.17.4"
 }
}
```

这意味着它进入了我们的`node_modules`文件夹，我们可以在`app.js`文件中要求它（更多详细信息请参阅上一节）。然而，Nodemon 的工作方式有点不同。它是一个从终端执行的命令行实用程序。这将是启动应用程序的一种全新方式，要安装从命令行运行的模块，我们必须调整上一节中使用的`install`命令。

但现在，我们可以从大致相同的方式开始。我们将使用`npm install`并键入名称，就像在我们的应用程序部分中*安装**lodash**模块时一样，但我们将使用`g`标志，而不是使用`save`标志，它是全局的缩写，如下所示：*

```
npm install nodemon -g
```

此命令将`nodemon`作为全局实用程序安装在您的计算机上，这意味着它不会添加到您的特定项目中，您也不会需要`nodemon`。相反，您将从终端运行`nodemon`命令，如下所示：

![](assets/55de7da7-2315-4ef3-90fa-9d1258a72b46.png)

当我们使用前面的命令安装`nodemon`时，它将转到 npm 并获取`nodemon`附带的所有代码。

它将把它添加到 Node 和 npm 在您的机器上的安装中，在您正在工作的项目之外。

`npm install nodemon -g`命令可以在您机器的任何位置执行；它不需要从项目文件夹执行，因为它实际上根本不更新项目。然而，有了这个，我们的机器上现在有了一个全新的命令，`nodemon`。

# 执行 nodemon

Nodemon 将像 Node 一样执行，我们在其中键入命令，然后键入要启动的文件。在我们的例子中，`app.js`是我们项目的根源。运行它时，您将看到一些内容，如下所示：

![](assets/3b8e4ff2-fdf4-40f5-9937-ef2c3f108cc8.png)

我们将看到应用程序输出的组合，以及显示发生了什么的`nodemon`日志。如前面的代码所示，您可以看到`nodemon`正在使用的版本、它正在监视的文件以及它实际运行的命令。现在，在这一点上，它正在等待更多的变化；它已经运行了整个应用程序，它将一直运行，直到发生另一个更改或您关闭它。

在 Atom 内部，我们将对我们的应用程序进行一些更改。首先在`app.js`中将`Gary`改为`Mike`，然后将`filteredArray`变量改为`var filteredArray = _.uniq(['Mike'])`，如下代码所示：

```
console.log('Starting app.js');

const fs = require('fs');
const os = require('os');
const _ = require('lodash');
const notes = require('./notes.js');

// console.log(_.isString(true));
// console.log(_.isString('Gary'));
var filteredArray = _.uniq(['Mike']);
console.log(filteredArray);
```

现在，我将保存文件。在终端窗口中，您可以看到应用程序自动重新启动，在一瞬间，新的输出显示在屏幕上：

![](assets/278c0e02-c056-47a8-9076-9c52309dd3fb.png)

如前一个屏幕截图所示，现在我们的数组中有一个字符串项`Mike`。这就是`nodemon`的真正力量。

您可以创建应用程序，它们将在终端中自动重新启动，这非常有用。这将为你节省大量的时间和头痛。您不必每次进行小调整时都来回切换。这还可以防止在运行 web 服务器、进行更改以及忘记重新启动 web 服务器时出现大量错误。您可能认为您的更改没有按预期工作，因为应用程序没有按预期工作，但实际上，您从未重新启动过应用程序。

大部分情况下，我们将在整本书中使用`nodemon`，因为它非常有用。它只用于开发目的，这正是我们在本地机器上所做的。现在，我们将继续前进，并开始探索如何从用户那里获取输入来创建 notes 应用程序。这将是接下来几节的主题。

在开始之前，我们应该清理本节中已经编写的大量代码。我将删除`app.js`中所有注释掉的代码。然后，我将简单地删除`os`，我们有`fs`、`os`和`lodash`，因为我们不会在整个项目中使用它。我还将在第三方和节点模块以及我编写的文件之间添加一个空格，如下所示：

```
console.log('Starting app.js');

const fs = require('fs');
const _ = require('lodash');

const notes = require('./notes.js');
```

我发现这是一个很好的语法，它使快速扫描第三方或节点模块，或我创建和需要的模块变得容易得多。

接下来，在`notes.js`中，我们将删除`add`函数；这只是为了演示而添加的，如下图所示，然后我们可以同时保存`notes.js`和`app.js`文件，`nodemon`会自动重启：

```
console.log('Starting notes.js');

module.exports.addNote = () => {
  console.log('addNote');
  return 'New note';
};

module.exports.add = (a, b) => {
  return a + b;
};
```

现在我们可以删除`greetings.txt`文件。这是用来演示`fs`模块是如何工作的，因为我们已经知道它是如何工作的，所以我们可以删除该文件。最后但并非最不重要的一点是，我们始终可以使用 C*trl*+*C*关闭`nodemon`。现在我们回到常规航站楼。

有了这些，现在我们应该继续，弄清楚如何从用户那里获得输入，因为这就是用户创建注释、删除注释和获取注释的方式。

# 获取输入

如果用户想要添加注释，我们需要知道注释的标题以及注释的正文。如果他们想要取回一张便条，我们需要知道他们想要取回的便条的标题，所有这些信息都需要进入我们的应用程序。请注意，应用程序在获得动态用户输入之前不会真正做任何事情。这就是让你的脚本变得有用和很棒的原因。

现在，在本书中，我们将创建笔记应用程序，以多种不同的方式获取用户的输入。我们将使用 socket I/O 从 web 应用程序获取实时信息，我们将创建自己的 API，以便其他网站和服务器可以向我们的应用程序发出 Ajax 请求，但在本节中，我们将从一个如何获取用户输入的非常基本的示例开始。

我们将在命令行中从用户处获取输入。这意味着在命令行中运行应用程序时，可以传入一些参数。这些参数将在节点内可用，然后我们可以使用它们执行其他操作，例如创建注释、删除注释或返回注释。

# 从命令行内的用户获取输入

首先，让我们从终端运行我们的应用程序。我们将以类似于前面章节的方式运行它：我们将从`node`开始（我不使用`nodemon`，因为我们将更改输入），然后我们将使用`app.js`，这是我们想要运行的文件，但我们仍然可以键入其他变量。

We can pass all sorts of command-line arguments in. We could have a command, and this would tell the app what to do, whether you want to add a note, remove a note, or list a note.

如果要添加注释，则该注释可能看起来像以下代码中显示的命令：

```
node app.js add
```

此命令将添加注释；我们可以使用`remove`命令删除注释，如下所示：

```
node app.js remove
```

我们可以使用`list`命令列出所有笔记：

```
node app.js list
```

现在，当我们运行此命令时，应用程序仍能按预期工作。我们传入一个新参数并不意味着我们的应用程序将崩溃：

![](assets/de190e41-6194-4b7e-ae63-0b7adc259456.png)

实际上我们已经可以访问`list`参数了，我们只是没有在应用程序中使用它。

要访问应用程序初始化时使用的命令行参数，您需要使用我们在第一章中探讨的`process`对象。

我们可以使用`console.log`注销所有参数，将它们打印到屏幕上；它在进程对象上，我们正在寻找的属性是`argv`。

The `argv` object is short for arguments vector, or in the case of JavaScript, it's more like an arguments array. This will be an array of all the command-line arguments passed in, and we can use them to start creating our application.

现在保存`app.js`，它将如下所示：

```
console.log('Starting app.js');

const fs = require('fs');
const _ = require('lodash');

const notes = require('./notes.js');

console.log(process.argv);
```

然后我们将重新运行此文件：

![](assets/d3077eb1-454a-4b2e-ab74-c7c0c8324ce5.png)

现在，如前面的命令输出所示，我们有三项，如下所示：

*   第一个指向所使用的节点的可执行文件。
*   第二个指向已启动的应用程序文件；在这种情况下，它是`app.js`。
*   第三个是我们的命令行参数开始发挥作用的地方。在它里面，我们的`list`以字符串的形式出现。

这意味着我们可以访问数组中的第三项，这将是 notes 应用程序的命令。

# 访问 notes 应用程序的命令行参数

现在让我们访问数组中的命令行参数。我们将创建一个名为`command`的变量，并将其设置为`process.argv`，我们将抓取第三个位置的项目（即`list`，如前面的命令输出所示），这是两个的索引，如下所示：

```
var command = process.argv[2];
```

然后我们可以通过注销字符串`command`将其记录到屏幕上。然后，作为第二个参数，我将传入实际使用的命令：

```
console.log('Command: ' , command);
```

这只是一个简单的日志，用于跟踪应用程序的执行情况。当我们添加 if 语句，根据该命令执行不同的操作时，很酷的东西就会出现。

# 添加 if/else 语句

让我们在`console.log('Command: ', command);`下方创建一个`if/else`块。我们将添加`if (command === 'add')`，如下图：

```
console.log('Starting app.js');

const fs = require('fs');
const _ = require('lodash');

const notes = require('./notes.js');

var command = process.argv[2];
console.log('Command: ', command);

if (command === 'add') 
```

在本例中，我们将经历添加`new note`的过程。现在，我们没有在这里指定其他参数，例如标题或正文（我们将在后面的部分中讨论）。现在，`if`的`command`等于`add`，我们用`console.log`来打印`Adding new note`，如下代码所示：

```
console.log('Starting app.js');

const fs = require('fs');
const _ = require('lodash');

const notes = require('./notes.js');

var command = process.argv[2];
console.log('Command: ', command);

if (command === 'add') {
  console.log('Adding new note');
}
```

我们也可以用类似于`list`的命令来做同样的事情。我们将添加`else if (command === 'list')`，如下图：

```
console.log('Starting app.js');

const fs = require('fs');
const _ = require('lodash');

const notes = require('./notes.js');

var command = process.argv[2];
console.log('Command: ', command);

if (command === 'add') {
  console.log('Adding new note');
} else if (command === 'list')
```

如果命令确实等于字符串`list`，我们将使用`console.log`运行下面的代码块来打印`Listing all notes`。如果没有命令，我们也可以添加一个`else`子句，即`console.log ('Command not recognized')`，如下图：

```
console.log('Starting app.js');

const fs = require('fs');
const _ = require('lodash');

const notes = require('./notes.js');

var command = process.argv[2];
console.log('Command: ', command);

if (command === 'add') {
  console.log('Adding new note');
} else if (command === 'list') {
  console.log('Listing all notes');
} else {
  console.log('Command not recognized');
}
```

有了这个功能，我们现在可以第三次重新运行我们的应用程序，这一次，您将看到我们的命令等于 list，并显示所有注释，如以下代码所示：

```
if (command === 'add') {
  console.log('Adding new note');
} else if (command === 'list') {
  console.log('Listing all notes');
} else {
  console.log('Command not recognized');
}
```

这意味着我们可以使用参数运行不同的代码。请注意，我们没有运行`Adding new note`，也没有运行`Command not recognized`。但是，我们可以将`node app.js`命令从`list`切换到`add`，在这种情况下，我们将得到`Adding new note`打印，如下面的屏幕截图所示：

![](assets/475401cc-84e9-4785-a2b0-f676f103fba5.png)

如果我们运行一个不存在的命令，例如`read`，您可以看到`Command not recognized`打印，如下图所示：

![](assets/e9b6a001-067d-4224-aac3-449a3cdcbd07.png)

# 练习–将两个 else if 子句添加到 if 块

现在，我想让你们做的是在我们的`if`块中再添加两个`else if`子句，如下所示：

*   其中一个将用于`read`命令，该命令将负责收回一张单独的便条
*   另一个名为`remove`的人将负责删除注释

你所要做的就是为它们添加`else if`语句，然后快速`console.log`打印`Fetching note`或`Removing note`之类的内容。

花一点时间来解决这个问题，这是本节的挑战。添加这两个`else if`子句后，从终端运行这两个子句，并确保显示日志。如果它真的出现了，你就完成了，你可以继续这个部分。

# 演习的解决办法

对于解决方案，我要做的第一件事是为`read`添加一个`else if`。我会打开和关闭我的花括号，并击中 eEnt2 t2。

在`else if`语句中，我将检查`command`变量是否等于字符串`read`，如下所示：

```
console.log('Starting app.js');

const fs = require('fs');
const _ = require('lodash');

const notes = require('./notes.js');

var command = process.argv[2];
console.log('Command: ', command);

if (command === 'add') {
  console.log('Adding new note');
} else if (command === 'list') {
  console.log('Listing all notes');
} else if () {

} else {
  console.log('Command not recognized');
}
```

In the future, we'll be calling methods that update our local database with the notes.

现在，我们将使用`console.log`打印`Reading note`：

```
console.log('Starting app.js');

const fs = require('fs');
const _ = require('lodash');

const notes = require('./notes.js');

var command = process.argv[2];
console.log('Command: ', command);

if (command === 'add') {
  console.log('Adding new note');
} else if (command === 'list') {
  console.log('Listing all notes');
} else if (command === 'read') {

} else {
  console.log('Command not recognized');
}
```

接下来需要做的事情是添加一个`else if`子句，检查`command`是否等于`remove`。在`else if`中，我将打开和关闭我的条件并点击 e*ENTR*，就像我在前面的`else if`条款中所做的那样；这一次，我会加上`if`这个`command`等于`remove`，我们想去掉这个音符。在这种情况下，我们只需使用`console.log`打印`Reading note`，如下代码所示：

```
console.log('Starting app.js');

const fs = require('fs');
const _ = require('lodash');

const notes = require('./notes.js');

var command = process.argv[2];
console.log('Command: ', command);

if (command === 'add') {
  console.log('Adding new note');
} else if (command === 'list') {
  console.log('Listing all notes');
} else if (command === 'read') {
  console.log('Reading note');
} else {
  console.log('Command not recognized');
}
```

有了这些，我们就完蛋了。如果我们参考代码块，我们添加了两个新命令，可以在终端中运行，我们可以测试它们：

```
if (command === 'add') {
  console.log('Adding new note');
} else if (command === 'list') {
  console.log('Listing all notes');
} else if (command === 'read') {
  console.log('Reading note');
} else {
  console.log('Command not recognized');
}
```

首先，我将使用`read`命令运行`node app.js`，此时`Reading note`显示：

```
console.log('Starting app.js');

const fs = require('fs');
const _ = require('lodash');

const notes = require('./notes.js');

var command = process.argv[2];
console.log('Command: ', command);

if (command === 'add') {
  console.log('Adding new note');
} else if (command === 'list') {
  console.log('Listing all notes');
} else if (command === 'read') {
  console.log('Reading note');
} else if (command == 'remove') {
  console.log('Removing note');
} else {
  console.log('Command not recognized');
}
```

然后我将重新运行该命令；这次，我将使用`remove`。当我这样做时，`Removing note`会打印到屏幕上，如此屏幕截图所示：

![](assets/3f7acc58-ae65-4865-9d47-413e64f16ece.png)

我将使用一个不存在的命令结束测试，当我运行该命令时，您可以看到`Command not recognized`出现。

# 获取特定的注释信息

现在，我们在上一小节中所做的是步骤 1。我们现在支持各种命令。接下来我们需要弄清楚的是如何获得更具体的信息。例如，您要删除哪个便笺？你想读哪张便条？在添加注释的情况下，您希望注释文本是什么？这是我们需要从终端获得的所有信息。

现在，获取它将非常类似于我们之前所做的，为了向您展示它的外观，我们将使用以下命令再次打印整个`argv`对象：

```
console.log(process.argv);
```

在终端中，我们现在可以运行更复杂的命令。假设我们想使用`node app.js remove`命令删除一个便笺，我们将通过它的标题来完成。我们可以使用`title`参数，它看起来像下面的代码：

```
node app.js remove --title
```

在这个`title`参数中，我们有`--`（两个）连字符，后跟参数名称，即`title`，后跟`=`（等号）。然后我们可以输入我们的笔记标题。可能票据标题是`secrets`。这将把 title 参数传递到我们的应用程序中。

现在，有几种不同的方法可以格式化`title`参数，如下所示：

*   您可以使用前面命令中的标题`secrets`
*   你可以在引号中加上 title equals secrets，这样我们可以在标题中使用空格：

```
 node app.js remove --title=secrets
```

*   您可以完全删除`=`（等于）号，只需在其中加一个空格：

```
 node app.js remove --title="secrets 2"
```

无论您选择如何格式化您的论点，这些都是传递标题的有效方式。

As you see in the preceding screenshot, I am using double quotes when wrapping my string. Now, if you switch to single quotes, it will not break on Linux or OS X, but it will break on Windows. That means when you're passing in command-line arguments such as the title or the note body, you'll want to wrap your strings, when you have spaces, in double quotes, not single. So, if you are using Windows and you're getting some sort of unexpected behavior with your arguments, make sure you're using double quotes instead of single; that should fix the issue.

目前，我将保留`=`（等于）号和引号，然后重新运行命令：

```
node app.js remove --title="secrets 2"
```

当我运行该命令时，您可以在以下代码输出中看到我们有两个参数：

![](assets/1cb82daa-4c24-4774-873c-9a3f6872e51d.png)

这些是我们不需要的参数，然后我们有了`remove`命令，这是第三个，我们现在有了一个新的第四个字符串，标题等于`secrets 2`。我们的论点被成功地传递到应用程序中。问题是它不太容易使用。在第四个字符串中，我们必须解析出键`title`，以及值`secrets 2`。

当我们使用命令时，这是上一节中的第三个参数，在我们的应用程序中使用它要容易得多。我们只是从 arguments 数组中取出它，然后使用命令变量引用它，并检查它是否等于`add`、`list`、`read`或`remove`。

当我们使用不同的风格来传递参数时，事情变得更加复杂。如果我们用空格而不是`=`（等于）号重新运行最后一个命令，如下面的代码所示，这是完全有效的，那么我们的 arguments 数组现在看起来完全不同了：

![](assets/d2a28fa2-df33-4c71-a401-b391ddc66626.png)

在前面的代码输出中，您可以看到我们将标题作为第四项，将值`secrets 2`作为第五项，这意味着我们必须添加其他解析条件。这很快就会变成一种痛苦，这就是为什么我们不这么做。

在下一章中，我们将使用名为 yargs 的第三方模块来轻松解析命令行参数。我们将得到一个对象，其中 title 属性等于`secrets 2`字符串，而不是像本文或前面讨论的那样使用字符串。这将使实现 notes 应用程序的其余部分变得非常容易。

现在，解析某些类型的命令行参数（例如键值对）变得更加复杂，这就是为什么在下一章中，我们将使用 yargs 来完成这项工作。

# 总结

在本章中，我们学习了如何使用 require 加载 Node.js 附带的模块。我们为 notes 应用程序创建了文件，并要求将其放在`app.js`中。我们探讨了如何使用内置模块，以及如何使用我们定义的模块。我们了解了如何需要我们创建的其他文件，以及如何从这些文件导出属性和函数等内容。

我们稍微探讨了 npm，如何使用`npm init`生成`package.json`文件，以及如何安装和使用第三方模块。接下来，我们研究了`nodemon`模块，使用它在我们更改文件时自动重启我们的应用程序。最后，我们学习了如何从用户那里获取创建 notes 应用程序所需的输入。我们了解到，我们可以使用命令行参数将数据传递到我们的应用程序中。

在下一章中，我们将探讨一些更有趣的节点基本概念，包括 yargs、JSON 和重构。