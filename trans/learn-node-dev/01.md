Getting Set Up  

# 准备

在本章中，您将为本书的其余部分设置本地环境。无论您是在 macOS、Linux 还是 Windows 上，我们都将安装 Node，并了解如何运行 Node 应用程序。

我们将讨论 Node 是什么，为什么你会想使用它，以及为什么你想要使用节点，而不是像 Rails、C++、java 或者任何其他语言可以完成类似的任务。在本章结束时，您将运行第一个节点应用程序。这将很简单，但它将使我们走上创建真实世界生产节点应用程序的道路，这也是本书的目标。

更具体地说，我们将介绍以下主题：

*   Node.js 安装
*   节点是什么
*   为什么要使用节点
*   原子
*   你好，世界

# Node.js 安装

在我们开始讨论什么是节点以及它为什么有用之前，您需要首先在您的机器上安装节点，因为在接下来的两个部分中，我们将要运行一点节点代码。

现在，为了开始，我们只需要两个程序——一个浏览器，我将在整本书中使用 Chrome，但任何浏览器都可以，还有终端。我将使用**聚光灯**打开终端，这就是我的操作系统上所说的终端。

如果您在 Windows 上，请查找命令提示符，您可以使用 Windows 键进行搜索，然后键入`command prompt`，在 Linux 上，您正在查找命令行，尽管根据您的发行版，它可能被称为终端或命令提示符。

现在，打开该程序后，您将看到一个屏幕，如以下屏幕截图所示：

![](assets/a4d7162c-aef9-40d4-98a9-ec1ea68fbca0.png)

本质上，它是在等待您运行命令。在本书中，我们将从终端运行许多命令。我将在后面的几节中讨论它，所以如果您以前从未使用过它，您可以开始舒适地导航。

# Node.js 版本确认

在浏览器中，我们可以前往[nodejs.org](http://nodejs.org)获取最新版本 Node 的安装程序（如图所示）。在本书中，我们将使用最新版本 9.3.0：

![](assets/01739796-c861-4e5e-a192-0e22f6a8c399.png)

It is important that you install a V8 version of Node.js. It doesn't have to be 4.0, it could be 1.0, but it is important it's on that V8 branch, because there is a ton of new features that come along with V8, including all of the features you might have come to love in the browser using ES6.

ES6 是 JavaScript 的下一个版本，它附带了许多我们将在本书中使用的强大增强功能。如下图所示，Node.js 长期支持发布计划（[https://github.com/nodejs/LTS](https://github.com/nodejs/LTS) ），可以看到当前节点版本是 V8，2017 年 4 月推出：

在继续之前，我想谈谈节点发布周期。我在上图中看到的是正式发布周期，这是由节点发布的。您会注意到，只有在偶数节点编号旁边才能找到活动的 LTS、蓝色条和维护条。现在，LTS 代表长期支持，这是推荐给大多数用户的版本。我建议您继续使用当前提供的 LTS 选项（节点 v 8.9.4 LTS），尽管左侧的任何选项都可以，但这显示为[nodejs.org](http://nodejs.org)上的两个绿色按钮。

现在，正如你所看到的，主要的版本号，每六个月更新一次。不管有什么大的总体变化，即使没有什么大的变化，这种变化也会像发条一样发生。这不像从 1.0 跳到 2.0 时使用完全不同的库。Node 的情况并非如此，您从本书中获得的是 Node 所提供的最新和最伟大的功能。

# 安装节点

一旦确认并选择了版本，我们只需点击节点网站（[nodejs.org](http://nodejs.org)上所需的版本按钮，下载安装程序即可。安装程序是那些基本的*点击下一步几次，你就完成了*类型的安装程序，没有必要运行任何花哨的命令。我将启动安装程序。如下面的屏幕截图所示，只需问几个问题，然后单击“下一步”或继续浏览所有问题：

![](assets/9d793ed5-bdc8-43e9-80af-9c6e539d4a72.png)

您可能希望指定自定义目标，但如果您不知道这意味着什么，并且在安装程序时通常不这样做，那么也可以跳过该步骤。在下一个屏幕截图中，您可以看到我只使用了 58.6MB，没问题。

我将通过输入密码来运行安装程序。输入密码后，只需几秒钟即可安装节点：

![](assets/83317cab-1d71-4aaf-ba99-43b150100919.png)

如以下屏幕截图所示，我们收到一条消息，说明安装已成功完成，这意味着我们可以开始了：

![](assets/17dde6f1-27e8-43e8-b7ba-d3f342d8261b.png)

# 验证安装

现在节点已经成功安装，我们可以继续从终端运行节点来验证这一点。在终端内部，我将通过退出终端并再次打开来关闭它：

![](assets/ef346e4a-2e45-4758-9eac-3c7d3a12bada.png)

The reason I'm opening it up is because we've installed a new command, and some Terminals require a restart before they will be able to run that new command.

在本例中，我们重新启动了程序，可以运行全新的命令，因此，我们将键入：

```
node -v
```

我们在这个命令中所做的是运行 Node 命令，并传入一个被称为**标志**，一个连字符符号，后跟一个字母。它可以是`a`，也可以是`j`，或者在我们的例子中是`v`。此命令将打印当前安装的节点版本。

我们可能会遇到如下错误：

![](assets/624d0bbe-8758-48a9-a8d5-667582827385.png)

如果您试图运行一个不存在的命令，例如`nodeasdf`，您将看到找不到命令。如果您看到这一点，通常意味着节点安装程序工作不正常，或者您没有首先运行它。

但在我们的例子中，使用`v`标志运行节点应该会产生一个数字。在我们的例子中，它是 9.3.0 版。如果您确实安装了 Node，并且看到如下屏幕截图，那么您就完成了。在下一节中，我们将开始探索节点到底是什么。

![](assets/c6ad6c47-19b7-41ae-b798-a6cd09c51270.png)

# 什么是节点？

Node 是在最初的开发人员使用 JavaScript 时出现的，JavaScript 通常只能在浏览器中运行，他们让它作为一个独立的进程在您的机器上运行。这意味着我们可以在浏览器上下文之外使用 JavaScript 创建应用程序。

现在，JavaScript 以前的功能集很有限。当我在浏览器中使用它时，我可以做一些事情，比如更新 URL、删除节点徽标、添加单击事件或其他任何事情，但我真的做不了更多。

使用 Node，我们现在有了一个与其他语言（如 Java、Python 或 PHP）更相似的功能集。其中一些措施如下：

*   我们可以使用 JavaScript 语法编写节点应用程序
*   您可以操作文件系统，创建和删除文件夹
*   您可以直接创建查询数据库
*   您甚至可以使用 Node 创建 web 服务器

这些事情在过去是不可能的，它们是因为节点。

现在，节点和在浏览器中执行的 JavaScript 都运行在完全相同的引擎上。它被称为 V8 JavaScript 运行时引擎。这是一个开源引擎，它接受 JavaScript 代码并将其编译成更快的机器代码。这是 Node.js 如此之快的主要原因。

机器代码是低级代码，您的计算机可以直接运行，而无需对其进行解释。您的机器只知道如何运行某些类型的代码，例如，如果不先将 JavaScript 代码或 PHP 代码转换为低级代码，您的机器就无法直接运行这些代码。

使用这个 V8 引擎，我们可以将 JavaScript 代码编译成更快的机器代码，然后执行它。这就是所有这些新特性的用武之地。V8 引擎是用 C++语言编写的。因此，如果你想扩展节点语言，你不写节点代码，你编写 C++代码，它是根据 V8 已经存在的东西构建的。

Now, we'll not be writing any C++ code in this book. This book is not about adding onto Node, it is about using Node. So, we will only be writing JavaScript code.

说到 JavaScript 代码，让我们开始在终端内部编写一些代码。现在，在本书中，我们将创建文件并执行这些文件，但是我们实际上可以通过运行`node`命令来创建一个全新的节点进程。

参考以下屏幕截图，我有一个右插入符号，它正在等待 JavaScript 节点代码，而不是新的命令提示符命令：

![](assets/c5947e1b-5bd5-472e-993d-6c281a8324d0.png)

这意味着我可以运行类似于`console.log`的程序，正如您可能已经知道的那样，它会在屏幕上记录一条消息。`log`是一个函数，所以我将这样调用它，打开和关闭括号，并在两个单引号内传入一个字符串，一条消息`Hello world!,`，如下命令行所示：

```
console.log('Hello world!');
```

这将在屏幕上打印 Hello world。如果我点击*e*n*ter*，世界你好！按预期打印，如以下代码输出所示：

![](assets/baf96c0b-f956-42f2-9fd4-1ae1d93d86c1.png)

现在，幕后到底发生了什么？这就是 Node 所做的。它接受您的 JavaScript 代码，将其编译成机器代码并执行。在前面的代码中，您可以看到它执行了我们的代码，打印出 Hello world！。现在，当我们执行这个命令时，V8 引擎正在后台运行，它也在 Chrome 浏览器中运行。

如果我通过进入设置|更多工具|开发者工具打开 Chrome 中的开发者工具：

![](assets/c50b749f-f331-445c-a2cf-a4e5effb477a.png)

我可以忽略大部分事情。我正在查找 Console 选项卡，如以下屏幕截图所示：

![](assets/46808206-8003-411c-8dca-2745900d99a3.png)

前面显示控制台的屏幕截图是我们可以运行一些 JavaScript 代码的地方。我可以键入完全相同的命令，`console.log('Hello world!');`并运行它：

![](assets/608f3133-f3d0-4562-9a9b-65c76466c07a.png)

正如您在前面的屏幕截图中所看到的，你好，世界！打印到屏幕上，这与我们之前使用终端运行时得到的结果完全相同。在这两种情况下，我们都是通过 V8 引擎运行它，在这两种情况下，输出是相同的。

现在，我们已经知道这两者是不同的。节点具有文件系统操纵等功能，而浏览器具有操纵窗口内显示内容等功能。让我们花一点时间来探讨他们之间的差异。

# 使用节点和浏览器中的 JavaScript 编码之间的差异

在浏览器内部，如果您进行过任何 JavaScript 开发，则可能使用过`window`：

![](assets/c86d2ba0-91d4-4829-81fc-5471adbb8604.png)

窗口是全局对象，它基本上存储您可以访问的所有内容。在下面的屏幕截图中，你可以看到数组，我们有各种各样的 CSS 操作和谷歌分析关键词；实际上，您创建的每个变量都存在于窗口中：

![](assets/29a97655-4da3-4dd9-b5ae-fdafb9a1f4dd.png)

我们在节点内部有类似的东西，称为`global`，如下所示：

![](assets/1cb4f89c-3e2f-4e20-bdfd-2d67697b1e46.png)

因为节点中没有浏览器窗口，所以不叫`window`，所以叫`global`。`global`对象存储了许多与`window`相同的东西。在下面的屏幕截图中，您可以看到可能很熟悉的方法，例如`setTimeout`和`setInterval`：

![](assets/586f7689-f17e-430e-8b70-a9c8c0f411c8.png)

如果我们看一下这个代码截图，除了一些例外，我们拥有窗口中定义的大部分内容，如以下截图所示：

![](assets/ddde7001-804c-4a88-a11f-b0c14722b083.png)

现在，在 Chrome 浏览器中，我也可以访问`document`：

![](assets/c9ca1af3-26a5-41f2-8d40-a0c092e1d6e4.png)

`document`对象在节点网站中存储对**文档对象模型**（**DOM**的引用。`document`对象准确地显示了我在浏览器视口中拥有的内容，如以下屏幕截图所示：

![](assets/4f4e6fb3-b941-4b3a-b829-06187cf3fef4.png)

我可以对文档进行更改，以更新浏览器视口中显示的内容。现在，显然我们在节点中没有这个 HTML`document`，但是我们有类似的东西，叫做`process`。您可以通过从节点运行进程来查看它，在下面的屏幕截图中，我们有很多关于正在执行的特定节点进程的信息：

![](assets/dafb06f4-45b7-4327-95e0-ce6f3ac2900f.png)

这里还有关闭当前节点进程的方法。我想让你做的是运行`process.exit`命令，将数字 0 作为参数传递进来，告诉你一切都顺利结束了：

```
process.exit(0);
```

当我运行此命令时，您可以看到我现在返回到命令提示符处，如以下屏幕截图所示：

![](assets/07a39364-2899-4019-a0b4-3900fcd8b12e.png)

我已经离开了节点，现在可以运行任何常规命令提示符命令，比如检查节点版本。我总是可以通过运行`node`返回节点，通过使用*控制*+*C*两次，我可以不使用`process.exit`命令离开节点。

![](assets/eb2936f8-a6d8-4880-9ca1-e3232ac78ae1.png)

现在，我回到常规命令提示符。所以，这些是显著的区别，很明显，在浏览器中，你有了可视区域，窗口变为全局，文档基本上变成了流程。现在，显然这是一个概括，但这是一些大的变化。我们将探究整本书中的所有细节。

现在，当有人问你什么是节点？可以说*节点是一个使用 V8 引擎的 JavaScript 运行时。当他们问你 V8 引擎是什么时，你可以说，OT2。V8 引擎是一个开源的 JavaScript 引擎，用 C++编写，java java 代码，编译成机器代码。它在 Node.js 中使用，在 Chrome 浏览器*中使用。

# 为什么要使用节点

在本节中，我们将介绍 Node.js 后面的*为什么*。为什么它如此擅长创建后端应用程序？那么，为什么像沃尔玛这样的公司都在使用 Uber.js 呢？

正如您在学习本课程后可能已经注意到的，当人们想要学习一种新的后端语言时，越来越多的人将节点作为他们想要学习的语言。Node 技能集对于需要每天使用 Node 来编译应用程序的前端开发人员和使用 Node.js 创建应用程序和实用程序的工程师来说都是一个热门需求。所有这些使得 Node 成为后端语言的首选。

现在，如果我们看一下 Node 的主页，我们有三句话，如下截图所示：

![](assets/b3212c22-2924-411a-ac57-d8e8db1d71b7.png)

在上一节中，我们讨论了第一句话。我们看了一下 Node.js 是什么。图中只有三个句子，所以在本节中，我们将看后两个句子。我们现在将阅读它们，然后将其分解，确切地了解 Node 为何如此伟大。

第一句话，Node.js 使用事件驱动的非阻塞 I/O 模型，使其轻量级和高效；我们现在将探讨所有这些。我们将在 Node.js 一节末尾探讨的第二句话是打包的生态系统 npm，它是世界上最大的开源库生态系统。现在，这两句话包含了大量的信息。

我们将回顾一些代码示例，深入研究一些图表，我们将探索是什么让 Node 与众不同，是什么让它如此出色。

Node 是一种事件驱动的非阻塞语言。现在，什么是 I/O？I/O 是应用程序一直在做的事情。当您读取或写入数据库时，即 I/O，它是输入/输出的缩写形式。

这是从节点应用程序到物联网内其他事物的通信。这可能是一个数据库读写请求，您可能正在更改文件系统中的某些文件，或者您可能正在向单独的 web 服务器发出 HTTP 请求，例如用于获取用户当前位置地图的 Google API。所有这些都使用 I/O，I/O 需要时间。

现在，非阻塞 I/O 非常好。这意味着，当一个用户向谷歌请求 URL 时，其他用户可以请求对数据库文件的读写访问，他们可以请求各种各样的内容，而不会阻止其他人完成某些工作。

# 模块化和非模块化软件开发

让我们继续看一看阻塞和非阻塞软件开发之间的区别：

![](assets/d98b8e36-15cf-4a2e-8a6f-74ae6d3a7f03.png)

在前面的屏幕截图中，我们将执行两个文件。但在开始之前，首先让我们探讨一下这些文件是如何运行的，以及完成程序所需的步骤。

这将有助于我们理解阻塞（我在图像左侧看到）和非阻塞（非阻塞）之间的巨大区别，阻塞不是节点使用的，非阻塞是在右侧看到的，这正是本书中所有节点应用程序的操作方式。

为了理解这个代码示例中发生的事情，您不必了解各个细节，例如需要什么。我们将在一个非常普遍的意义上对事物进行分解。每段代码的第一行负责获取被调用的函数。这个函数将是我们模拟的 I/O 函数，它将进入数据库，获取一些用户数据并将其打印到屏幕上。

请参阅前面的代码图像。加载函数后，两个文件都尝试获取 ID 为`123`的用户。当它获取该用户时，它首先用`user1`字符串将其打印到屏幕上，然后继续，它获取以`321`作为 ID 的用户，并将其打印到屏幕上。最后两个文件加起来`1 + 2`，将结果（3）存储在`sum`变量中，并打印到屏幕上。

现在，虽然他们都做同样的事情，但他们的方式却截然不同。让我们将各个步骤分解。在下面的代码图中，我们将讨论执行哪个节点以及需要多长时间：

![](assets/cbf26905-e195-4d79-be4f-e6fd874a2483.png)

可以考虑前面屏幕截图中显示的秒数；这并不重要，只是显示两个文件之间的相对操作速度。

# 阻塞 I/O 的工作原理

阻塞示例可以如下所示：

![](assets/edacad6f-9299-41ce-a728-a6172afbd4b1.png)

在我们的阻塞示例中发生的第一件事，如前面的屏幕截图所示，是我们在代码的第 3 行获取用户：

```
var user1 = getUserSync('123');
```

现在，这个请求需要我们转到一个数据库，这是一个 I/O 操作，通过 ID 获取该用户。这需要一点时间。在我们的例子中，我们会说需要三秒钟。

接下来，在代码的第 4 行，我们将用户打印到屏幕上，这不是 I/O 操作，它会立即运行，将`user1`打印到屏幕上，如下代码所示：

```
console.log('user1', user1); 
```

正如您在下面的屏幕截图中所看到的，它几乎不需要任何时间：

![](assets/400cbd6b-099e-48ab-81f4-291cf7d055f2.png)

接下来我们等待`user2`的取数：

```
var user2 = getUserSync('321');
```

![](assets/0888c6f8-da6d-4320-aafa-4f6692b70f96.png)

当`user2`返回时，正如您所料，我们会将其打印到屏幕上，这正是第 7 行发生的情况：

```
console.log('user2', user2);
```

最后，我们将数字相加并打印到屏幕上：

```
var sum = 1 + 2; 
console.log('The sum is ' + sum); 
```

所有这些都不是 I/O，因此在这里，我们几乎可以在任何时间将总和打印到屏幕上。

这就是阻塞的工作原理。这被称为阻塞，因为当我们从数据库（这是一个 I/O 操作）获取数据时，我们的应用程序不能做任何其他事情。这意味着我们的机器闲置着等待数据库响应，甚至不能做一些简单的事情，比如添加两个数字并将它们打印到屏幕上。这在阻塞系统中是不可能的。

# 工作的非阻塞 I/O

在我们的非阻塞示例中，这就是我们构建节点应用程序的方式。

让我们逐行分解这个代码示例。首先，事情的开始方式与我们在阻塞示例中讨论的大致相同。我们将为`user1`启动`getUser`函数，这正是我们之前所做的：

![](assets/9c170d20-73ec-417b-a51a-62f13963b8de.png)

但我们不是在等待，我们只是在启动这项活动。这都是 Node.js 中事件循环的一部分，我们将对此进行详细探讨。

注意这需要一点时间；我们只是开始请求，而不是等待数据。我们接下来做的事情可能会让你大吃一惊。我们没有将`user1`打印到屏幕上，因为我们仍在等待该请求返回，而是开始获取 ID 为`321`的`user2`的过程：

![](assets/e6e86e00-25f0-453b-89f5-063adbfef43e.png)

在代码的这一部分中，我们将启动另一个事件，它只需要一点时间即可完成，而不是 I/O 操作。现在，在幕后，数据库的获取是 I/O，但启动事件、调用此函数不是，所以它发生得非常快。

接下来，我们打印总数。总和不关心两个用户对象中的任何一个。它们基本上是不相关的，所以在我打印`sum`变量之前，不需要等待用户回来，如下面的屏幕截图所示：

![](assets/989ab9b8-023d-4e73-acd5-ebf2d460f179.png)

打印总数后会发生什么？我们有一个虚线框，如下面的屏幕截图所示：

![](assets/47d4fbae-786a-469b-ba5d-eff9d7b767dd.png)

此框表示事件得到响应所需的模拟时间。现在，此框的宽度与阻塞示例第一部分（等待 user1）中的框的宽度完全相同，如下所示：

![](assets/7b946502-ff7c-4c2e-8fe8-2be5a4ae7a62.png)

使用非阻塞并不会使 I/O 操作更快，但它能让我们同时运行多个操作。

在非阻塞示例中，我们在半秒标记之前启动两个 I/O 操作，在三秒半之间，这两个操作都返回，如以下屏幕截图所示：

![](assets/88a19684-fd14-41b8-89d3-9feeee9f4591.png)

现在，结果是整个应用程序完成得更快。如果比较执行这两个文件所用的时间，则非阻塞版本只需三秒多，而阻塞版本只需六秒多。相差 50%。这 50%来自这样一个事实：在阻塞中，我们有两个请求，每个请求花费 3 秒钟；在非阻塞中，我们有两个请求，每个请求花费 3 秒钟，但它们同时运行。

使用非阻塞模型，我们仍然可以在不必等待数据库响应的情况下打印总和。现在，这就是两者之间的巨大区别；阻塞，一切按顺序发生，在非阻塞中，我们启动事件，附加回调，这些回调稍后被触发。我们仍在打印`user1`和`user2`，我们只是在数据返回时打印，因为数据不会立即返回。

在 Node.js 内部，事件循环附加了一个监听器，让事件完成，在本例中，让数据库响应。当它这样做时，它调用您在非阻塞情况下传递的回调，然后我们将其打印到屏幕上。

Now, imagine this was a web server instead of the preceding example. That would mean if a web server comes in looking to query the database, we can't process other users' requests without spinning up a separate thread. Now, Node.js is single threaded, which means your application runs on one single thread, but since we have non-blocking I/O, that's not a problem.

在阻塞上下文中，我们可以在两个单独的线程上处理两个请求，但这并不能很好地扩展，因为对于每个请求，我们必须增加应用程序使用的 CPU 和 RAM 资源量，这很糟糕，因为这些线程仍然处于空闲状态。仅仅因为我们可以启动其他线程并不意味着我们应该这样做，我们在浪费什么都不做的资源。

在非阻塞的情况下，我们不是通过创建多个线程来浪费资源，而是在一个线程上完成所有工作。当一个请求传入时，I/O 是非阻塞的，因此我们不会占用比从未发生过的情况更多的资源。

# 使用终端的阻塞和非阻塞示例

让我们实时运行这些示例，看看我们得到了什么。我们有两个文件（`blocking`和`non-blocking`文件），我们在上一节中看到。

我们将运行这两个文件，我将使用 Atom 编辑器编辑文本文件。这些是我们将在本节后面设置的内容，这只是为了您的查看目的，您不需要运行这些文件。

现在，`blocking`和`non-blocking`文件都将运行，它们将以不同的方式执行与我们在上一节中所做的类似的操作。两者都使用 I/O 操作，`getUserSync`和`getUser`，每种操作都需要 5 秒钟。时间没有什么不同，只是它们的执行顺序使得非阻塞版本更快。

现在，为了模拟和展示事物是如何工作的，我将添加几个`console.log`语句，如下面的代码示例`console.log('starting user1')`、`console.log('starting user2')`所示。

这将让我们直观地了解终端内部的工作方式。通过运行`node blocking.js`，这就是我们运行文件的方式。我们输入`node`并指定文件名，如下代码所示：

```
 node blocking.js 
```

当我运行文件时，我们得到一些输出。启动 user1 会打印到屏幕上，然后它会显示在屏幕上：

![](assets/20b59ccb-f0e6-489a-bfcb-4d12c123e78c.png)

现在，我们将 user1 对象打印到名为 Andrew 的屏幕上，并将启动 user2 打印到屏幕上，如以下代码输出所示：

![](assets/1042e6f6-cea0-4939-a0a6-f5ae5687895d.png)

在这之后，user2 对象在大约五秒钟后返回，名称为 Jen。

如前一个屏幕截图所示，我们的两个用户已经打印到屏幕上，最后我们的总和是 3，打印到屏幕上；一切都很好。

请注意，启动 user1 之后紧接着完成 user1，启动 user2 之后紧接着完成 user2，因为这是一个阻塞应用程序。

现在，我们将运行非阻塞文件，我称之为`non-blocking.js`。当我运行此文件时，启动 user1 打印，启动 user2 打印，然后总和背对背打印所有内容：

![](assets/b2645e90-ed2b-47f9-bc54-0f86d99d7392.png)

大约 5 秒钟后，用户 1 和用户 2 基本上同时打印到屏幕上。

这就是非阻塞的工作原理。仅仅因为我们启动了一个 I/O 操作并不意味着我们不能做其他的事情，比如启动另一个 I/O 操作并将一些数据打印到屏幕上，在本例中只是一个数字。这就是最大的区别，这也是非阻塞应用如此神奇的原因。他们可以同时做很多事情，而不必担心多线程应用程序的混乱。

让我们回到浏览器中，在 Node 网站上再次查看这些句子：

![](assets/5362f1ab-d1ae-4a24-805f-0c29032f702f.png)

Node.js 使用了一个事件驱动的、非阻塞的 I/O 模型，这使得它变得轻量级和高效，我们已经看到了这一点。

因为节点是非阻塞的，所以我们能够将应用程序所花费的时间减少一半。这种无阻塞 I/O 使我们的应用程序超级快速，这就是轻量级和高效的发挥作用的地方。

# 节点社区–解决问题的开源库

现在，让我们转到节点网站上的最后一句话，如以下屏幕截图所示：

![](assets/77e0d3cd-2131-4e2b-9e51-24548fa6adaa.png)

js 的包生态系统 npm 是世界上最大的开源库生态系统。这才是 Node 的真正魅力所在。这是社区中最重要的部分，人们每天都在开发新的库来解决 Node.js 应用程序中的常见问题。

诸如验证对象、创建服务器以及使用套接字实时提供内容等。已经为所有这些构建了库，所以您不必担心这一点。这意味着您可以专注于与应用程序相关的特定内容，而无需在编写真正的代码之前创建所有这些基础设施，这些代码可以执行特定于应用程序用例的操作。

现在，在[npmjs.org](http://npmjs.org)上提供的 npm 是我们将转向的许多第三方模块的网站：

![](assets/8b3348a0-e931-4ece-a38d-7fbee074a008.png)

若您试图解决节点中听起来很普通的问题，那个么很可能有人已经解决了它。例如，如果我想验证一些对象，假设我想验证 name 属性是否存在，以及是否有一个长度为 3 的 ID。我可以进入谷歌或者 npm；我通常选择谷歌，我可以用谷歌搜索`npm validate object`。

当我在谷歌上搜索时，我只会在[npmjs.com](http://npmjs.com)上查找结果，你可以找到前三个左右的结果：

![](assets/83bd9ccc-dcdd-4f5f-aff2-b74cc3b8c031.png)

我可以单击第一个，这将让我浏览文档，看看它是否适合我：

![](assets/c77764e8-64dc-4c68-947c-e4e74dbb858a.png)

这个看起来很棒，所以我可以毫不费力地将它添加到我的应用程序中。

现在，我们将经历这个过程。别担心，我不会让你对如何添加第三方模块感到焦虑不安。我们将在书中使用大量的节点，因为这是真正的节点开发人员所做的。他们利用了开发人员的奇妙社区，这是使 Node 如此伟大的最后一件事。

这就是为什么 Node 现在处于强大的地位，因为它是无阻塞的，这意味着它对 I/O 应用程序非常有用，并且它有一个非常棒的开发人员社区。所以，如果你想完成任何事情，有可能已经有人编写了代码来完成。

这并不是说你再也不应该使用 Rails、Python 或任何其他阻塞语言，这不是我的意思。我真正想向您展示的是 Node.js 的强大功能，以及如何让您的应用程序变得更好。像 Python 这样的语言有一些东西，比如 Twisted 库，其目的是向 Python 添加非阻塞特性。尽管最大的问题是所有的第三方库，因为它们仍然是以阻塞的方式编写的，所以您可以使用的库非常有限。

由于节点是从头开始无阻塞构建的，[npmjs.com](http://npmjs.com)上的每个库都是无阻塞的。所以你不必担心找到一个非阻塞与阻塞的对比；您可以安装一个模块，知道它是使用非阻塞思想从头开始构建的。

在接下来的几个部分中，您将编写第一个应用程序并从终端运行它。

# 节点应用程序的不同文本编辑器

在本节中，我想向您介绍本书可以使用的各种文本编辑器。如果你已经有一个你喜欢使用的，你可以继续使用你拥有的。没有必要为了完成这本书中的任何事情而更换编辑。

现在，如果您没有，并且正在寻找一些选项，我总是建议您使用**Atom**，您可以在[Atom.io](http://atom.io)上找到。它是免费的、开源的，并且可以在所有操作系统、Linux、macOS 和 Windows 上使用。它是由 GitHub 背后的人创建的，我将在本书中使用它的编辑器。有一个很棒的主题和插件开发者社区，所以你可以根据自己的喜好定制它。

现在，除了 Atom，还有一些其他的选择。我听到很多人在谈论**Visual Studio 代码**。它也是开源的、免费的，在所有操作系统上都可用。如果你不喜欢 Atom，我强烈建议你看看这个，因为我已经通过口耳相传听到了很多好东西。

接下来，我们一直有**升华文本**，您可以在[升华文本网站](http://sublimetext.com)上找到。现在，Sublime 文本不是免费的，也不是开源的，但它是一个很多人都喜欢使用的文本编辑器。我更喜欢 Atom，因为它与 Sublime 文本非常相似，尽管我发现它更简洁、更易于使用，而且它是免费的、开源的。

现在，如果您正在寻找一个更高级的编辑器，它在 IDE 中提供了所有的功能，而不是文本编辑器，那么我总是推荐**JetBrains**。他们的产品都不是免费的，虽然他们有 30 天的免费试用期，但它们确实是最好的贸易工具。如果你发现自己在一家公司工作，或者你在一份公司愿意支付编辑费用的工作中，我总是建议你选择 JetBrains。他们的所有编辑器都附带了您期望的所有工具，例如版本控制集成、调试工具和内置部署工具。

所以，花点时间，下载一个你想用的，玩一玩，确保它适合你的需要，如果不适合，试试另一个。

# Hello World–创建并运行第一个节点应用程序

在本节中，您将创建并运行第一个节点应用程序。嗯，这将是一个简单的问题。它将演示从创建文件到从终端运行文件的整个过程。

# 创建节点应用程序

第一步是创建一个文件夹。我们创建的每个项目都将在其自己的文件夹中运行。我将在 macOS 上打开**Finder**并导航到我的桌面。我希望您在操作系统上打开桌面，无论您是在 Linux、Windows 还是 macOS 上，并创建一个名为`hello-world`的全新文件夹。

I don't recommend using spaces in your project file or folder names, as it only makes it more confusing to navigate inside of Terminal. Now, we have this `hello-world` folder and we can open it up inside of our editor.

现在我将使用 c*ommand*+*O*（*Ctrl*+*O*用于 Windows 用户）打开，导航到桌面并双击我的 hello world 文件夹，如下所示：

![](assets/0f41597b-8ced-4bd1-a43f-84b71697a3d6.png)

左边是我的文件，没有。那么，让我们创建一个新的。我将在项目的根目录中创建一个新文件，我们将其命名为`app.js`，如下所示：

![](assets/1f21ffe8-49cf-414a-bfa2-e0cab5682fa0.png)

这将是节点应用程序中唯一的文件，在这个文件中，我们可以编写一些代码，在启动应用程序时执行这些代码。

将来，我们会做一些疯狂的事情，比如初始化数据库和启动 web 服务器，但现在我们只使用`console.log`，这意味着我们正在访问 console 对象上的 log 属性。这是一个函数，所以我们可以用括号调用它，我们将以字符串形式传递一个参数，`Hello world!`。我将在末尾抛出一个分号并保存该文件，如以下代码所示：

```
console.log('Hello world!');
```

这将是我们运行的第一个应用程序。

Now, remember, there is a basic JavaScript requirement for this course, so nothing here should look too foreign to you. I'll be covering everything new and fresh inside of this course, but the basics, creating variables, calling functions, those should be something you're already familiar with.

# 运行节点应用程序

现在我们有了`app.js`文件，唯一要做的事情就是运行它，我们将在终端上完成。现在，要运行这个程序，我们必须导航到我们的项目文件夹。如果你不熟悉终端，我会给你一个快速复习。

您可以随时了解在 Linux 或 macOS 上使用`pwd`的位置，或者在 Windows 上使用`dir`命令的位置。运行时，您将看到类似于以下屏幕截图的内容：

![](assets/d60c2c2f-132e-4e91-9502-3ac7e918147c.png)

我在`Users`文件夹中，然后我在我的用户文件夹中，我的用户名正好是`Gary`。

When you open Terminal or Command Prompt, you'll start in your user directory.

我们可以使用`cd`导航到桌面，这里是：

![](assets/8f231b7e-2265-4f50-8652-6f360e5727ee.png)

现在我们坐在桌面上。您可以在计算机上任何位置运行的另一个命令是`cd /users/Gary/desktop`。这将导航到您的桌面，无论您位于哪个文件夹。命令`cd desktop`要求您在用户目录中才能正常工作。

现在我们可以开始将 cd 插入我们的项目目录，我们称之为`hello-world,`，如下命令所示：

```
cd hello-world
```

使用以下屏幕截图：

![](assets/3490414c-477f-42bf-a6b8-59748150c574.png)

一旦我们进入这个目录，我们就可以在 Linux 或 Mac 上运行`ls`命令（Windows 上的`dir`命令）来查看我们的所有文件，在这种情况下，我们只有一个文件，我们有`app.js`：

![](assets/533e8079-8292-4d97-a74d-ddb45f680e25.png)

这是我们将要运行的文件。

现在，在你做任何其他事情之前，确保你在`hello-world`文件夹中，并且你应该在里面有`app.js`文件。如果您这样做，我们所要做的就是运行`node`命令，然后再加上一个空格，这样我们就可以传入一个参数，该参数将是文件名`app.js`，如下所示：

```
node app.js
```

一旦你准备好了，点击*进入*，我们就开始了，你好，世界！打印到屏幕上，如下所示：

![](assets/dcd99b26-6948-473b-a370-a873bf676c13.png)

这就是创建和运行一个非常基本的节点应用程序所需要的一切。虽然我们的应用程序并不酷，但我们将使用这个过程来创建文件夹/文件，并在本书中从终端运行它们，所以这是我们制作真实世界节点应用程序的一个很好的开始。

# 总结

在本章中，我们介绍了 Node.js 的基本概念。我们看了一下节点是什么，了解到它构建在 V8 JavaScript 引擎之上。然后，我们探讨了 Node 为什么如此流行，它的优点和缺点。我们查看了可以选择的不同文本编辑器，最后创建了第一个节点应用程序。

在下一章中，我们将深入并创建我们的第一个应用程序。我真的很高兴开始编写真实世界的应用程序。