# 第六章。测试、基准测试和分析

测试你的应用程序和它的开发一样重要。测试是分析应用程序模块和整个应用程序的过程，以查看它是否如您所期望的那样运行。它允许您的企业定义用例，并检查它们是否全部完成。

有很多测试技术。其中最著名的是**测试驱动开发** ( **TDD** )。这项技术包括使用尽可能少的开发周期。在每个周期之间，执行测试，并且在开发之前添加测试和用例。这样，您的应用程序版本可以被持续测试，任何有缺陷的版本都可以被快速发现。如果使用版本控制系统，比如 Git，那么找到测试失败的罪魁祸首并修复它就变得非常容易。

从头开始执行测试的一个重要方面是，当您发现用例和测试用例时，您可以继续添加它们。例如，如果有人报告了一个 bug，而您为它创建了一个特定的用例，您可以确保这个 bug 不会再次出现，或者它不会在测试中出现。在社区驱动的项目中，看到这个用例是非常常见的(一个成员发现了一个错误并为它添加了一个测试用例)。如果你能复制它，你就能创建一个测试用例。

根据您的测试平台，您可以对您的应用程序进行基准测试。通常，测试平台每个测试的默认超时时间长达 1 或 2 秒。对于希望确保性能良好的功能，可以降低该值。您也可以通过给更长的用例更多的时间来做相反的事情。

具有此超时功能的平台允许您进行一致的测试。记得在通用平台上测试，比如一般的工作环境。不要为超高速服务器定义测试基准，然后期望它们在 20 年前的计算机上通过。

# 测试基本面

测试可以用多种方式定义。最常见的方法是单元测试。这是一种方法，通过这种方法，您的应用程序的各个部分被单独检查，以确认它们符合规范。这种方法鼓励您的应用程序部件充当独立的、可替换的黑盒。

您需要真实数据来正确测试您的应用程序。你还需要不切实际的数据。这两者对于确认它对正确数据和加扰数据的行为符合预期都是至关重要的。这确保了被误导或恶意的用户不会破坏您的应用程序。

你可能想知道我说的不现实的数据是什么意思。您的应用程序处理日期字段中的文本还是复选框中的数字？丢失数据怎么办？你可能认为是这样，但是如果你有更多的开发人员在开发它，你可能想要确保，在未来的某个地方，它不会停止正确的行为。最常见的错误类型发生在一个地方，在一个完全不同的地方进行更改之后。

单元测试的目标应该是完全隔离应用程序的每个模块，并且能够独立测试它们。如果一个模块需要应用程序的其他部分才能正常工作，您可以伪造该数据或模拟该依赖关系，例如使用 Sinon([http://sinonjs.org/](http://sinonjs.org/))。

测试的一些好处如下:

*   bug 是在开发周期的早期发现的。因为您可以在每次更改代码时测试代码，所以应该更早发现错误。更早修复 bug 的成本，有时甚至在投入生产之前，大大降低了整体成本。
*   它迫使开发人员考虑输入/输出数据和错误，因为应用程序架构师必须思考并正确描述每个用例。特性和用例是在考虑一个或多个测试用例的情况下开发的。
*   它支持更改或重构模块，同时仍然确保预期的行为由于测试用例而保持不变。
*   它有助于模块集成测试，因为每个模块都经过测试并具有预期的行为。

只有正确定义了测试，并且您的测试覆盖了整个应用程序(所有函数和对象)，所有这些好处才能实现。有了适当的测试覆盖，您还可以为新特性或边缘案例添加特定的用例。

分离每个模块的测试相当困难。例如，如果您的一个模块需要一个数据库来工作，那么您的测试用例将需要给它数据库访问权。这并不好，因为你的单元测试实际上是一个集成测试，如果它失败了，你就不能说问题是出在模块上还是数据库上。

## 测试环境

拥有一致的测试环境也很重要。更重要的是，环境应该与生产环境相同或几乎相同。这意味着相同的应用程序(当然)，但也是相同的操作系统版本，相同的数据库服务器版本，等等。

例如，对于 Node.js 测试，确保您的测试环境具有相同的 Node.js 版本。你可以用不同的版本进行测试，但最重要的是生产中使用的版本。这同样适用于操作系统版本、数据库服务版本、依赖项版本等。

## Docker 工具

拥有相同的环境可能不容易，但是有一个解决方案——Linux 容器。如果你还没试过 Docker，你就错过了火车。这个解决方案是免费的，是一个包含容器的工具，使它们可用。

与游民等工具相比，它的主要区别在于它不需要虚拟机来创建环境。Docker 类似于OpenVZ([https://openvz.org/Main_Page](https://openvz.org/Main_Page)，但有一个转折；您可以创建一个环境(容器)并共享给其他人使用。如果你喜欢 NPM，你会发现这很相似。您有版本控制和依赖关系，并且最常用的环境已经在线供您下载和使用。

您可以在容器中创建一个测试环境，然后将该容器分发给其他开发人员。这也适用于生产。您的开发人员可以在其笔记本电脑中获得生产数据库和完整生产环境的快照。这样，就可以像应用于生产一样进行更改和测试。这比在生产中尝试并不得不回滚要好。这样，你就不会那么频繁地回滚。这是持续整合的原则。

让我们为我们的 Node.js 应用程序创建一个非常简单的环境。安装 Docker，打开一个终端，并运行以下代码:

```js
$ docker pull node:0.12.4
Pulling repository node
4797dc6f7a9c: Download complete
...
6abd33745acb: Download complete
Status: Downloaded newer image for node:0.12.4

```

请记住，我们想要一个特定的版本，这就是我们在这种情况下强制`0.12.4`的原因。我认为操作系统不重要，因为我们的应用程序不会有外部依赖或节点模块。这个命令只是下载图像模板，还没有创建任何环境；我们马上就去做。你会注意到它需要几百兆字节。不用担心；这可能是您唯一需要的空间，因为您的环境几乎总是依赖于此图像。如果您想签出下载的图像，请运行以下命令:

```js
$ docker images
REPOSITORY     TAG       IMAGE ID        CREATED      VIRTUAL SIZE
node           0         4797dc6f7a9c    3 days ago   711.8 MB
node           0.12      4797dc6f7a9c    3 days ago   711.8 MB
node           latest    4797dc6f7a9c    3 days ago   711.8 MB
node           0.12.4    4797dc6f7a9c    3 days ago   711.8 MB

```

嗯，那里有很多空间，不是吗？如果你仔细看，你会注意到只有一个图像(第`IMAGE ID`个是一样的)。发生的事情是`0.12.4`实际上是写这本书的时候的最新版本，最新的标签也被分配给了我们的形象。此外，该版本是`0.12`的最后一个版本，也是 0 的最后一个版本。

这意味着我们可以使用这些标签中的任何一个来引用我们的图像，但是我们不希望这样，因为新版本可能会出现，我们的图像将开始用这些新版本构建。

我们可以看到哪些容器正在运行，或者以前创建过，并且不再运行。我们可以简单地看到什么在运行，但我发现看到死容器更有用，因为它们可能会使用不必要的空间。现在没有集装箱了。我们可以简单地测试图像，看看它是否有效:

```js
$ docker run -it node:0.12.4 bash
root@daa77af1b150:/# node -v
v0.12.4
root@daa77af1b150:/# npm -v
2.11.1
root@daa77af1b150:/# exit

```

我们只是使用我们的图像运行了一个基本环境，在一个`tty` ( `-t`)中以交互模式(`-i`)运行`bash`，而不是在后台运行(`-d`)。你可以看到我们在环境中有节点和`npm`。如果我们看看哪些容器存在，我们会看到类似这样的东西:

```js
$ docker ps -a
CONTAINER ID     IMAGE      COMMAND     CREATED ...
1a56bbeb3d36     node:0     "bash"      47 seconds ago ...

```

我们的容器有唯一的标识符`1a56bbeb3d36`，正在使用`0`节点图像，并且正在运行`bash`命令。嗯，它实际上不再运行了。您可以通过运行以下命令将其删除:

```js
$ docker rm 1a56bbeb3d36

```

注意到`ps`命令中的`Exited (0) ..`行了吗？是的，命令的退出代码是可访问的。如果你用`exit` `123`退出`bash`，你会看到它在集装箱外面。这对于启动测试命令而不是`bash`然后根据退出代码检查是否所有测试都通过来说是很棒的。您也可以记录输出，如果出现故障，将其保存以供分析。

## 测试工具

现在我们有了一种复制环境进行测试的形式，我们需要一个合适的测试工具——你可以用来定义你的用例和测试用例。有很多很棒的工具，Node.js 有专门的测试工具。有些真的很棒。

如果你没什么想法，我建议你试试摩卡([http://mochajs.org/](http://mochajs.org/))。它可以在 NPM 安装，你应该在全球安装:

```js
sudo npm install -g mocha

```

这样，您就可以在计算机上的所有应用程序中使用 mocha，而无需反复安装，因为它实际上是一个开发/测试依赖项，而不是真正的应用程序依赖项。全局安装它也会在您的路径中安装`mocha`命令。

让我们创建一个非常简单的模块`module`。js 带有一个简单地将两个数字相加的函数:

```js
// add a with b
exports.add = function (a, b) {
  return a + b;
};
```

现在，让我们创建一个测试用例。为此，我们将创建另一个名为`test.js`的文件:

```js
var assert = require("assert");
var m      = require("./module");

describe("module.add()", function () {
  it("should add two numbers", function () {
    assert.equal(m.add(2, 3), 5);
  });
});
```

可以看到，这个文件加载了我们的模块(`m`)并断言`m.add`应该加两个数字。为了检查它，我们通过检查模块在通过`2`和`3`时是否返回`5`来添加一个测试用例。现在，在有这两个文件的文件夹中打开一个终端，运行`mocha`就可以了，不需要任何参数，如下所示:

![The test tool](graphics/4183_06_01.jpg)

很好，不是吗？还有其他形式的输出叫做**记者**，比如进度，列表，或者点阵。如果你只是想要一个简单的输出，尝试列表或进度。如果你想要每一个测试的细节，使用规格报告器。它显示在前面的截图中。

让我们在函数中添加另一个测试。将测试文件更改为如下所示:

```js
var assert = require("assert");
var m      = require("./module");

describe("module.add()", function () {
  it("should add two numbers", function () {
    assert.equal(m.add(2, 3), 5);
  });

  it("should return null when one is not a number", function () {
    assert.equal(m.add(2, "a"), null);
  });
});
```

如果你再次运行`mocha`，你的测试用例将导致`test`套件失败，如这个截图所示:

![The test tool](graphics/4183_06_02.jpg)

让我们改变我们的模块，使其行为正确，正如我们在新测试中所述。你可以想怎么改就怎么改；我只举一个例子:

```js
// add a with b
exports.add = function (a, b) {
  if (isNaN(a) || isNaN(b)) {
    return null;
  }
  return a + b;
};
```

再次运行时，我们的测试应该会通过，如下图所示:

![The test tool](graphics/4183_06_03.jpg)

我们现在可以在我们的环境中测试它，而不是直接测试它。这确保了我们的应用程序在干净的环境中工作，并且不会因为您的本地环境中的某些东西而通过。为此，我们可以使用之前的节点图像。让我们创建一个简单的测试环境。为此，我们需要在测试文件夹中创建一个名为`Dockerfile`的文件:

```js
FROM node:0.12.4

RUN npm install -g mocha

VOLUME /opt/app/

```

这描述了我们的环境。该文件描述如下:

*   使用节点图像版本`0.12.4`
*   安装`mocha`依赖项
*   在`/opt/app`上创建可链接体积

现在，让我们构建我们的环境，并将其称为`env/test`。我们实际上是在另一个图像的基础上创建一个新图像。我们的可链接卷是一个在运行环境时可以指定的文件夹。这样，您就可以在所有应用程序中使用这个图像。为了构建我们的环境，我们运行以下程序:

```js
$ Sending build context to Docker daemon 11.26 kB
Sending build context to Docker daemon
Step 0 : FROM node:0.12.4
 ---> 4797dc6f7a9c
Step 1 : RUN npm install -g mocha
 ---> Running in 286c8bb64a2b
...
Removing intermediate container 26fd9bb79ed5
Successfully built e36af32c961c

```

我们现在有了一个可以使用的图像。让我们通过使用`mocha`运行测试来尝试图像。

![The test tool](graphics/4183_06_04.jpg)

有关命令行的详细信息，请查看 Docker 的在线文档。我们正在运行我们的映像，其中`/opt/app` ( `-v`)卷是我们当前的文件夹(带有我们的 Node.js 文件)。我们的测试环境在交互模式下运行(`-it`)，结果图像在最后被丢弃(`--rm`)。

如果您有一个中央代码存储库，最好在提交之前进行测试，以避免常见错误。它还避免了中断更改。做出改变来修正或改进某个东西，打破其他东西是很常见的。有了一个始终干净的测试环境，开发人员可以确保测试正确运行。此环境可能类似于下图中的环境:

![The test tool](graphics/4183_06_05.jpg)

## 持续整合

**持续集成** ( **CI** )是一种实践，其中应用程序的所有开发人员持续地将其变更集成到一个中央存储库中。这是 **极限编程** ( **XP** )中使用的做法。它可以更快地引入新功能，并通过减少代码合并时间来帮助避免代码冲突。

如果应用程序有一个好的测试套件，开发人员可以在复制的生产和测试环境中本地测试变更，如果通过就提交。这些测试不应取代在服务器上进行的测试。如果测试套件执行得很快，它甚至可以保证提交被合并，但是通常不建议这样做，因为有些提交实际上无法通过。通常，所有的提交都被接受，只有在那时它们才被测试。测试结果应该是公开的，至少在开发人员的圈子里是公开的，作为一种强制他们处理提交、他们如何构造代码以及他们如何描述提交的方式。

CI 有四个最佳实践:

*   拥有一个代码库，并使用修订控制系统
*   应该检查每个提交，以保证它通过所有测试
*   将测试环境与生产环境分开
*   自动化部署

实现该工作流程的一种方法是使用 **git** 。因为它允许您为提交和合并定义钩子，所以您可以向中央存储库添加一个钩子来测试每个新的提交。如果提交通过，它可能有资格传递到生产。

一种策略是将通过所有测试的最新提交与生产合并。这可能是每次提交通过时，也可能是在特定时间。对于简单的应用，这种方法是可以接受的。但是如果你有一个大的用户群，这真的会有风险。确保您的测试基础非常好，并且至少查看和阅读提交更改日志。您应该知道以下风险:

*   您的测试基础可能不会覆盖您的所有代码。这意味着您的代码中有些部分没有经过测试，这增加了其行为的不确定性。在这种情况下，您应该尝试覆盖尽可能多的代码。
*   您的测试基础可能不会覆盖您所有的用例。如果您的所有用例没有在测试中描述，那么它们将不会在您的代码中测试。他们可以得到正确的处理，但仍然不确定。所以，你应该描述你所有的用例。
*   有些测试用例不容易描述甚至重现。您应该努力避免这些类型的测试，并确保您可以完全依赖测试。否则，您将需要有人在应用程序投入生产之前测试它们的变化。

此外，能够针对生产数据库测试应用程序也很重要，可能是最新的备份或具有复制功能的数据库，您可以在不影响生产环境的情况下使用这些数据库。

数据大小总是会影响应用程序的性能。如果你只是测试你的模块来检查简单的用例，你不是在测试负载，但是你应该这样做。有时，您的生产数据可能会有一些关系，除了最初之外，您并没有这些关系。你可能认为你的代码不允许这些关系出现，但你可能错了。

例如，考虑一个层次结构，其中您为某个元素定义了一个父元素。假设这个后代也可以是另一个元素的父元素。如果三级后代是长辈的父母呢？这就产生了一个你可能不想要但又不得不处理的循环。即使您的应用程序一开始不允许出现这个循环，也要考虑获取保护自己免受其害所需的代码。

### 代码覆盖率

让您的所有代码都被测试覆盖是很重要的，以确保您真的在测试所有的东西，或者至少是所有编码的东西。这不是一项容易的任务。代码中的条件和循环创建了不同情况和运行路径的日志，并且一些代码可能仅在非常特定的情况下被触发。这种情况需要以某种方式进行检验。

代码覆盖率是一个度量，用于指示测试套件覆盖了多少代码。更高的度量表示您的应用程序更“测试覆盖”并且通常是低错误概率的指示。这个度量通常以百分比值给出，50%的覆盖率意味着测试套件覆盖了一半的代码。

有工具可以帮你找到这个值，否则就不可能算出来。在 Node.js 环境中，这些工具通常会创建一个代码的副本，在这个副本中，它们会更改每一个重要的行，以便计算执行通过该行的次数。有效行是包含真实代码的行，而不是注释或空行。

也有在线服务可以做到这一点。根据您的应用程序许可证或预算，您可能更喜欢在本地准备测试环境。这通常不像看起来那么简单。您必须创建一种方法来检测您的代码(最好在副本上完成)，并在收集覆盖率度量的同时运行您的测试，然后生成报告。

Node.js 有几个工具可以尝试。没有什么神奇的工具，你应该看看什么最适合你和你的应用。一个可能的工具是`istanbul`。让我们在我们的小测试示例中尝试一下。您会发现这有点棘手，对于一个真正的应用程序，您必须自动化这个过程。让我们从安装依赖项开始:

```js
sudo npm install –g istanbul mocha-istanbul

```

`mocha-istanbul`依赖项可以在本地安装。`istanbul` Node.js 模块应该是全局的，因为它有一个命令供我们使用。现在我们可以检测我们的代码了。让我们创建一个检测副本:

```js
istanbul instrument module.js > instrumented.js

```

我们现在必须改变我们的测试套件来使用我们的仪表化版本:

```js
var assert = require("assert");
var m      = require("./instrumented");

describe("module.add()", function () {
  it("should add two numbers", function () {
    assert.equal(m.add(2, 3), 5);
  });

  it("should return null when one is not a number", function () {
    assert.equal(m.add(2, "a"), null);
  });
});
```

最后，我们只需要使用`istanbul`报告器运行我们的测试套件。为此，使用`reporter`参数运行`mocha`:

```js
mocha –reporter mocha-istanbul test.js

```

您将看到一个报告，显示您的代码中有多少行和函数被测试套件覆盖，而不是显示测试的描述。以下是输出示例:

![Code coverage](graphics/4183_06_06.jpg)

之后，你应该有一个名为`html-report`的文件夹，里面有一个`index.html`页面。在你的浏览器中打开它来分析你的测试覆盖率。您应该会看到类似以下截图的页面:

![Code coverage](graphics/4183_06_07.jpg)

你会看到`test`文件夹，在里面，你会找到我们最初的模块。点击它，你会看到一份报道。对于每一个重要的行(请注意，带有结束括号的行被忽略)，您将有一个相关的数字。它对应于我们测试时执行通过那条线的次数。在我们的例子中，是绿色背景的 **1** 和 **2** 列。原因很容易理解，因为我们只有两个测试。

![Code coverage](graphics/4183_06_08.jpg)

## 基准测试

基准测试是运行一组工具或测试来测量特定性能指标的过程，以便与其他工具或过去的测试进行比较。应用程序最常见的基准测试与两个相似的指标相关:时间(一个操作)和操作(一段时间内)。

为了保持应用程序的性能，您需要不断地对其进行基准测试。一个显而易见的方法是使用测试套件，其中您添加特定的测试只是为了基准测试的目的。在检查完常见用例之后，您可以进行特定的测试，确保某些操作在特定的目标时间内继续运行。

认真对待标杆，但不要因此失眠！大多数时候，当您开始应用程序开发时，您只是没有可以比较的统计数据，并且不知道要定义什么样的基准测试。

首先对简单的列表进行基准测试，比如历史列表，并确保它们的性能不会超过 100 毫秒。创建更复杂的界面时，请确保其呈现也表现良好。如果一个简单的任务要等半秒钟以上，而一个复杂的任务要等一两秒钟以上，人们就会感到压力很大。

这些基准测试通常使用生产数据的副本来完成，如果数据太大，则使用其中的一个子集来完成，以确保您在测试环境(如您的个人笔记本电脑)中针对大量数据而不是少量数据进行基准测试。您也可以根据生产数据进行测试，但我不建议这样做。

例如，使用我们之前的测试框架，`mocha`确保每个测试运行不到两秒钟。您可以更改特定测试的默认超时。让我们用一个新的测试文件`timeout.js`来测试一下:

```js
describe("timeout", function () {
  this.timeout(100); // milliseconds

  it("will fail", function (done) {
    // we should call done() but we don't to cause timeout
  });
});
```

我们正在创建一个异步测试。这是因为我们在测试函数中引用了`done`在测试结束时调用。在这种情况下，我们不是专门称之为来迫使它失败。让我们试试，如下所示:

![Benchmark tests](graphics/4183_06_09.jpg)

在性能很重要的特定测试中使用超时是一种很好的做法。对于大多数常见的测试来说，正常的超时可能没问题，但是请确保您分析了一些特定的测试，并确保它们在一定的时间内执行。

超时可以是一个性能限制，也可以是一个标记，当应用程序变得太复杂或者测试数据变得太大而无法保持性能时，它会通知您。这时候，基于前一章，您需要看一看您的环境并分析您的后续步骤。

测试套件(如 mocha)还可以为您提供其他有趣的信息来补充您的测试，并帮助您更好地了解应用程序的行为，例如:

*   报告测试持续时间，即使对于不是基准测试的测试，这将允许您首先进行测试并查看度量，然后定义一个好的超时标记。
*   提交测试报告。它们可用于质量保证报告，并可保存以供以后分析或比较。

具体针对 Node.js 应用，`mocha`可以为您提供:

*   内存泄漏检测，通过在测试前后查看全局变量
*   未捕获的异常检测，指示导致异常的测试
*   无缝异步支持
*   Node.js 调试器支持
*   浏览器支持

## 分析测试

拥有一个测试套件非常重要。最重要的好处是让您的应用程序得到全面测试，或者至少尽可能多地进行测试。创建初始测试环境可能是一个挑战，但是随着您不断开发您的应用程序，它会得到回报。

执行适当的测试可确保您:

*   不要用新功能重新引入旧 bug。这甚至可以在不接触源代码的情况下通过改变数据库来实现。
*   可以先通过定义测试用例来定义用例(看看[https://en.wikipedia.org/wiki/Test-driven_development](https://en.wikipedia.org/wiki/Test-driven_development))。
*   可以进行更改，并轻松检查应用程序是否保持预期的行为。
*   可以检查您的测试覆盖率，看看它是如何随着时间而变化的。
*   可以为新发现的 bug 创建特定的测试，并确保它们不会再次出现。
*   确保基准测试在特定指标下运行。

获得一个合适的测试套件类似于让一个质量保证人员在您每次进行更改时测试您的应用程序。此外，您的质量保证人员不会像您的测试套件那样精确或快速。

如果您的应用程序有比您更多的开发人员，请确保您强制测试成功通过，并且测试覆盖率达到 90%这样的高分。如果您自动化了您的覆盖测试，您可以使用覆盖度量作为将新特性与生产合并的条件。

确保您的测试在开发小组圈子中是公开的，让每个人都能看到其他人的工作。这激励人们更好地工作，因为他们的名声是公开的，至少在团队内部是这样。

当有更多的人关注测试时，开发人员可以分享经验，并在遇到失败的测试时寻求帮助。这减少了修复问题所花费的时间，并激励开发人员保持测试套件始终运行。这应该是一个不变的目标——保持测试历史没有失败。

# 总结

一个好的、高性能的应用程序完全取决于它的性能。一个完整的测试套件可以确保您在开发中也有良好的表现，并且可以快速引入更改，这些更改可以提高性能。测试套件应该有针对基准分析的特定测试，并有严格的时间限制。开发人员应该了解它们，并努力保持测试通过，而不必取消那些限制。

使用测试套件作为生产指标。如果您的测试套件以至少 90%的覆盖率覆盖了您的应用程序源，并且通过了所有的基准测试，请确保您合并了新的更改。为这些测试使用单独的服务器，不要将测试与生产混合在一起。让您的生产服务器保持精简和快速，并且只有在您确定它将保持这种方式时才进行更改。

在下一章中，我们将研究瓶颈——降低性能的限制——以及您对此无能为力的情况。你必须努力为他们做好准备，如果可能的话，试着减轻他们的后果。网络、服务器和客户端是导致瓶颈的一些因素。有些你可以控制和最小化，但有些…你只需要为它们做好准备。