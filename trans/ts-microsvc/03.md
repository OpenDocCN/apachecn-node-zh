Exploring Reactive Programming <link rel="stylesheet" href="css/style.css" type="text/css"> 

# 探索反应性编程

到目前为止，我们将我们的应用程序描述为非常著名的行业术语的混合，例如异步、实时、松散耦合、可伸缩、分布式、消息驱动、并发、非阻塞、容错、低延迟和高吞吐量。 在本章中，我们将进一步了解反应式编程，它集合了所有这些特征。 我们将看到并理解“反应性宣言”——一套当集体应用时，将带来上述所有优势的原则。 我们将了解响应式微服务的一些关键方面，它应该是什么，以及响应式编程的关键优势是什么。 我们将看看反应式编程解决什么问题，反应式编程的不同风格，等等。

在本章中，我们将重点关注以下内容:

*   反应式编程简介
*   被动的宣言
*   反应性的微服务主要构建块和关注点
*   什么时候响应，什么时候不响应(协调)—介绍混合方法
*   在 Node.js 中响应

# 反应式编程简介

如果我们想要从地面上的 50000 人看到反应性编程，它可以简单地称为:

<q>When input x in any function changes, output y automatically updates in the corresponding response without the need to manually invoke it. In short, the sole purpose is to continuously respond to external inputs whenever prompted by output worlds.</q>

响应式编程是通过诸如映射、过滤、减少、订阅、退订、流等实用程序实现的。 响应式编程更多地关注事件和消息驱动模式，而不是手动处理大量的实现细节。

让我们通过一个实际的日常示例来理解响应式编程。 从 IT 行业开始，我们就一直在使用 Excel。 现在，假设你写了一个基于单元格值的公式。 现在，每当单元格值发生更改时，所有基于该值的相应结果都会自动反映更改。 这被称为**反应**。

简单理解反应式编程，当结合处理各种数据流时，反应式编程可以是高级数据流，具有处理以下事情的能力:

*   事件流，我们可以进入和订阅的流，然后使用订阅输出作为数据源。
*   拥有流使我们能够操作流，从原始流创建新的流，并在需要时应用转换。
*   转换应该在分布式系统中独立工作。 特定的转换可以是从不同地方接收到的多个流的合并。

函数式响应式编程是我们将要使用的响应式编程的变体。 简单地说，我们的功能性反应微服务应该有以下两个基本属性:

*   **意指或外指**:每个功能、服务或类型都是精确的、简单的、单一的、负责的和实现独立的。
*   **连续时间**:编程时应牢记时变值。 函数式反应式编程中的变量在很短的时间内都有一个值。 它应该为我们提供转换的灵活性、效率、模块化、单一责任。

下面是函数式反应式编程的特点:

*   **动态**:知道如何对时间做出反应或处理各种输入变化
*   **处理时间变化**:当反应值连续变化时，处理适当的变化
*   **高效**:当输入值发生变化时，需要的处理量最小
*   **意识到历史变迁**:维护局部而非全局的状态变化

现在我们简要地了解了响应式编程，让我们看看在采用响应式编程时我们获得了哪些优势。 下一节讨论并给出了为什么你应该放弃一切并开始响应式编程的强有力的理由。

# 为什么我应该考虑采用反应式编程?

既然我们已经揭开了反应式编程的神秘面纱，那么下一个大问题就是为什么我们应该关心反应式编程，以及在进行反应式编程时我们可以得到什么好处。 在这一节中，我们将看到响应式编程的主要好处，以及在任何时候轻松地管理代码来引入主要的新功能:

*   与回调或中间件相比，易于解释或利用任何功能。
*   轻松处理错误和内存管理，无需任何集中配置。 单个订阅可以有一个错误函数，您可以在该函数中轻松地处理资源。
*   有效处理与时间相关的复杂问题。 有时，在调用一些外部 API(如谷歌云视觉 API)时，我们会受到速率限制约束。 响应式编程在这种情况下有大量的用例。
*   去市场的速度更快。 当正确地实现时，响应式编程极大地减少了旧式代码到很少的代码行。
*   易于处理的可节流输入流，也就是说，我的输入流是动态的。 它可以根据需求增加或减少。

既然我们已经了解了响应式编程的一些主要优点，在下一节中，我们将讨论响应式编程的结果，一个响应式系统。 我们将在反应性宣言中看到一组定义的标准。

# 被动的宣言

响应式系统意味着耦合更松散、更灵活、更容易迁移和更容易根据需要进行伸缩。 这些品质使它更容易发展，优雅地处理错误，并对错误作出反应。 以优雅迎接错误，而不是幽闭恐怖的灾难。 反应性系统是有效的和即时的响应，为用户提供有效的和交互式的反馈。 为了总结反应系统的所有特点，本文引入了反应宣言**。 在这一节中，我们将看看反应性宣言和所有需要的标准。 现在，让我们看看反应宣言的表述。**

 **# 响应系统

作为响应性标准的一部分，响应性系统总是需要响应性。 他们需要及时向用户提供和响应。 这改善了用户体验，我们可以以更好的方式处理错误。 服务中的任何故障都不应该传播到系统中，因为它可能会导致一系列错误。 回应是至关重要的。 失败的服务即使降级也应该提供响应。

# 有弹性的错误

系统应该能够适应所有的错误。 弹性应该是这样的:错误被优雅地处理，而不是使整个系统崩溃。 弹性架构可以通过以下方式实现:

*   复制，以确保在主节点宕机的情况下有一个副本。 这避免了单点故障。 为了确保组件或服务应该以处理单个责任的方式在它们之间委托服务。
*   确保系统中的包容和隔离，以便将组件包含在其边界中。 它应该防止级联错误。 组件的客户端不需要处理自己的故障。

# 弹性可伸缩

这通常用于引用系统处理不同负载的能力，通过及时增加或减少所利用的资源数量。 反应系统应该能够反应一个时间点载荷,并相应地采取行动在可用资源提供一个具有成本效益的解决方案,也就是说,不需要或按比例缩小,当资源,扩大但只是这一比例的资源是必要的为了保证基础设施的成本在一个预设值。 系统应该能够分片或复制组件，并在它们之间分配输入。 系统应该能够在需要时为客户端服务请求的下游和上游服务生成新的实例。 应该有一个有效的服务发现流程来帮助进行弹性伸缩。

# 消息驱动的

异步消息传递是响应式系统的基础。 这有助于我们在组件之间建立边界，并并行地确保松耦合、隔离和位置透明性。 如果某个特定组件现在不可用，系统应该将失败委派为消息。 该模式通过控制系统中的消息队列(可选择在需要时应用反压力)，帮助我们实现负载管理、弹性和流控制。 非阻塞通信可以减少系统开销。 有许多工具等消息传递**Apache 卡夫卡**,**兔 MQ**,**Amazon 简单队列服务**、**ActiveMQ**,【显示】Akka,等等。 代码的不同模块通过消息传递彼此交互。 深入思考一下反应性宣言，微服务似乎只是反应性宣言的延伸。

# 主要构建块和关注点

继续我们的反应式编程之旅，我们现在将讨论反应式编程的主要构建块(准确地说是函数式反应式编程)以及反应式微服务实际上应该处理的问题。 下面是响应式编程的主要构建块列表以及它们都处理的内容。 响应式微服务应该基于类似的原则设计。 这些构建块将允许我们确保微服务是独立的，只有一个职责，可以异步传递消息，并且是可移动的。

# 可观察到的流

一个可观察的流只是一个随时间构建的数组。 项目不是存储在内存中，而是随着时间的推移异步到达。 可观察对象可以被订阅，由它们发出的事件可以被监听和响应。 每个响应式微服务都应该能够处理本地可观察的事件流。 可观察对象允许你通过调用系列中的`next()`函数向订阅者发送值:

*   **热可观察对象和冷可观察对象**:可观察对象根据订阅的生产者进一步分为热可观察对象和冷可观察对象。 如果需要多次创建，则称为**热观察对象**，而如果只需要创建一次，则称为**冷观察对象**。 简单地说，热观测多为*组播，*，冷观测多为*单播，*。 举一个活生生的例子，当你打开 YouTube 上的任何视频，每个订阅者都会看到相同的序列，从开始到结束，这基本上是一个冷观察。 但是，当您打开一个实时流时，您只能查看最近的视图并进一步查看。 这是一个热门的可观察对象，其中只有一个对生产者/订阅者的引用，而不是从每个订阅的开始就创建生产者。
*   **Subjects**:subject 只是一个可观察对象，它可以自己调用`next()`方法，以便根据需要发出新的值。 主题允许您从公共点广播值，同时将订阅限制为仅一个事件。 创建一个共享订阅。 一个主体既可以被称为观察者，也可以被称为可观察对象。 它可以作为一组订阅者的代理。 主题用于实现通用实用程序(如缓存、缓冲、日志等)的可观察对象。

# 订阅

observable 是一个随时间填充的数组，而**订阅**则是一个在数组中迭代的`for`循环，它会随时间发生。 订阅提供了易于使用和易于处理的方法，因此不存在内存加载问题。 在处理订阅时，可观察对象将停止侦听特定的订阅。

# 排放和地图

当一个可观察对象抛出一个值时，会有一个订阅方侦听该可观察对象抛出的值。 **emit**和**map**允许您侦听该值，并根据您的需要对其进行操作。 例如，它可以用来将 HTTP 可观察对象的响应转换为 JSON。 为了进一步增加链，提供了`flatMap`操作符，该操作符根据接收到的函数返回值创建一个新流。

# 操作符

当一个可观察对象发出值时，它们并不总是我们想要的形式。 操作符很有用，因为它们帮助我们改变可观察对象发出值的方式。 操作符可以在以下阶段使用:

*   在创建一个可观察序列时
*   将事件或一些异步模式转换为可观察序列
*   处理多个可观测序列，将它们合并为单个可观测序列
*   分享观察对象的副作用
*   在可观察序列上做一些数学变换
*   基于时间的操作，如节流
*   处理异常
*   过滤由可观察序列发出的值
*   分组和弹出窗口的值

# 反压力的策略

到目前为止，我们一直在玩可观察对象和观察者。 我们使用数据流(可观察对象)模拟我们的问题，将其传输到我们想要的输出(使用操作符)，并抛出一些值或一些副作用(观察者)。 现在，也可能发生这样的情况:一个可观察对象抛出数据的速度比观察者处理数据的速度快。 这最终导致数据丢失，称为**背压问题**。 要处理反压力，要么我们需要接受数据丢失，要么我们需要缓冲可观察流，并在数据丢失不是一个选项时以块的形式处理它。 不同的策略可在这两种选择:

| **当失败是一种选择** | **当失去不是一个选项** |
| **debelling**:只在时间跨度过去后发射数据。 | **Buffer**:设置要缓冲的时间量或最大事件数。 |
| **Pause**:暂停源流一段时间。 | **BufferedPause**:缓存源流发出的任何内容。 |
|  | **受控流**:这是一种推拉策略，生产者推送事件，而消费者只推送它能处理的内容。 |

# 局部套用功能

**curry**是一个逐个求函数参数的过程，每次求值结束时生成一个少一个参数的新函数。 当函数的参数需要在不同的地方求值时，套用是很有用的。 使用 curry 过程，一个参数可以在某个组件上求值，然后它可以被传递到任何其他位置，然后结果可以被传递到另一个组件，直到所有的参数都求值。 这与我们的微服务类比非常相似。 稍后，当我们有服务依赖时，我们将使用 curry。

# 什么时候反应，什么时候不反应(协调)

现在，我们正处于对微服务的核心概念非常熟悉的阶段。 下一个我们经常接触到的问题是关于微服务的实现，以及它们之间如何相互作用。 最常见的问题是什么时候使用编排，什么时候做出反应，以及是否可能使用混合方法。 在本节中，我们将了解每种方法及其优缺点，并查看每种方法的使用实例。 让我们从编配开始。

# 编制

**编排**更像是**面向服务的体系结构(SOA)**方法，我们在其中处理 SOA 中各种服务之间的交互。 当我们提到编排时，我们维护一个控制器，它是所有服务交互的编排器或主协调器。 这通常遵循更多的请求/响应类型模式，其中通信模式可以是任何类型。 例如，我们可以在我们的购物微服务中有一个协调器，它同步执行以下任务—首先，接受客户订单，然后检查产品，准备账单，在成功付款后，更新产品库存。

# 好处

它提供了一种处理编程流程的系统方法，在这种方法中，您可以实际控制发出请求的方式。 例如，您可以确保只有在请求 A 完成之后才能成功调用请求 B。

# 缺点

虽然编排模式可能看起来很有好处，但该模式涉及到几个折衷，例如:

*   对这个系统有很强的依赖性。 假设一个初始服务宕机，那么链中的下一个服务将永远不会被调用。 由于存在多个单点故障，系统很快就会成为瓶颈。
*   系统将引入同步行为。 总的端到端花费的时间是处理所有单个服务所花费时间的总和。

# 被动的方法

微服务应该独立共存。 他们不应该相互依赖。 响应式方法**倾向于解决编配方法的一些挑战。 响应式模式不需要一个控制编排器来负责哪个步骤在哪个阶段发生的逻辑，而是促进服务提前知道要构建和执行的逻辑。 这些服务知道要对什么做出反应，以及如何提前处理。 服务的通信模式是哑管道，它们内部没有任何逻辑。 由于本质上是异步的，因此它删除了编排流程中的等待部分。 服务可以产生事件并继续处理。 服务的生产和消费是解耦的，因此生产者不需要知道消费者是否上升。 在这种方法中可能有多种模式，生产者可能希望从消费者那里收到确认。 集中式事件流以响应式的方式处理所有这些事情。**

 **# 好处

被动的方法有很多优点，它克服了很多传统的问题:

*   并行或异步执行提供更快的端到端处理。 异步处理本质上不能防止服务请求时的资源阻塞。
*   使用集中式事件流或哑通信管道作为通信模式，可以方便地在任何时间点添加或删除任何服务。
*   系统控制是分布式的。 系统中不再有一个单点故障作为协调器。
*   当这种方法与其他几种方法结合在一起时，就可以获得各种好处。
*   当这种方法与事件来源结合在一起时，所有的事件都被存储起来，并且它支持事件回放。 因此，即使某些服务关闭，当服务再次在线时，事件存储仍然可以重放该事件，并且服务可以检查更新。
*   另一个优点是**命令查询职责隔离**(**CQRS**)。 如[第一章](01.html)、*揭穿微服务*中所示，我们可以应用此模式来分离读和写活动。 因此，任何服务都可以独立地向外扩展。 在应用程序读或写很重的情况下，这是非常有用的。

# 缺点

虽然这种方法解决了大部分的复杂性，但也带来了一些权衡:

*   异步编程有时处理起来很痛苦。 光看代码是无法解决问题的。 [第 2 章](02.html)，*为旅程作好准备*中所示的事件循环的透彻理解，是必须理解*异步编码*中的实际工作流程。
*   复杂性和集中的代码现在已经转移到各个服务中。 流控制现在被分解并分布到所有服务中。 这可能会在系统中引入冗余代码。

就像所有的事情一样，一刀切的方法在这里行不通。 已经出现了几种混合方法，它们利用了这两个过程。 现在让我们看看一些混合方法。 混合方法可以增加很多价值。

# 外部反应，内部协调

第一种混合模式促进了不同微服务和服务内部编排之间的响应式模式。 让我们考虑一个例子来理解这一点。 考虑我们的购物微服务例子。 每当有人购买一个产品，我们会检查库存，计算价格，处理付款，检查付款，添加推荐产品，等等。 每一个微服务都是不同的。 在这里，我们可以在产品库存服务、支付服务和推荐产品之间使用反应式方法，在结帐服务、处理支付和分发产品之间使用编制方法。 集合服务根据所有这三个服务的结果生成一个事件，然后可以生成这些事件。 有几个优点和价值增加，例如:

*   大多数服务都是解耦的。 编排只在需要的时候才会出现。 应用程序的整体流程是分布式的。
*   拥有异步事件和基于事件的方法确保不会出现单点故障。 如果服务错过了事件，那么只要服务在线可用，就可以重播事件。

虽然有一些优势，但也有一些权衡:

*   如果服务是耦合的，那么它们很快就会成为单点故障。 它们不能独立伸缩。
*   同步处理会导致系统阻塞和资源占用，直到请求完全完成。

# 响应式协调器来驱动流

第二种方法引入了类似于响应式编排器的东西来驱动不同服务之间的流。 它更多地使用基于命令和事件的方法来控制整个生态系统的整体流程。 命令指示需要做的事情，事件是执行命令的结果。 响应式协调器接收请求并生成命令，然后将它们推入事件流。 已经为命令设置的各种微服务使用这些命令，执行一些处理，然后在命令成功执行并执行时抛出一个事件。 响应式协调器使用这些事件，并在必要时按编程方式对事件作出反应。 这种方法有几个附加的价值，例如:

*   服务是解耦; 尽管协调器和服务之间似乎存在耦合，但响应式方法和集中式事件流可以解决以前的大部分缺陷。
*   事件流或集中的事件总线确保微服务之间的异步编程。 事件可以按需重播。 没有单点故障。
*   整个流程可以集中在响应式协调器的一个地方。 所有这些集中的逻辑都可以保存在那里，任何地方都不会有任何重复的代码。

虽然这种方法有很多好处，但也会带来以下的权衡——协调者需要得到照顾。 如果协调器故障，整个系统都会受到影响。 协调器需要知道需要哪些命令来响应或执行预先设定的操作。

# 剧情简介

在介绍了所有的方法(纯反应、纯编配和两种不同的混合方法)之后，我们现在将介绍可以应用前面四种方法的各种用例。 现在我们将学习哪种方法适合于哪里。

# 当一个纯粹的反应性方法是一个完美的适合

在以下场景中，纯粹的反应性方法是一个完美的选择:

*   当应用程序中的大部分处理都可以异步完成时。 当您可以在应用程序中使用并行处理时，响应式体系结构模式非常适合处理应用程序的需求。
*   在每个服务中分散应用程序流是可管理的，而且不会成为令人头疼的问题。 对于监视和审计，可以使用相关 id(**UUID**、**GUID**、**CUID**)生成集中视图。
*   当需要快速部署应用程序并将其快速推向市场时，这是最重要的目标。 当微服务与响应式方法相结合时，它有助于增加解耦，最小化依赖，处理临时关闭情况，从而帮助产品更快地进入市场。

# 当纯粹的配器是一个完美的搭配

在以下场景中，纯编配方法是一个完美的选择:

*   当并行处理不能满足应用程序的需求时。 所有的步骤都必须用顺序处理完成，没有并行处理的机会。
*   如果应用程序需要集中的流控制。 不同的领域，如**银行业**和**ERP**都需要在一个地方查看端到端流，这是一个高优先级的需求。 如果有 100 个服务，每个服务都有自己的控制流，那么维护集中的流可能很快就会成为分布中的瓶颈。

# 当反应在外面，协调在里面是一个完美的搭配

在以下情况下，一种混合的方法，更具体地说是外部反应，内部协调，是一个完美的选择:

*   您的大部分处理都可以异步完成。 您的服务可以通过事件流彼此通信，并且您可以在系统中进行并行处理，也就是说，您可以根据您的系统通过事件流或命令传递数据。 例如，只要付款成功，一个微服务显示相关产品，一个微服务向卖家发送订单。
*   每个微服务中的去中心化流很容易管理，并且没有到处重复的代码。
*   将产品推向市场的速度是首要任务。
*   顺序步骤并不适用于系统，而是适用于服务。 只要顺序步骤不应用于整个系统。

# 当引入一个反应性协调者是完美的搭配

在以下场景中，引入响应式协调器是一个完美的解决方案:

*   根据正在处理的数据，应用程序的流程可以改变。 流可能有数百个微服务，应用程序需要临时关闭，一旦应用程序恢复在线，就可以重播事件。
*   系统中有几个需要同步处理的异步处理块。
*   它可以方便地发现服务。 服务可以在任何时候轻松伸缩。 移动整个服务很容易。

根据您的总体需求，您可以决定微服务体系结构中的任何一种策略。

# 在 Node.js 中响应

现在我们已经了解了响应式编程的概念以及响应式编程在微服务中的优势，现在让我们看看在 Node.js 中响应式编程的一些实际实现。 在本节中，我们将通过查看 Node.js 中响应式编程的实现来理解响应式编程的构建模块。

# Rx.js

这是最流行的库之一，它得到了积极的维护。 该库可用于大多数编程语言的不同形式，如**RxJava**，**RxJS**，**Rx。 Net**，**RxScala**，**RxClojure**，等等。 在撰写本文时，它上个月的下载量已超过 400 万次。 除此之外，还有大量的文档和在线支持。 我们将在大多数时候使用这个库，除非有需要。 你可以通过:[http://reactivex.io/](http://reactivex.io/)查看。 在撰写本文时，Rx.js 的稳定版本为**5.5.6**。 js 有很多操作符。 我们可以将 Rx.js 操作符用于各种事情，比如组合各种事情、在需要时应用条件、从承诺或事件创建新的可观察对象、错误处理、过滤数据、拥有发布者-订阅方模式、转换数据、请求-响应实用程序，等等。 让我们快速上手。 为了安装 RxJS，我们需要安装 Rx 包和 Node-Rx 绑定。 打开终端，拍摄`npm install rx node-rx --save`。 我们还需要一个模块，因为这个库必须支持 Node.js 作为构建系统。 在终端-`npm install @reactivex/rxjs --save`中点击此命令。 在本章中，我们将使用我们刚刚在[第 2 章](02.html)、*中创建的`Hello World`微服务框架，并将继续使用它。 下面是我们将在演示中看到的各种选项:*

| `forkjoin` | 当我们有一组可观察对象我们只需要最后一个值。 如果一个可观察对象从未完成，则不能使用此方法。 |
| `combineAll` | 它只是通过等待一个外部的可观察对象完成，然后自动应用`combineLatest`来平展/合并一个可观察对象中的可观察对象。 |
| `race` | 首先发出值的可观察对象将被使用。 |
| `retry` | 如果出现错误，按特定次数重试一个可观察序列。 |
| `debounce` | 忽略花费少于指定时间的发出值。 例如，如果我们将 debounce 设置为一秒，那么在一秒之前发出的任何值都将被忽略。 |
| `throttle` | 仅在经过由所提供的函数确定的持续时间时才发出值。 |

下面的示例对值进行节流，直到两秒:

```js
const source = Rx.Observable.interval(1000);
const example2 = source.throttle(val => Rx.Observable.interval(2000));
const subscribe2 = example2.subscribe(val => console.log(val));
```

下面的例子将在可观察对象上触发一个竞争条件:

```js
let example3=Rx.Observable.race(
 Rx.Observable.interval(2000)
            .mapTo("i am first obs"),
  Rx.Observable.of(1000)
            .mapTo("i am second"),
 Rx.Observable.interval(1500)
            .mapTo("i am third")
  )
let subscribe3=example3.
                  subscribe(val=>console.log(val));
```

您可以在源文件夹的`using_rxjs`中查看源代码。 上表中所有操作符的示例可以在`rx_combinations.ts`、`rx_error_handing.ts`和`rx_filtering.ts`中找到。 API 的完整列表可以在[http://reactivex.io/rxjs/](http://reactivex.io/rxjs/)找到。

# Bacon.js

培根.js 是一个小巧的函数式响应式编程库。 当与 Node.js 集成时，您可以轻松地将意大利面条般的代码转换为干净的、声明性的代码。 它的月下载量超过 2.9 万次。 在撰写本文时，可用的版本是**1.0.0**。 让我们快速上手。 为了安装 Bacon.js，我们需要安装 Bacon.js 和它的类型。 打开终端，拍摄`npm install baconjs --save`和`npm install @types/baconjs --only=dev`。 现在，让我们看一个基本的示例，在这个示例中，我们将看到代码看起来有多干净。 我们有一个 JSON 对象，其中一些产品用数字`1`对应`mobile`，用`2`对应`tv`，以此类推。 我们创建一个服务来返回产品名称，如果产品不存在，它应该返回`Not found`。 以下是服务代码:

```js
baconService(productId: number){
  return Bacon.constant(this.productMap[productId])
}
```

控制器代码如下:

```js
@Get('/:productId')
async get(@Req() req: Request,@Res() res: Response,@Param("productId") productId: number) {
  let resp: any;
  this.baconService.baconService(productId)
    .flatMap((x) => {
      return x == null || undefined ? "No Product Found" : x;
    })
    .onValue((o: string) => {
      resp = o;
    })
  return resp;
} 
```

您可以在源文件夹的`using_baconjs`处跟随源代码。 api 的完整列表可以在[https://baconjs.github.io/api.html](https://baconjs.github.io/api.html)找到。

# HighLand.js

这更像是一个泛型函数库，它构建在 Node.js 流之上，因此允许它处理异步和同步代码。 **HighLand.js**最好的特点之一是它处理反压力的方式。 它有一个内置的暂停和缓冲功能，也就是说，当客户端不能处理任何更多的数据时，流将被暂停，直到它准备好，如果源不能暂停，那么它将维护一个临时缓冲区，直到正常操作可以恢复。 是时候用一个实际的例子来实践一下了。 让我们从表达主题转向阅读主题。 我们将看到 Node.js I/O 操作的强大，它可以并行执行。 射击一个终端并击中`npm install highland --save`。

继续我们之前的框架，用下面的代码创建`index.ts`，它基本上读取三个文件并打印它们的内容:

```js
import * as highland from "highland";
import { Stream } from "stream";
import * as fs from "fs";

var readFile = highland.wrapCallback(fs.readFile);
console.log("started at", new Date());

var filenames = highland(['file1.txt', 'file2.txt', 'file3.txt']);
filenames
  .map(readFile)
  .parallel(10) //reads up to 10 times at a time
  .errors((err: any, rethrow: any) => {
    console.log(err);
    rethrow();
  })
  .each((x: Stream) => {
    console.log("---");
    console.log(x.toString());
    console.log("---");
  });
console.log("finished at", new Date());
```

编译文件，保持三个`.txt`文件平行于`package.json`，并运行`node`文件。 内容将被阅读。 您可以在源代码的`src`文件夹中跟随`using_highlandjs`项目。 完整的 api 列表可以在[http://highlandjs.org/](http://highlandjs.org/)上找到。

# 关键的外卖

现在我们已经看到了所有三个库，我们将总结以下关键点和显著特征:

|  | **Rx.js** | **培根** | **Highland.js** |
| **文档** | 很好的文档，非常成熟的 api 和许多选项，在其他语言中有扩展。 | 更少的 Node.js 示例，很棒的 API 文档，对 Node.js 的本地支持。 | 非常少的文档和帮助器方法，不断发展。 |
| **反压** | 实现的。 | 不受支持的。 | 最好的实现。 |
| **社区** | 被 Netflix 和微软等大公司使用。 在所有其他语言中都有类似的概念，更像 Java，学习曲线。 | 比 Rx.js 小，学习曲线比 Rx.js 小。 | 最不活跃的社区，必须直接挖掘代码库。 |
| **license** | Apache 2.0 | 用 | Apache 2.0 |

# 总结

在本章中，我们学习了反应性宣言。 我们将反应性原则融入到微服务中。 我们学习了如何在 Node.js 中应用响应式编程。 我们了解了设计微服务架构的可能方法，了解了它的优点和缺点，并看到了一些实际场景，以找出在哪些情况下我们可以应用这些模式。 我们看到了编排过程、反应过程和混合方法的两种特殊情况。

在下一章中，我们将开始开发我们的购物车微服务。 我们将设计我们的微服务架构，编写一些微服务，并部署它们。 我们将看到如何将代码组织成合适的结构。****