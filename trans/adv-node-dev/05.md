# 带有套接字的实时网络应用

在本章中，您将学习 Socket.io 和 WebSockets，它们支持服务器和客户端之间的双向通信。这意味着我们不仅要设置一个节点服务器，还要设置一个客户端。这个客户端可以是一个网络应用程序、一个 iPhone 应用程序或一个安卓应用程序。对于这本书，客户端将是一个网络应用程序。这意味着我们将把两者连接起来，让数据从浏览器无缝地流向服务器，从服务器流向浏览器。

现在，我们的 todo app 数据只能单向流动，客户端必须初始化请求。借助 Socket.io，我们将能够即时来回发送数据。这意味着对于实时应用程序，如电子邮件应用程序、点餐应用程序或聊天应用程序，服务器不需要等待客户端请求信息；服务器可以说，“*嘿，我刚得到一个你可能想给用户看的东西，所以在这里！”*这将打开一个充满可能性的世界，我们将从找出如何将 Socket.io 集成到 Node 应用程序开始。让我们开始吧！

# 创建新的 web 应用程序项目

在向 web 应用程序添加套接字之前，您需要一个 web 应用程序来添加它们，这正是我们将在本节中创建的。我们将制作一个基本的快递应用程序，我们将在 GitHub 上发布。然后，我们将它部署到 Heroku，这样我们就可以在浏览器中实时查看它。

现在，这个过程的第一步是创建一个目录。我们将一起做一些事情，让我们都朝着正确的方向前进。从桌面开始这个过程的第一步是运行`mkdir`为这个项目新建一个目录；我打算叫它`node-chat-app`。

然后，我们可以使用`cd`导航到该目录，我们可以运行一些命令:

```
mkdir node-chat-app
cd node-chat-app
```

首先，`npm init`。与本书中的所有项目一样，我们将利用 npm，因此我们将运行以下命令:

```
npm init
```

![](images/3dcad9af-d069-4002-b47d-e98cd23bfa61.png)

然后，我们将使用*e**enter*键为每个选项使用默认值:

![](images/dabdb017-99da-4bf2-800a-b2519d8a7417.png)

完成后，我们可以输入`yes`，现在我们有了一个`package.json`文件。在我们进入 Atom 之前，我们将运行以下命令来初始化一个新的 Git 存储库:

```
git init
```

我们将使用 Git 对这个项目进行版本控制，我们还将使用 Git 来推送到 GitHub 和 Heroku。有了这个，我可以使用`clear`命令清除终端输出，我们就可以进入 Atom 了。我们将从打开文件夹并设置我们的基本应用程序结构开始。

# 设置我们的基本应用程序结构

为了建立基本的应用程序结构，我将打开我们刚刚在桌面上创建的文件夹，名为`node-chat-app`:

![](images/4bc28905-c257-4137-82d4-d9090f43789b.png)

在这个文件夹中，我们将从创建几个目录开始。现在，与前面章节中的其他应用程序不同，聊天应用程序将有一个前端，这意味着我们将编写一些 HTML。

我们还将添加一些样式并编写一些在浏览器中运行的 JavaScript 代码，而不是在服务器上运行。为此，我们将有两个文件夹:

*   一个将被称为`server`，它将存储我们的 Node.js 代码
*   另一个将被称为`public`，它将存储我们的样式、我们的 HTML 文件和我们的客户端 JavaScript

现在，在`server`内部，就像我们对 todo API 做的那样，我们将有一个`server.js`文件，它将是我们的 Node 应用程序的根:

![](images/bbbb2aaf-1b53-4a38-8063-01926870b587.png)

这个文件将做一些事情，比如创建一个新的快递应用程序，将公共目录配置为快递服务的静态文件夹，并调用`app.listen`启动服务器。

在`public`中，我们将为这个部分做的是创建一个名为`index.html`的文件:

![](images/f5682799-13ac-4176-8ec6-50e206eaf810.png)

`index.html`文件将是当有人访问该应用时我们提供的标记页面。现在，我们将制作一个非常简单的程序，只需在屏幕上打印一条消息，这样我们就可以确认它是否正常运行。在下一节中，我们将讨论如何在客户机上集成 Socket.io。

# 为文档类型设置 index.html 文件

不过现在，在我们的`index.html`文件中，我们将提供`DOCTYPE`，这样浏览器就知道我们想要使用哪个版本的 HTML。我们告诉它使用引用 HTML5 的 HTML。接下来，我们将打开和关闭我们的`html`标签:

```
<!DOCTYPE html>
<html>

</html>
```

这个标签将让我们提供`head`和`body`标签，这正是我们让事情正常运行所需要的:

*   首先是`head`。在`head`里面，我们可以提供各种配置标签。我们现在只使用一个`meta`，这样我们就可以告诉浏览器我们想要使用哪个`charset`。在`meta`标签中，我们将提供`charset`属性，将其设置为引号内的`utf-8`:

```
      <!DOCTYPE html>
      <html>
      <head>
 <meta charset="utf-8">
 </head>
      </html>
```

*   接下来，我们将在`html`中提供`body`标签。这包含了我们想要实际渲染到屏幕上的 HTML，我们要为这个做的是渲染一个`p`标签，这是一个段落，我们会有一些简单的文本，像`Welcome to the chat app`:

```
      <!DOCTYPE html>
      <html>
      <head>
        <meta charset="utf-8">
      </head>
      <body>
 <p>Welcome to the chat app</p>
 </body>
      </html>
```

这就是目前将要出现的一切。现在，我们可以移出`html`文件，回到`server`文件。

# 为公共目录设置 server.js 文件

在我们的`server`文件中，我们想要设置这个服务器来提供`public`文件夹。现在，在这种情况下，`server.js`文件不在项目的根目录下，这意味着我们必须从`server`到`node-chat-app`建立一个目录。然后，我们要进入`public`文件夹。这将使得设置 Express 中间件有点困难。我们要做的是看一看一个内置的节点模块，它使转换路径变得非常容易。

现在，为了向您展示我所说的内容，让我们继续使用两个`console.log`调用:

```
console.log();
console.log();
```

第一个`console.log`调用会告诉我们以前是怎么做的，第二个调用会告诉我们更好的方法。

在第一次`console.log`呼叫中，我们将提供与第一个 Express 应用程序相同的路径。我们使用`__dirname`来引用当前目录，在本例中是`server`目录，因为文件在`server`文件夹中。然后，我们把它串联起来，`/public`。现在，在这种情况下，我们在`server`文件夹中没有`public`文件夹；`public`文件夹和`server`文件夹处于完全相同的级别，这意味着我们需要使用`..`来查找一个目录，然后我们需要进入`public`:

```
console.log(__dirname + '/../public');
console.log();
```

这是旧的做事方式，如果我们从终端运行这个，我们可以看到为什么它看起来有点奇怪。我要跑`server/server.js`:

```
nodemon server/server.js
```

我们得到的是这个路径，如下图所示:

![](images/27dff985-7df2-4295-a4ec-776fadd70a3b.png)

我们进入`Users/Andrew/Desktop/`项目文件夹，这是预期的，然后我们进入`server`，从`server`出来，进入`public`——这是绝对没有必要的。我们想做的是直接从`project`文件夹进入`public`，保持一个干净的、跨操作系统兼容的路径。为此，我们将使用名为`path`的节点附带的模块。

# 连接方法

现在，让我们看看`path`的文档，因为`path`有很多我们在这一节中不会用到的方法。我们将前往[nodejs.org](https://nodejs.org/en/)，在那里我们可以找到“文档”选项卡。我们将转到文档页面，然后转到应用编程接口参考页面:

![](images/f2a281b3-95b3-48da-9a15-8d521be5707e.png)

这是我们所有可用模块的列表。我们正在使用路径模块:

![](images/f0dbc7a1-cd59-472b-b676-d0b85daa536b.png)

在路径内部，我们将使用的方法是`join`，您可以在前面的截图中看到。如果你点击这个方法，你可以去看看`join`的工作原理:

![](images/5bd530c8-7f9f-497f-adc5-10780bf142e4.png)

`join`方法获取您的部分路径并将它们连接在一起，这意味着前面截图中显示的示例导致了更简单的路径。在这个例子中，我们可以看到我们从`foo`开始。然后我们进入`bar`，它也出现了；然后我们进入`baz/asdf`，它确实出现了。下一部分是有趣的部分:我们进入`quux`目录，然后我们使用`..`出去，你可以看到结果路径没有显示我们进出，就像我们的路径在终端里面一样；相反，它将此解析为最终路径，在那里`quux`目录看不到。

我们将使用完全相同的方法来清理我们的路径。在 Atom 内部，我们可以通过创建一个名为`path`的常数并要求它来加载`path`模块:

```
const path = require('path');
```

记住，这个不需要安装:是内置模块，不用`npm`就可以访问。接下来，我们将制作一个名为`publicPath`的变量。我会把它变成一个常量变量，因为我们会对它做任何改变，我们称之为`path.join`:

```
const path = require('path');
const publicPath = path.join();
```

我们马上将一些论点传入`path.join`。不过，在此之前，我要给`console.log(publicPath)`打个电话:

```
const path = require('path');
const publicPath = path.join();

console.log(__dirname + '/../public');
console.log(publicPath);
```

现在，在`path.join`里面，我们要做的是走两条路，`__dirname`和`'/../public'`，把它们作为单独的参数传进去。我们仍然想从`dirname`目录的`server`文件夹开始。然后，作为第二个参数，我们将指定引号内的相对路径。我们将使用`..`离开目录，然后使用正斜杠进入`public`文件夹:

```
const path = require('path');
const publicPath = path.join(__dirname, '../public');
```

我将保存`server`文件，现在我们应该能够回到终端并看到我们的新路径——它是这样的:

![](images/99ebfc25-831e-4d61-9f80-4368ac0118f1.png)

而不是先进入`server`再出去，直接进入`public`目录，比较理想。这是我们想要提供给 Express 静态中间件的路径。

现在我们已经有了这个`public`路径变量，让我们在本地设置 Express。在此之前，我们将使用`npm i`安装它。模块名为`express`，我们将使用最新版本`@4.16.3`，带有`--save`标志:

```
npm i express@4.16.3 --save
```

我们将运行安装程序，然后我们可以继续并在`server.js`中实际使用它。在`package.json`中，我们现在将它放在依赖对象中。

# 配置基本服务器设置

有了 Express 安装程序，您将创建一个全新的 Express 应用程序，并配置 Express 静态中间件，就像我们之前为服务`public`文件夹所做的那样。最后，你将在港口`3000`呼叫`app.listen`。您将提供其中一个小回调函数来打印消息到终端，例如`server is up on port 3000`。

一旦您创建了服务器，您将在终端内启动它，并前往浏览器内的`localhost:3000`。如果我们现在去那里，我们会得到一个错误，因为没有服务器在那个端口上运行。您应该能够刷新此页面，并看到我们在`index.html`内的段落标记中键入的小消息。

我要做的第一件事是在`server.js`内部，通过创建一个名为`express`的常量并要求我们刚刚安装的库来加载 Express:

```
const path = require('path');
const express = require('express');
```

接下来，您需要创建一个`app`变量，我们可以在其中配置我们的 Express 应用程序。我将创建一个名为`app`的变量，并将其设置为对`express`的调用:

```
const path = require('path');
const express = require('express');

const publicPath = path.join(_dirname, '../public');
var app = express();
```

Remember, we don't configure Express by passing in arguments; instead, we configure Express by calling methods on `app` to create routes, add middleware, or start up the server.

首先，我们将调用`app.use`来配置我们的 Express 静态中间件。这将提供`public`文件夹:

```
const path = require('path');
const express = require('express');

const publicPath = path.join(_dirname, '../public');
var app = express();

app.use();
```

你需要做的是调用`express.static`并在路径中通过。我们创建了一个`publicPath`变量，它准确地存储了我们需要的路径:

```
app.use(express.static(publicPath));
```

最后要做的就是调用`app.listen`。这将在端口`3000`上启动服务器，我们将提供一个回调函数作为第二个参数，以便在服务器启动后向终端打印一条小消息。

我用`console.log`打印`Server is up on port 3000`:

```
app.listen(3000, () => {
  console.log('Server is up on port 3000');
});
```

有了这些，我们现在可以在终端内启动服务器，并确保我们的`index.html`文件显示在浏览器中。我将继续使用`clear`命令清除终端输出，然后使用`nodemon`运行服务器，使用以下命令:

```
nodemon server/server.js
```

![](images/9bb3fd9a-ba44-4ffe-b697-a53787f26ac9.png)

在这里，我们得到了我们的小信息。在浏览器中，如果我给东西一个刷新，我们得到我们的标记，`Welcome to the chat app`，如下图截图所示:

![](images/702468dc-5328-47a3-a420-2ea2ee480034.png)

我们现在已经建立了一个基本的服务器，这意味着在下一节中，我们实际上可以在客户端和后端都添加 Socket.io。

# 设置 gitignore 文件

现在，在我们开始在 GitHub 和 Heroku 上获取东西之前，我们将首先在 Atom 中设置一些东西。我们需要建立一个`.gitignore`文件，我们将在项目的根目录中提供这个文件。

Inside `.gitignore`, the only thing we'll be ignoring is the `node_modules` folder. We do not want to commit any of this code to our repo, because it can be generated using `npm install` and it's subject to change. It's a real pain to manage that sort of thing, and it is not recommended that you commit it.

我们接下来要做的是为 Heroku 配置一些东西。首先，我们必须使用`process.env.PORT`环境变量。我将在`publicPath`变量旁边创建一个名为`port`的常数，将其设置为`process.env.PORT`或`3000`。我们将在本地使用它:

```
const publicPath = path.join(__dirname, '../public');
const port = process.env.PORT || 3000;
```

现在，我们可以在`app.listen`中提供`port`，并且我们可以通过将我们的常规字符串更改为模板字符串来获得`Server is up on`，从而在下面的消息中提供它。我来注入`port`变量值:

```
app.listen(port, () => {
  console.log(`Server is up on ${port}`);
});
```

现在我们已经准备好了，为了让我们的应用为 Heroku 设置，我们需要做的下一件事是更新`package.json`文件，添加一个`start`脚本，并指定我们想要使用的 Node 版本。在`scripts`下，我会添加一个`start`脚本，告诉 Heroku 如何启动应用程序。为了启动应用，你必须运行`node`命令。你必须进入`server`目录，启动它的文件是`server.js`:

```
"scripts": {
  "start": "node server/server.js",
  "test": "echo \"Error: no test specified\" && exit 1"
},
```

我们还将指定`engines`，这是我们以前做过的。`engines`，如您所知，让您告诉 Heroku 使用哪个版本的 Node:

```
"engines": {

},
```

这一点非常重要，因为我们正在利用仅在最新版本的 Node 中提供的一些功能。在`engines`中，我将提供与我之前使用的完全相同的键值对，将`node`设置为等于`9.3.0`:

```
"engines": {
  "node": "9.3.0"
},
```

如果您使用的是不同版本的 Node，您可以提供它来代替我在这里添加的版本。

# 对当前未提交的文件进行提交

现在我们已经准备好了，您可以提交所有当前未提交的文件。然后，您将进入 GitHub 并创建一个 GitHub 存储库，在那里您将向上推送您的本地代码。确保代码真的上了 GitHub 您可以通过刷新 GitHub repo 页面来做到这一点。你应该在报告上看到你的目录结构。

接下来您需要做的是创建一个 Heroku 应用程序并部署到它上面。一旦您的应用程序部署完毕，您应该能够访问浏览器上的应用程序网址。你应该看到和我们在`localhost:3000`中看到的完全一样的信息。`Welcome to the chat app`消息应该打印出来，但是你应该在真正的英雄库应用上，而不是在`localhost:3000`上。

现在，我们已经在项目内部进行了所有必要的更改。我们已经配置了`port`变量，并且已经设置了我们的`scripts`和`engines`，因此您不必再进行任何代码更改；你只需要在浏览器和终端中施展你的魔法就可以了。

第一步是创建一个新的 GitHub 存储库。我们需要一个地方来提升我们的代码。我们可以前往[github.com](https://github.com/)，点击那个绿色的大“新建存储库”按钮，新建一个。我会打电话给我的知识库`node-course-2-chat-app`。我将公开并创建它:

![](images/87bf2c14-1f24-4ab5-a821-3303b4b45b5f.png)

现在我们已经创建了存储库，我们有了一个可以使用的命令列表。我们有一个想要推送的现有存储库，因此我们可以复制这些行:

![](images/dcd2bf63-eb91-40ab-9345-388086661b42.png)

在终端中，在我们真正推送任何东西之前，我们需要进行提交。我会关闭`nodemon`并运行`git status`命令:

![](images/14707ad1-5052-4aa0-a9c6-a1748b736135.png)

这里，你看我们有我们期望的文件，我们有`public`和`server`文件夹，我们有`.gitignore`，我们有`package.json`。然而，`node_modules`却不见踪影。然后，您需要使用`git add .`将这些未跟踪的文件添加到下一个提交中。

如果您再次运行`git status`命令，您可以看到一切看起来都很好:

![](images/3283a9cf-163b-497c-94ee-29e67d7b5699.png)

我们要提交四个更改:四个新文件。我将运行带有`-m`标志的`git commit`来指定消息。`-a`标志不是必需的，因为所有的文件都已经添加了。在报价中，`Init commit`将完成工作:

```
git commit -m 'Init commit'
```

一旦你完成了提交，你就可以通过运行他们给你的两行代码把它推送到 GitHub。我将运行这两个:

```
git remote add origin https://github.com/garygreig/node-course-2-chat-app.git 
git push -u origin master
```

如图所示，它现在在 GitHub 上。我们可以通过刷新页面来确认这一点，我们看到的不是说明，而是我们创建的文件:

![](images/bcdd497d-6a76-4a67-ac36-6221823c42f9.png)

下一件也是最后一件要做的事情是在 Heroku 上获取该应用程序。你实际上不需要去 Heroku 网络应用程序就能完成；我们可以在终端内运行`heroku create`:

![](images/0fd758d2-3258-4a0d-a20b-9ca567cb4ef6.png)

让我们继续创建应用程序。我们可以使用以下命令来部署应用程序。我将继续运行它:

```
git push heroku master
```

这将把我的本地代码推送到 Heroku。Heroku 将看到新代码被推送，因此它将继续部署它:

![](images/568ef626-d985-4ab6-8f63-36485be6b3e7.png)

一旦启动，我们可以使用`heroku open`命令在浏览器上打开应用网址。或者，您可以随时从终端获取网址。我将复制上一张截图中显示的网址，进入浏览器，并粘贴它:

![](images/2f19e93c-32d4-47f5-bc74-ca3e10e809e6.png)

如前面的截图所示，我们应该看到我们的应用。欢迎来到显示在屏幕上的聊天应用程序，有了这个，我们就完成了！我们有一个基本的 Express 服务器，我们有一个后端和一个前端，它在 GitHub 上，它在 Heroku 上！

我们已经准备好进入下一部分，实际上我们将开始集成 Socket.io。

# 将 Socket.io 添加到应用程序

现在您已经启动并运行了一个基本的快速应用程序，在本节中，您将配置您的服务器以允许传入的网络套接字连接。这意味着服务器将能够接受连接，我们将设置客户端进行连接。然后，我们将有一个持久的连接，我们可以来回发送数据，无论是从服务器到客户端的数据，还是从客户端到服务器的数据。这就是网络套接字的妙处——你可以双向发送数据。

现在，为了设置网络套接字，我们将使用一个名为 Socket.io 的库。就像 Express 使设置 HTTP 服务器变得非常容易一样，Socket.io 使设置支持网络套接字的服务器和创建与服务器通信的前端变得非常简单。Socket.io 有一个后端和前端库；我们将使用这两者来设置网络套接字。

# 设置套接字

首先，在终端内部，让我们继续使用`npm i`安装最新版本的 Socket.io。模块名称为`socket.io`，编写本报告时最新版本为`@2.0.4`。我们将使用`--save`开发标志来更新`package.json`文件:

```
npm i socket.io@2.0.4 --save
```

一旦这一切就绪，我们可以继续对我们的`server`文件进行一些更改。首先，我们将载入图书馆。我将创建一个名为`socketIO`的常量，并将其设置为与`socket.io`库的`require`语句相等:

```
const path = require('path');
const express = require('express');
const socketIO = require('socket.io');
```

有了这些，我们现在需要将 Socket.io 集成到我们现有的 web 服务器中。目前，我们使用 Express 来制作我们的网络服务器。我们创建一个新的 Express 应用程序，我们配置我们的中间件，我们称之为`app.listen`:

```
var app = express();

app.use(express.static(publicPath));

app.listen(port, () => {
  console.log(`Server is up on ${port}`);
});
```

现在，在幕后，Express 实际上正在使用一个名为`http`的内置 Node 模块来创建这个服务器。我们需要自己使用`http`。我们需要配置快递与`http`合作。然后，也只有到那时，我们才能添加 Socket.io 支持。

# 使用 http 库创建服务器

首先，我们将载入`http`模块。所以，让我们做一个名为`http`的常量，它是一个内置的 Node 模块，所以不需要安装。我们可以简单地进入`require('http')`，就像这样:

```
const path = require('path');
const http = require('http');
const express = require('express');
const socketIO = require('socket.io');
```

从这里，我们将使用这个`http`库创建一个服务器。就在我们的`app`变量下面，让我们制作一个名为`server`的变量。我们就叫`http.createServer`:

```
const path = require('path');
const http = require('http');
const express = require('express');
const socketIO = require('socket.io');

const publicPath = path.join(_dirname, '../public');
const port = process.env.PORT || 3000;
var app = express();
var server = http.createServer()
```

现在，你可能不知道，但你实际上已经在幕后使用`createServer`方法了。当你在你的快速应用程序上调用`app.listen`时，它实际上调用了这个完全相同的方法，在应用程序中作为`createServer`的参数传递。`createServer`方法取一个函数。这个函数看起来非常类似于我们的一个 Express 回调，它通过一个请求和一个响应被调用:

```
var server = http.createServer((req, res) => {

})
```

现在，正如我提到的，`http`实际上是用于快递的幕后。它集成得如此之多，以至于您实际上只需提供`app`作为参数，我们就完成了:

```
var server = http.createServer(app);
```

在我们集成 Socket.io 之前，让我们先总结一下这个变化。我们将使用 HTTP 服务器，而不是 Express 服务器，所以我们将调用`server.listen`而不是调用`app.listen`:

```
server.listen(port, () => {
  console.log(`Server is up on ${port}`);
});
```

再说一次，没有必要改变`server.listen`方法中传递的参数——它们完全相同，并且彼此非常接近，因此`server.listen`参数与 Express `app.listen`参数相同。

既然我们已经做好了这些，我们实际上并没有改变任何应用程序的功能。我们的服务器仍将在端口`3000`上工作，但我们仍无法访问 Socket.io。在终端中，我可以通过清除终端输出并使用`nodemon`命令启动我们的服务器来证明这一点:

```
nodemon server/server.js
```

然后，我将在浏览器网址中加载`localhost:3000`，看看我得到了什么:

![](images/d0d7f5b6-0533-4639-a599-8444ed9366bc.png)

如前面的截图所示，我们得到了我们的 HTML，欢迎使用聊天应用程序出现了。这意味着即使我们现在使用的是 HTTP 服务器，我们的应用程序仍然在工作。

# 将服务器配置为使用套接字

接下来我们要做的是将服务器配置为使用 socket . io——这就是我们做出这一更改的全部原因。在`server`变量旁边，我们将制作一个名为`io`的变量。

我们将它设置为对`socket.io`的调用，并传入`server`，我们希望将其用于我们的网络套接字:

```
var server = http.createServer(app);
var io = socketIO(server);
```

现在我们可以通过`server`变量访问该服务器，所以我们将把它作为第一个也是唯一一个参数传入。现在，我们得到的是我们的网络套接字服务器。在这里，我们可以做任何我们想做的事情，比如发射或收听事件。这就是我们将如何在服务器和客户端之间进行通信，我们将在本节的后面部分详细讨论这一点。

有了这些，我们的服务器就可以运行了；我们准备接受新的连接。问题是我们没有任何关系可以接受。当我们加载网页时，我们什么也没做。我们实际上并没有连接到服务器。我们需要手动运行一些 JavaScript 代码来启动这个连接过程。

现在，当我们将 Socket.io 与我们的服务器集成时，我们实际上获得了一些很酷的东西。首先，我们获得了接受传入连接的路由，这意味着我们现在可以接受网络套接字连接。此外，我们还访问了一个 JavaScript 库，这使得在客户端使用 Socket.io 变得非常容易。该库可通过以下路径获得:`localhost:3000/socket.io/socket.io.js`。如果您在浏览器中加载这个 JavaScript 文件，您可以看到它只是一个很长的 JavaScript 库:

![](images/99e7d630-174a-4fa3-a6ab-376abd26388d.png)

这包含了我们在客户端建立连接和传输数据所需的所有代码，无论是从服务器到客户端还是客户端到服务器。

为了从我们的 HTML 文件中建立连接，我们要做的是将它载入。我会回到`localhost:3000`。现在，我们可以进入 Atom，打开`index.html`，在`body`标签的底部附近，我们将添加一个`script`标签来加载到我们刚刚在浏览器中找到的文件中。

首先，我们将制作`script`标签本身，打开和关闭它，为了加载一个外部文件，我们将使用`src`属性来提供路径:

```
<body>
  <p>Welcome to the chat app</p>

  <script src=""></script>
</body>
```

这条路径是相对于我们的服务器的。将会是`/socket.io/socket.io.js`，这和我们之前在浏览器中输入的完全一样:

```
<script src="/socket.io/socket.io.js"></script>
```

通过添加`script`标签，我们现在正在加载库。在浏览器上，得益于`socket`库，我们可以使用各种可用的方法。其中一个方法是让我们发起一个连接请求，这正是我们在下一行要做的。让我们添加第二个`script`标签。这一次，我们不加载外部脚本，而是直接在行中编写一些 JavaScript:

```
<script src="/socket.io/socket.io.js"></script>
<script>

</script>
```

我们可以添加任何我们喜欢的 JavaScript，这个 JavaScript 将在 Socket.io 库加载后立即运行。稍后，我们将把它分解成自己的文件——但目前，我们可以简单地将 JavaScript 代码放在 HTML 文件中。我们要叫`io`:

```
<script src="/socket.io/socket.io.js"></script>
<script>
  io();
</script>
```

`io`是我们可用的方法，因为我们在这个库中加载了。它不是浏览器本地的，当我们调用它时，我们实际上是在发起请求。我们从客户端向服务器发出请求，要求打开一个网络套接字并保持该连接打开。现在，我们从`io`得到的东西真的很重要；我们将把它保存在一个名为`socket`的变量中，就像这样:

```
<script src="/socket.io/socket.io.js"></script>
<script>
  var socket = io();
</script>
```

这创建了我们的连接，并将套接字存储在一个变量中。这个变量对沟通至关重要；这正是我们监听来自服务器的数据并将数据发送到服务器所需要的。现在我们已经准备好了，让我们继续保存我们的 HTML 文件。我们将进入浏览器，打开 Chrome 开发工具。

Now regardless of what browser you use, whether it's IE, Safari, Firefox, or Chrome, you'll have access to a set of developer tools, which makes it really easy to debug and see what's going on behind the scenes in your web page. We'll be using the Chrome Developer Tools here to do a little debugging, I'd highly recommend using Chrome for the course just so you can follow along exactly.

要打开开发人员工具，我们转到设置|更多工具|开发人员工具。您也可以使用特定于您的操作系统的键盘快捷键。当您打开开发人员工具时，您将会看到大量的选项，如下所示:

![](images/72f77d05-d85e-479b-beb7-f6b57fa68309.png)

如果你以前从未使用过 Chrome 开发工具，你很可能会被带到元素面板。我们现在要使用的面板是网络面板。

“网络”面板跟踪网页发出的所有请求。因此，如果我请求一个 JavaScript 文件，我会在一个漂亮的列表中看到它，如前面的截图所示。

我们必须刷新页面才能看到网络请求列表；就在这里，我们有五个:

![](images/ab69f98e-f2d1-4a7a-80a2-93731e25162a.png)

最上面的网络请求是第一个发出的，最下面的是最后一个发出的。第一个是`localhost:3000`页面，是加载`Welcome to the chat app`的 HTML 文件。第二个是我们在浏览器上看到的那个 JavaScript 文件，它给了我们库，让我们可以调用那个`io`方法来启动连接过程。接下来的四个都与启动和维护该连接相关。有了这些，我们现在在客户机和服务器之间有了实时连接，我们可以开始交流任何我们想交流的东西。

# 客户端和服务器之间的通信

现在，交流可以是任何事情。在这种情况下，它以事件的形式出现。客户端和服务器都可以发出事件，客户端和服务器都可以监听事件。让我们来谈谈电子邮件应用程序中可能发生的一个事件。

在电子邮件应用程序中，当新邮件进来时，服务器可能会发出一个名为`newEmail`的事件。然后，客户端将监听该事件。当它触发时，它将获得`newEmail`数据，并将电子邮件渲染到其他邮件下方的屏幕上。同样的事情也可能以另一种方式发生:也许客户想创建一封新的电子邮件并将其发送给其他人。它会询问这个人的电子邮件地址和消息的内容，然后它会在客户机上发出一个事件，服务器会监听这个事件。因此，整个服务器/客户端关系完全是通过这些事件运行的。

现在，我们将在本章中为我们的特定应用程序创建自定义事件；但是现在，我们将看几个默认的内置功能，让您跟踪新用户和断开用户。这意味着当用户加入我们的应用程序时，我们可以做一些类似问候用户的事情。

# io.on 方法

为了在 Atom 内部玩这个，在`server.js`中，我们将在`io`上调用一个名为`io.on`的方法:

```
app.use(express.static(publicPath));

io.on();
```

`io.on`方法让你注册一个事件监听器。我们可以倾听一个特定的事件，并在事件发生时做一些事情。我们将要使用的一个内置事件——最流行的一个——叫做`connection`。这使您可以监听客户端到服务器的新连接，并在该连接到来时执行一些操作。为了做某事，你提供了一个回调函数作为第二个参数，这个回调函数将被一个`socket`调用:

```
io.on('connection', (socket) => {

});
```

这个`socket`参数与我们在`index.html`文件中访问的`socket`参数非常相似。这代表单个套接字，而不是连接到服务器的所有用户。现在，有了这个，我们可以做任何我们喜欢的事情。比如我可以用`console.log`打印一点消息，比如`New user connected`:

```
io.on('connection', (socket) => {
  console.log('New user connected');
});
```

每次用户连接到我们的应用程序，我们都会向控制台打印一条消息。我将继续保存`server.js`文件，移动到终端，您将看到消息实际上已经存在:

![](images/d65ffe25-41a2-4158-b4ac-3590bf86d903.png)

为了解释原因，我们需要了解关于网络套接字的一件事。正如我提到的，网络套接字是一种持久的技术，这意味着客户端和服务器都保持通信通道的开放，只要它们中的任何一方愿意。如果服务器关闭，客户端就没有选择，反之亦然。如果我关闭浏览器选项卡，服务器不能强制我保持连接打开。

现在，当连接断开客户端时，它仍然会尝试重新连接。当我们使用`nodemon`重新启动服务器时，大约有四分之一秒服务器关闭，客户端会注意到这一点。上面写着，“哇，哇，哇！服务器坏了！让我们尝试重新连接！”最终它会重新连接，这就是我们看到这条信息的原因。

继续关闭服务器，在客户端，您会看到网络请求正在 Chrome 开发工具中进行:

![](images/4a98cb77-75d4-493b-9afb-d48ac57f2cbd.png)

他们正在尝试重新连接到服务器，您可以看到他们失败了，因为服务器没有启动。现在，回到终端，重新启动服务器，如下所示:

![](images/05a56f3d-7382-46f4-86c3-3ebe0df21368.png)

在客户端内部，我们会再次尝试重新连接。我们将从服务器上获得成功的结果，然后，我们回来了！就像这样:

![](images/73e49a7b-0326-40b2-86c4-130b7f59353e.png)

现在，当我们重新连接时，您可以看到我们再次收到消息，这就是为什么我们在第一次将其添加到`server.js`文件时看到了它。

# 在客户端添加连接事件

现在，连接事件也存在于客户端。这意味着在客户端，当我们成功连接到服务器时，我们可以做一些事情。可能不会马上发生；这可能需要一点时间。在 Atom 里面，我们可以在`index.html`里面添加这个事件，就在我们对`io`的调用下面。如图所示，我们称`socket.on`:

```
var socket = io();

socket.on
```

我们想听一个事件，这个事件和我们`server.js`文件中的有一点不同。不是`on('connection')`，而是`on('connect')`:

```
var socket = io();

socket.on('connect');
```

这里的`on`方法和我们在`server.js`中使用的方法完全一样。第一个参数是事件名称，第二个参数是回调函数。在这种情况下，我们无法访问`socket`参数，因为我们已经将其作为`socket`变量。

在这种情况下，我要做的就是用`console.log`打印一条小消息到控制台，`Connected to server`:

```
socket.on('connect', () => {
  console.log('Connected to server');
});
```

现在我们已经准备好了，我们可以进入浏览器，进入开发人员工具中的一个新选项卡。我们将加载控制台选项卡。控制台选项卡有点像节点内的终端。如果我们在客户端 JavaScript 代码中使用`console.log`，这些消息将会显示在那里。正如你在前面的截图中看到的，我们也有一些错误。这些错误发生在我们的服务器停机时，我正在向您展示它是如何重新连接的；但是如果我们刷新页面，正如您将要看到的那样，`Connected to server`会出现，如下所示:

![](images/b2c5a05b-8a60-4dbf-92b8-8a736595cd37.png)

一旦连接发生，客户端和服务器都会触发该事件。客户端打印`Connected to server`，服务器打印`New user connected`。

有了这些，我们现在已经在 Socket.io 中使用了事件系统。我们还没有设置自己的自定义事件，但是我们已经利用了一些内置事件。

# 断开事件

在这一节中，我们要讨论的最后一件事是`disconnect`事件，当连接断开时，它允许您在服务器和客户端上做一些事情。我们将在客户机上添加一个事件侦听器，并在服务器上做同样的事情。

在客户端，在我们的`connect`事件旁边，我们可以再次调用`socket.on`来收听新的事件。同样，这里事件的名称是一个内置事件的名称，因此只有当您正确键入它时，它才会起作用。这个叫做`disconnect`:

```
socket.on('disconnect');
```

每当连接断开时，`disconnect`事件就会触发。如果服务器宕机，客户端将能够做一些事情。就目前而言，某件事只是要记录一条消息，`console.log('Disconnected from server')`:

```
socket.on('disconnect', () => {
  console.log('Disconnected from server');
});
```

现在我们已经有了这个消息，我们实际上可以保存我们的`index.html`文件。转到浏览器，刷新浏览器以载入我们的新 JavaScript 文件。继续，让你的浏览器屏幕稍微小一点，这样我们就可以在终端的背景中看到它。

我将进入终端，通过关闭服务器来关闭连接，在浏览器内部，我们将`Disconnected from server`打印到屏幕上:

![](images/7b2c98db-b167-450b-9edd-2866e78baf95.png)

如果我在终端内重启我的服务器，你可以看到我们已经自动连接，如`Connected to server`打印到屏幕上:

![](images/8f0feac0-1f57-46ae-8260-c0053d06bb4c.png)

现在，服务器上存在完全相同的事件。我们可以监听断开连接的客户端，当他们离开时，我们可以做些什么。为了注册这个事件，你将进入`server.js`，在我们的回调中，你将调用`server.js`中的`socket.on`，就像我们在`index.html`文件中所做的那样。完全一样的签名。第一个参数是事件名称，`disconnect`。回调函数应该做一些简单的事情，比如打印`client disconnected`。

一旦你准备好了，我想让你做的是打开浏览器，打开终端，然后关闭浏览器标签。您应该会在服务器中看到打印的消息，无论您在这里键入了什么消息。打开另一个浏览器选项卡，关闭它，并确保您收到相同的消息。假设浏览器选项卡有一个打开的连接，则每次关闭浏览器选项卡时都会打印此消息。

现在，要做到这一点，您所需要做的就是复制与我们在`io.on`方法中使用的签名完全相同的签名。`socket.on`取两个参数:第一个是我们要听的事件名称，`disconnect`；第二个参数是事件触发时要运行的函数:

```
socket.on('disconnect', () => {

});
```

在这种情况下，我们要做的就是用`console.log`打印`User was disconnected`，就像这样:

```
socket.on('disconnect', () => {
  console.log('User was disconnected');
});
```

然后，我们将保存文件，这将自动重启我们的应用程序。切换到终端，然后切换到浏览器，这样您就可以在后台看到终端。我将打开一个新的选项卡，所以当我关闭这个当前打开的选项卡时，Chrome 浏览器不会完全关闭。打开连接关闭标签，如下图所示，在终端内部，我们得到`User was disconnected`:

![](images/fafaca7c-7953-45ac-abff-01d99d39c79f.png)

如果我打开一个新标签页，转到`localhost:3000`，那么`New user connected`打印。我一关闭它，`User was disconnected`就会打印到服务器的屏幕上。希望你开始明白为什么网络套接字如此令人敬畏——即时双向通信使得任何类型的实时应用程序都可以轻松构建。

现在，让我们用一个承诺来结束这个。我会关闭我们的服务器并运行`git status`。我们可以看到我们只有修改过的文件:

![](images/1b7ad71a-38da-450f-a53b-87b0991bae91.png)

因此，带有`-am`标志的`git commit`将完成工作。我们可以添加我们的消息，`Add connect and disconnect event handlers`:

```
git commit -am 'Add connect and disconnect event handlers'
```

我将使用`git push`命令进行提交并将其推送到 GitHub。

有了这些，我们就完了。在下一节中，我们将进入非常有趣的内容——您将学习如何发出和收听自定义事件。这意味着您可以将任何您喜欢的数据从服务器发送到客户端，反之亦然。

# 发出和收听自定义事件

在上一节中，您学习了如何收听这些内置事件，例如连接事件和断开事件。这些都很好，它们是一个很好的起点，但是在这一节中，我们要谈论的是发出和收听定制事件，这就是 Socket.io 变得非常有趣的地方。

当您能够发出和监听自定义事件时，您可以将任何您想要的东西从服务器发送到客户端，或者从客户端发送到服务器。现在，让我们快速浏览一下这个示例，我们将使用一个示例应用程序，它将是一个电子邮件应用程序:

![](images/2900ca06-4ada-4f9d-b008-d808ba8d2aaf.png)

左边是我们的服务器，它正在启动一个 Socket.io 网络服务器。在右边，我们有我们的电子邮件应用程序，它显示了我们当前所有电子邮件的列表。现在，我们的应用程序可能需要的一个自定义事件是`newEmail`事件:

![](images/e853b6ec-58a3-476c-b1ab-1dc5919a2e78.png)

当电子邮件进来时，服务器将发出`newEmail`事件。例如，如果我注册了一项新服务，该服务会向我发送电子邮件以确认我的电子邮件。然后，服务器最终会收到该电子邮件，并发出一个事件供客户端监听。客户端将监听`newEmail`事件，并将能够使用 jQuery、React、Ember 或它碰巧正在使用的任何库在浏览器中重新呈现电子邮件列表，向我(用户)显示新电子邮件。

现在，除了发送事件发生的消息，最重要的是发送数据，我们可以做到这一点。当您创建并发出自定义事件时，您可以将您喜欢的任何信息从服务器发送到客户端，或者从客户端发送到服务器。通常，这采取具有各种属性的对象的形式。在收到新邮件的情况下，我可能想知道邮件来自谁。我肯定需要知道电子邮件的文本，我也想知道电子邮件何时到达我的服务器，这样我就可以在浏览器中为碰巧使用电子邮件应用程序的人呈现我需要的内容。

现在，这是从服务器流向客户端的数据，这是我们无法用 HTTP 请求完成的事情，但我们可以用 Socket.io 完成。现在，另一个事件`createEmail`事件将从客户端流向服务器:

![](images/a4683655-d8fe-48a7-9f09-3c6d2500b135.png)

当我在我的网络浏览器中创建新的电子邮件时，我需要从客户端发出该事件，服务器将监听该事件。我们将再次发送一些数据。虽然数据会有一点不同，但我们想知道电子邮件需要发送给谁，我们需要电子邮件的文本，也许我们想将其安排在下一行，因此可以使用`scheduleTimestamp`字段。

显然，这些都只是示例字段；真正的电子邮件应用程序的字段可能会有些不同。不过，有了这些，我们就可以在应用程序中创建这两个事件了。

# 在应用程序中创建自定义事件

让我们从创建`newEmail`和`createEmail`事件开始，开始在应用程序中创建自定义事件。在我们开始发出或收听定制事件之前，让我们继续对客户端 JavaScript 进行一些调整。

# 将 JavaScript 移动到一个单独的文件中

正如您可能在上一节中注意到的，我在客户端 JavaScript 代码中意外地使用了 ES6 箭头函数。正如我提到的，我们希望避免这种情况；该项目将在 Chrome 中正常工作，但如果您试图将其加载到手机、Internet Explorer、Safari 或某些版本的 Firefox 上，程序将会崩溃。因此，我们将通过移除箭头并在参数前添加`function`关键字来使用常规函数，而不是使用箭头函数。我将为`on('connect'`监听器和`on('disconnect'`监听器执行此操作，添加`function`关键字并移除箭头:

```
socket.on('connect', function () {
  console.log('Connected to server');
});

socket.on('disconnect', function () {
  console.log('Disconnected from server');
});
```

我还将把我们的 JavaScript 移到一个单独的文件中。我们将有一个单独的文件存放代码，而不是在我们的 HTML 文件中编辑客户端 JavaScript。这是把事情做好的更好的方法。

在`public`文件夹中，我们可以为这个 JavaScript 文件新建一个文件夹。我将制作一个名为`js`的应用程序(到这个应用程序结束时，我们将有多个 JavaScript 文件，所以创建一个文件夹来存放所有这些文件是个好主意)。但是现在，我们只需要一个，`index.js`。当我们加载`index.html`时，将加载`index.js`文件，它将包含让该页面工作所需的所有 JavaScript，从我们在上一节中编写的 JavaScript 开始。剪切掉`script`标签中的所有代码，粘贴到`index.js`中:

```
var socket = io();

socket.on('connect', function () {
  console.log('Connected to server');
});

socket.on('disconnect', function () {
  console.log('Disconnected from server');
});
```

我们可以保存文件并更新我们的`script`标签。我们将通过提供`src`属性来加载它，而不是让代码行，文件路径为`/js/index.js`:

```
  <script src="/socket.io/socket.io.js"></script>
  <script src="/js/index.js"></script>
</body>
```

现在我们已经有了这个，我们有了和以前完全一样的功能——只是这次，JavaScript 被分解成了自己的文件。使用`nodemon server/server.js`启动服务器。一旦它启动，我们可以通过进入浏览器并打开`localhost:3000`来加载应用程序。我还将打开开发人员工具，这样我们就可以确保一切都按预期进行。控制台内，我们看到`Connected to server`仍在打印:

![](images/8982ec98-bf7d-4919-af54-d88434f1a7ef.png)

这是存在于`index.js`中的代码，它出现在这里的事实本身就证明文件已经被加载。有了这些，我们现在可以继续我们的定制活动。

现在，我们为我们的示例电子邮件应用程序讨论了两个事件:我们有`newEmail`，它是从服务器到客户端；而我们有`createEmail`，这是一个由客户端发出，服务器监听的事件。我们将从`newEmail`开始，为了开始，我们将进入我们的客户端 JavaScript 并监听那个事件。

当该事件触发时，我们想要做一些事情:我们想要获取数据，并使用 jQuery、React 或其他一些前端框架将其呈现给浏览器，以便用户可以在电子邮件进入时立即看到它。

# 添加新的电子邮件自定义事件

现在为了听一个自定义事件，我们还是要用`socket.on`；但是，我们将在引号内提供第一个参数作为自定义事件的名称，而不是指定其中一个内置事件的名称。在这种情况下，该名称将是`newEmail`:

```
socket.on('newEmail');
```

现在，`socket.on`的第二个参数与内置事件侦听器的第二个参数相同。我们将提供一个函数，该函数将在事件触发时被调用:

```
socket.on('newEmail', function () {

});
```

现在，我们在函数内部要做的就是使用`console.log`打印一条小消息，`New email`:

```
socket.on('newEmail', function () {
  console.log('New email');
});
```

这将在 web 开发人员控制台内部打印，每次客户端听到这个事件通过管道传来。现在我们已经为`newEmail`准备好了监听器，让我们继续在`server.js`内部发出这个事件。

# 发射方法

在`server.js`内部，我们要做的是在`socket`上调用一个方法。`socket`方法有一个名为`emit`的方法，我们将在客户机和服务器上使用它来发出事件:

```
io.on('connection', (socket) => {
  console.log('New user connected');

  socket.emit('');
});
```

`emit`方法真的很像听者；虽然，我们不是在听一个事件，而是在创造这个事件。第一个论点是一样的。这将是您想要发出的事件的名称。在这种情况下，我们必须完全按照我们在`index.js`、`newEmail`中指定的方式进行匹配。现在，如下面的代码所示，我们将提供`newEmail`:

```
io.on('connection', (socket) => {
  console.log('New user connected');

  socket.emit('newEmail');
});
```

现在，这不是一个监听器，所以我们不会提供回调函数。我们要做的是指定数据。现在，默认情况下，我们不必指定任何数据；也许我们只是想什么都不用发出`newEmail`，让浏览器知道出事了。如果我们这样做，在浏览器内部我们可以刷新应用，我们得到`New email`，如下图所示:

![](images/3015d73d-3ead-4b41-a4d1-574b92392d0e.png)

尽管我们没有发送任何自定义数据，但事件仍在发生。如果您确实想发送自定义数据，这是最有可能的情况，这是超级容易的。你所要做的就是为`newEmail`提供第二个参数。现在，您可以提供一个三的参数，或者 true，或者任何其他的参数，但是您通常想要发送多条数据，所以一个对象将是您的第二个参数:

```
socket.emit('newEmail', {

});
```

这将让你指定你喜欢的任何东西。在我们的例子中，我们可以通过指定一个`from`属性来指定电子邮件来自谁；比如来自`mike@example.com`。也许我们也有电子邮件的`text`属性，`Hey. What is going on`，我们也可能有其他属性。例如，`createdAt`可以是服务器收到电子邮件的时间戳，如下所示:

```
socket.emit('newEmail', {
  from: 'mike@example.com',
  text: 'Hey. What is going on.',
  createdAt: 123
});
```

前面代码块中显示的数据将与`newEmail`事件一起从服务器发送到客户端。现在，继续保存`server.js`，在我们的客户端 JavaScript `index.js`文件中，我们可以继续处理这些数据。事件发出的数据作为回调函数的第一个参数提供。如下面的代码所示，我们有`newEmail`的回调函数，这意味着我们可以命名第一个参数`email`，并用它做我们想做的任何事情:

```
socket.on('newEmail', function (email) {
  console.log('New email');
});
```

我们可能会将其附加到一个真实的网络应用程序中的电子邮件列表中，但出于我们的目的，我们现在要做的就是将其作为第二个参数提供给`console.log`，将其呈现在屏幕上:

```
socket.on('newEmail', function (email) {
  console.log('New email', email);
});
```

有了这些，我们现在可以测试一切是否如预期的那样运行。

# 测试新的电子邮件事件

如果我进入浏览器，使用*命令* + *R* 进行刷新，我们会看到控制台内部有`New email`，下面有`Object`。我们可以点击`Object`展开它，我们可以看到我们指定的所有属性:

![](images/bd867838-4c51-46f5-b1b7-f8e364658f62.png)

我们拥有我们的`from`房产、`text`房产和我们的`createdAt`房产。一切都如预期的那样出现了，太棒了！实时地，我们不仅能够传递一个事件，而且能够将事件数据从服务器传递到客户端，这是我们用 HTTP API 永远做不到的。

# 添加创建电子邮件自定义事件

现在，在事情的另一面，我们有一种情况，我们希望从客户端发出一个事件，试图向服务器发送一些数据。这是为了我们的`createEmail`事件。现在，在这种情况下，我们将使用`socket.on`在`server.js`中添加我们的事件侦听器，就像我们在`server.js`中对任何其他事件侦听器所做的那样。

我们用于连接事件的`io.on`方法是一个非常特殊的事件；除了我们在本功能中提到的功能之外，您通常不会在`io`上附加任何东西，也不会拨打`io.on`或`io.emit`的电话。我们的自定义事件监听器将在下面的语句中通过调用`socket.on`来实现，就像我们对`disconnect`所做的那样，传入您想要收听的事件的名称—在本例中，它是`createEmail`事件:

```
socket.emit('newEmail', {
  from: 'mike@example.com',
  text: 'Hey. What is going on.',
  createdAt: 123
});

socket.on('createEmail');
```

现在，对于`createEmail`，我们确实想添加一个监听器。我们在我们的节点代码中，所以我们可以使用箭头函数:

```
socket.on('createEmail', () => {

});
```

我们可能会期待一些数据，比如要创建的电子邮件，所以我们可以命名第一个参数。我们以随事件一起发送的数据来命名，所以我将称之为`newEmail`。对于这个例子，我们要做的就是把它打印到控制台上，这样我们就可以确保事件正确地从客户端传递到服务器。我会添加`console.log`并注销事件名称，`createEmail`。作为第二个参数，我将注销数据，这样我就可以在终端中查看它，并确保一切都按预期运行:

```
socket.on('createEmail', (newEmail) => {
  console.log('createEmail', newEmail);
});
```

现在我们已经有了监听器，我们的服务器也重新启动了；然而，我们从未真正在客户端上发出事件。我们可以通过在`index.js`中调用`socket.emit`来解决这个问题。现在，在我们的`connect`回调函数中调用它。在我们连接之前，我们不想发出事件，`socket.emit`会让我们这样做。我们可以称`socket.emit`为发射事件。

事件名称为`createEmail`:

```
socket.on('connect', function () {
  console.log('Connected to server');

  socket.emit('createEmail');
});
```

然后，我们可以传递任何我们喜欢的数据作为第二个参数。在电子邮件应用程序的情况下，我们可能需要将其发送给某人，因此我们会有一个地址——类似于`jen@example.com`的内容。我们显然需要一些文本——类似`Hey. This is Andrew`的东西。此外，我们可能还有其他属性，例如 subject，但现在我们只讨论这两个属性:

```
socket.emit('createEmail', {
  to: 'jen@example.com',
  text: 'Hey. This is Andrew.'
})
```

因此，我们在这里所做的是，我们创建了一个客户端脚本，将它连接到服务器，一旦它连接，它就会发出这个`createEmail`事件。

Now, this is not a realistic example. In a real-world app, a user is most likely going to fill out a form. You'll grab the previously mentioned pieces of data from the form, and then you'll emit the event. We will be working with HTML forms a little later; for now, though, we're just calling `socket.emit` to play around with these custom events.

保存`index.js`，在浏览器内部，我们现在可以给页面一个刷新。一旦它连接起来，就会发出那个事件:

![](images/9ea89ef8-d3e2-402f-ae94-0bf7b4b40141.png)

在终端中，您可以看到`createEmail`打印:

![](images/b7b51fa1-5a51-452d-8594-bfb9a2b1972d.png)

事件是从客户端发送到服务器的。服务器得到了数据，一切正常。

# 开发人员控制台中的 socket.emit

现在，控制台的另一个很酷的地方是，我们可以访问应用程序创建的变量；最值得注意的是套接字变量。这意味着在谷歌 Chrome 内部，在开发者控制台中，我们可以调用`socket.emit`，我们可以发射任何我们喜欢的东西。

我可以发出一个动作，`createEmail`，我可以传入一些数据作为第二个参数，一个对象，其中我有一个等于`julie@example.com`的 to 属性。我也有我的其他属性——比如`text`，我可以设置为等于`Hey`:

```
socket.emit('createEmail', {to: 'julie@example.com', text: 'Hey'});
```

这是一个例子，说明我们如何使用开发人员控制台使调试我们的应用程序变得更加容易。我们可以输入一个语句，点击*进入*，它将继续发出事件:

![](images/8811a670-5871-4777-b76f-fe0776ab552b.png)

在终端中，我们将获得该事件并对其进行处理——无论是创建电子邮件还是执行我们可能需要的任何其他操作。在终端内，你可以看到`createEmail`出现了。我们会把那个发给朱莉，然后是文字，`Hey`。这一切都是从客户端传到服务器的:

![](images/5d17b9f5-2766-4b66-a660-5dcb8c2720c0.png)

既然我们已经做好了准备，并且已经考虑了如何使用这些自定义事件，现在是时候从电子邮件应用程序转移到我们将要构建的实际应用程序了:*聊天应用程序*。

# 聊天应用程序中的自定义事件

现在您已经知道如何发出和收听自定义事件，我们将继续创建两个事件，我们将在聊天应用程序中实际使用它们。这些将是`newMessage`和`createMessage`:

![](images/659b8cff-cdef-4a5a-8117-0694c4a5378e.png)

现在，对于聊天应用程序，我们再次拥有了我们的服务器，这将是我们构建的服务器；我们有我们的客户，他将成为聊天应用程序中的用户。很可能会有多个用户都想相互交流。

现在，我们将举行的第一个活动是`newMessage`活动。这将由服务器发出，并在客户端监听:

![](images/1be19315-6b2b-4499-ba4d-3e3c0d181df5.png)

当一条新消息进来时，服务器会将它发送给连接到聊天室的每个人，这样他们就可以将它显示在屏幕上，用户也可以继续响应它。`newMessage`事件需要一些数据。我们需要知道消息来自谁；一串某人的名字，例如`Andrew`、消息的文本、类似于`hey, can you meet up at six`的东西，以及一个`createdAt`时间戳。

所有这些数据都将在浏览器的聊天应用程序中呈现。我们将在一会儿真正做到这一点，但现在我们只是把它打印到控制台上。这是我想让你们创造的第一个事件。您将制作这个`newMessage`事件，从服务器发出它——现在，当用户连接时，您可以简单地发出它——并且您将在客户端上收听它。目前在客户端，拿到数据后只需用`console.log`打印一点消息即可。你可以说类似`got new message`的东西，打印这个数据传递的对象。

接下来，我们要处理的第二个事件是`createMessage`。这将从客户端传到服务器。所以如果我是用户 1，我会从我的浏览器中触发一个`createMessage`事件。这将发送到服务器，服务器将向其他所有人发送`newMessage`事件，这样他们就可以看到我的消息，这意味着`createMessage`事件将从客户端发出，而服务器将是该事件的监听者:

![](images/82e574bd-553e-43e4-bfa1-020918b7a805.png)

现在，这个事件需要一些数据。我们需要知道消息来自谁，以及文本:他们想说什么？我们需要这两条信息。

现在，请注意这里的一个差异:我们正在向客户端发送`from`、`text`和`createdAt`属性，但是当客户端创建消息时，我们并没有向其请求`createdAt`属性。这个`createdAt`属性实际上将在服务器上创建。这将阻止用户欺骗消息的创建时间。我们将信任用户向我们提供的某些属性；还有一些我们不会相信他们会提供给我们的，其中之一就是`createdAt`。

现在，对于`createMessage`，你所要做的就是在服务器上设置一个事件监听器，等待它触发，再一次，你可以简单地打印一条消息，例如`create message`，然后你可以提供传递给`console.log`的数据，将其打印到终端。现在，一旦你有了那个监听器，你就会想要发出它。您可以在用户第一次连接时发出它，也可以从 Chrome Developer Tools 发出几个`socket.emit`调用，确保所有消息都显示在终端中，收听`createMessage`事件。

我们将在`server.js`内部开始收听那个`createMessage`事件，这将在`server.js`中的`socket.emit`功能下面发生。现在，我们有一位来自`createEmail`的老事件听众；我们可以去掉这个，我们可以调用`socket.on`来收听我们全新的活动`createMessage`:

```
socket.on('createMessage');
```

`createMessage`事件实际发生时需要调用一个函数。我们想对消息数据做些什么:

```
socket.on('createMessage', () => {

});
```

目前，您只需要使用`console.log`将其打印到终端，这样我们就可以验证一切是否如预期的那样工作。我们将获得我们的消息数据，它将包括一个`from`属性和一个`text`属性，我们将把它打印到屏幕上。您不必指定我使用的确切消息；我只说`createMessage`，第二个参数将是从客户端传递到服务器的数据:

```
socket.on('createMessage', (message) => {
  console.log('createMessage', message);
});
```

现在我们已经有了我们的监听器，我们可以在`index.js`中在客户端发出这个。现在，我们当前有一个`createEmail`事件的发出调用。我来解除这个`emit`的召唤。我们先呼叫`socket.emit`，然后呼叫`emit('createMessage')`:

```
socket.on('connect', function () {
  console.log('Connected to server');

  socket.emit('createMessage');
});
```

接下来，我们将发射带有必要数据的`createMessage`。

Remember when you're emitting a custom event that the first argument is the event name and the second is the data.

对于数据，我们将提供一个具有两个属性的对象:`from`，这个属性来自`Andrew`；和`text`，这是消息的实际文本，可能类似于`Yup, that works for me`:

```
socket.emit('createMessage', {
  from: 'Andrew',
  text: 'Yup, that works for me.'
});
```

这将是我们发出的事件。我去保存`index.js`，前往浏览器，我们应该可以刷新 app，在终端看到数据:

![](images/98277517-b201-4820-bd7c-8b525aeb1b1b.png)

如前一个截图所示，在终端内部我们有`createMessage`和我们指定的`from`属性，以及文本`Yup, that works for me`。

现在，我们还可以从 Chrome Developer Tools 中发出事件来玩转 Socket.io，我们可以添加`socket.emit`，我们可以发出任何我们喜欢的事件，传入一些数据:

```
socket.emit('createMessage', {from: 'Jen', text: 'Nope'});
```

我们要发出的事件是`createMessage`，数据是`from`属性；这一个来自`Jen`和一个文字属性，`Nope`:

![](images/6c85e450-ed3d-42b2-bc66-a6e92e08d942.png)

当我把这个发下来的时候，消息实时显示在服务器上，如下图截图所示，可以看到是从`Jen`发来的，文字是`Nope`，一切都在按预期运行:

![](images/d2d5b142-317f-4c4b-9048-e17438974b18.png)

这是第一个事件。另一个是`newMessage`事件，将由服务器发出，由客户端监听。

# 新消息事件

首先，我们将在`index.js`中添加事件监听器。我们有`newEmail`的旧事件监听器。我将继续移除它，我们将呼叫`socket.on`来收听新事件`newMessage`。`newMessage`事件需要回调:

```
socket.on('newMessage', function () {

});
```

目前，我们将使用`console.log`将消息打印到控制台，但是稍后，我们将获取该消息并将其添加到浏览器中，以便用户可以在屏幕上看到它。现在，我们要获取消息数据。目前我将创建一个名为`message`的参数，我们可以使用`console.log`将它记录到屏幕上，打印事件的名称，以便在终端中跟踪，以及从服务器传递到客户端的实际数据:

```
socket.on('newMessage', function (message) {
  console.log('newMessage', message);
});
```

现在，我们最不需要做的事情就是简单地从服务器发出`newMessage`，确保它出现在客户端。在`server.js`里面，我们不发出`newEmail`，而是调用`socket.emit`，发出我们的自定义事件，`newMessage`:

```
io.on('connection', (socket) => {
  console.log('New user connected');

  socket.emit('newMessage');
});
```

现在，我们需要一些数据——消息数据。我们还将提供这个作为第二个参数。它将是一个具有`from`属性的对象。它可能来自你喜欢的任何人；我和`John`一起去:

```
socket.emit('newMessage', {
  from: 'John',
});
```

接下来，我们将提供`text`属性。这也可以是任何东西，比如`See you then`，最后我们提供`createdAt`房产。这将由服务器稍后生成，因此用户不能欺骗消息的创建时间，但现在，我们将只使用某种随机数，例如`123123`:

```
socket.emit('newMessage', {
  from: 'John',
  text: 'See you then',
  createdAt: 123123
});
```

现在，一旦用户连接到服务器，我们就会发出那个事件。在浏览器中，我可以继续刷新东西。我们的`newMessage`事件出现了，数据与我们在`server.js`文件中指定的完全一样:

![](images/53484234-07b0-4d98-9fa2-f2bf1522d640.png)

我们有我们的`createdAt`时间戳、我们的`from`属性和我们的`text`属性。在未来，我们将从字面上理解这些数据，并将其呈现到浏览器中，这样它就会显示出来，有人可以阅读它并对其做出响应，但现在我们已经完成了。我们的事件监听器位于`createMessage`的服务器上，事件监听器位于`newMessage`的客户端上。

这部分就到这里！既然我们已经完成了，我们将迅速做出承诺。我将关闭服务器并运行`git status`命令:

![](images/96400b89-9804-4600-935d-ff23fe25d419.png)

如前面的截图所示，我们这里有相当多的变化。我们在`public.js`文件夹中有了新的`js`文件，我们还更改了`server.js`和`index.html`。我将运行`git add .`命令将所有这些添加到下一个提交中，然后我将使用带有`-m`标志的`git commit`创建一个提交。这个的一个好消息是`Add newMessage and createMessage events`:

```
git commit -m 'Add newMessage and createMessage events'
```

有了这些，我们现在可以将代码推送到 GitHub。没有必要用 Heroku 做任何事情，因为我们还没有任何可视化的东西；我们将推迟到以后。

在下一节中，我们将连接消息，因此当标签 1 发出消息时，标签 2 可以看到它。这将使我们更接近于在不同的浏览器标签之间进行实时通信。

# 广播事件

现在我们已经有了定制的事件监听器和发射器，是时候真正连接消息系统了，这样当一个用户向服务器发送消息时，它实际上会被发送给每个连接的用户。如果我有两个标签打开，并且我从一个标签发出`createMessage`事件，我应该会看到消息在第二个标签中到达。

为了在本地测试，我们将使用单独的选项卡，但是同样的方法也适用于在不同网络上使用不同浏览器的 Heroku 只要每个人的浏览器上有相同的 URL，他们就会被连接，不管他们在哪个机器上。现在，对于 localhost，我们显然没有正确的权限，但是当我们部署到 Heroku 时，我们将在本节中进行测试，我们将能够在您的手机和您机器上运行的浏览器之间进行测试。

# 为所有用户连接创建消息监听器

首先，我们将更新`createMessage`监听器。目前，我们所做的只是将数据记录到屏幕上。但是在这里，我们并不只是记录它，我们实际上想要向每个人发出一个新的事件，一个`newMessage`事件，所以每个连接的用户都会收到一个特定用户发送的消息。为了做到这一点，我们将在`io`上调用一个方法，它将是`io.emit`:

```
socket.on('createMessage', (message) => {
  console.log('createMessage', message);
  io.emit
});
```

`Socket.emit`向单个连接发出事件，而`io.emit`向每个单个连接发出事件。在这里，我们将发出`newMessage`事件，将其指定为我们的第一个参数。与`socket.emit`一样，第二个参数是您想要发送的数据:

```
socket.on('createMessage', (message) => {
  console.log('createMessage', message);
  io.emit('newMessage', {

  })
});
```

现在，我们知道我们将从客户端获得一个`from`属性和一个`text`属性—这些属性出现在`index.js`的`createMessage`事件的`socket.emit`中—这意味着我们需要做的是传递这些属性，将`from`设置为等于`message.from`，并将`text`设置为等于`message.text`:

```
io.emit('newMessage', {
  from: message.from,
  text: message.text
})
```

现在，除了`from`和`text`之外，我们还将指定一个`createdAt`属性，该属性将由服务器生成，以防止特定客户端欺骗消息创建的时间。`createdAt`属性设置为等于`new Date`，我们将调用`getTime`方法来取回时间戳，我们之前已经这样做过了:

```
io.emit('newMessage', {
  from: message.from,
  text: message.text,
  createdAt: new Date().getTime()
});
```

现在我们已经有了这个，我们实际上已经连接了消息。我们可以继续分别从`server.js`和`index.js`中删除我们的发射调用——即`newMessage`发射调用和`createMessage`发射调用，确保保存这两个文件。有了这些，我们可以通过打开到服务器的两个连接并发出一些事件来继续测试。

# 测试消息事件

我将使用`nodemon server/server.js`命令启动终端内部的服务器:

![](images/2f0192c1-36b7-4667-b655-74be87037ef3.png)

在浏览器内部，我们现在可以打开两个选项卡，都在`localhost:3000`。对于这两个选项卡，我将打开开发人员工具，因为这是目前我们应用程序的图形用户界面。我们还没有任何表单，这意味着我们需要使用控制台选项卡来运行一些语句。我们将对第二个选项卡执行相同的操作:

![](images/2b76c60f-3aaa-465c-8791-6ed308ea1629.png)

请注意，一旦我们打开标签，我们将在终端中获得`New user connected`消息:

![](images/d3134c5a-c8dd-4d7f-8a1f-24f27e9561da.png)

现在我们已经打开了两个标签，我们可以从其中任何一个发出`createMessage`事件。我将通过调用`socket.emit`从第二个选项卡发出它，发出一个自定义事件。事件名称是`createMessage`，它采用我们刚刚讨论的两个属性——属性`from`和属性`text`,这两个属性我都将在`socket.emit`对象中指定。`from`属性将设置为等于名字`Andrew`，而`text`属性将设置为等于`'This should work'`:

```
socket.emit('createMessage', {from: 'Andrew', text: 'This should work!'});
```

有了这个，我们现在可以从浏览器发出我的事件。它将转到服务器，服务器将向每个连接的用户发送消息，包括发送消息的当前连接的用户。我们将点击*进入*，它会触发，我们看到我们得到`newMessage`。我们有刚刚创建的消息，但有趣的是，在另一个选项卡中，我们也有消息:来自一个用户的消息已经到达另一个单独选项卡中的另一个用户:

![](images/3c1a7d6e-35a8-4369-8009-094e6d4a6f74.png)

有了这些，我们现在有了一个非常基本的消息传递系统:一个用户发出一个事件，它到达服务器，服务器将它发送给其他所有连接的人。有了这些，我想提交并部署到 Heroku，这样我们就可以测试它了。

# 向 Heroku 提交和部署消息

如果我在终端中运行`git status`命令，我看到我的两个已更改的文件如预期的那样:

![](images/b4f5767e-22b4-4d24-8774-ffb6a27bb40c.png)

然后，我可以运行带有`-am`标志的`git commit`命令，为这个提交指定一个消息——类似于`Emit newMessage on createMessage`的东西将完成任务:

```
git commit -am 'Emit newMessage on createMessage'
```

然后，我可以继续进行提交，并将其推送到 GitHub 和 Heroku。`git push`命令会在 GitHub 上得到它。

`git push heroku master`命令将把它部署到网络上。

我们将能够打开我们的聊天应用程序，并确保无论浏览器、计算机或任何其他变量如何，它都能工作:

![](images/46fcc142-6d27-444c-b117-fc868a0a2157.png)

如前面的截图所示，我们正在压缩并启动应用程序。看起来一切都结束了。我将使用`heroku open`命令打开它。这将在我的默认浏览器中打开它，如下图所示，您将看到我们有`Welcome to the chat app`:

![](images/59853981-8d91-4aef-a24a-713307e74816.png)

# 使用 Heroku 在火狐浏览器中测试消息传递

现在，为了演示这一点，我将打开一个单独的浏览器。我将打开火狐并输入完全相同的网址。然后，我将复制这个网址并抓取火狐浏览器，使其变小，这样我们就可以在两者之间快速切换，在这里打开 Heroku 应用程序:

![](images/5473cdad-dee3-4f40-aaed-23b924882cff.png)

现在，火狐也通过右上角的菜单提供开发者工具。在那里，我们有一个网页开发部分；我们正在寻找网络控制台:

![](images/cec09cd5-77a7-400b-b0af-405d042bb09f.png)

现在我们已经打开了这个，我们可以进入开发者工具，查看连接到 Heroku 应用程序的 Chrome 标签，我们将使用`socket.emit`发出一个事件。我们将发出`createMessage`事件。我们将在对象内部指定自定义属性，然后我们可以将`from`设置为`Mike`，并将`text`属性设置为`Heroku`:

```
socket.emit('createMessage', {from: 'Mike', text: 'Heroku'});
```

现在，当我继续发出这个事件时，一切都应该像预期的那样工作。我们呼叫`socket.emit`并发射`createMessage`。我们有我们的数据，这意味着它将被发送到 Heroku 服务器，该服务器将把它发送到 Firefox。我们将发送这个，这意味着我们将在 Chrome 开发者工具中获得`newMessage`。然后，在火狐内部，我们也有消息。来自`Mike`，文字为`Heroku`，我们的服务器添加了`createdAt`时间戳:

![](images/e0df6017-f242-4a88-96c9-8e31161dd1be.png)

有了这个，我们有了一个信息系统——不仅在本地工作，而且在 Heroku 上工作——这意味着世界上任何人都可以访问这个网址；他们可以发出事件，其他所有连接的人都将在控制台中看到该事件。

现在我们已经在各种浏览器上测试过了，我将关闭火狐，我们将进入这一部分的第二部分。

# 向其他用户广播事件

在这一部分中，我们将讨论发出事件的不同方式。一些你想发送给每个人的事件:一条新消息应该发送给每一个用户，包括发送它的人，这样它就可以显示在消息列表中。另一方面，其他事件应该只发给其他人，所以如果用户一发出一个事件，它不应该回到用户一，而是只发给用户二和用户三。

一个很好的例子是用户加入聊天室。我想打印一个小消息，比如`Andrew joined`，当有人加入的时候，我想打印一个消息，比如`welcome Andrew`，给实际加入的用户。因此，在第一个选项卡中，我会看到`welcome Andrew`，在第二个选项卡中，我会看到`Andrew joined`。为了做到这一点，我们将研究在服务器中发出事件的不同方式。这将通过广播来完成。广播是向除一个特定用户之外的所有用户发送事件的术语。

我将使用`nodemon server/server.js`命令再次启动服务器，在 Atom 中，我们现在可以调整如何在`server.js`中的`io.emit`方法中发出事件。现在，这将是我们做事情的最后一种方式，但我们也将玩广播，这意味着我将对此进行评论，而不是删除它:

```
socket.on('createMessage', (message) => {
  console.log('createMessage', message);
  //io.emit('newMessage', {
  //  from: message.from,
  //  text: message.text,
  //  createdAt: new Date().getTime()
  //});
});
```

要广播，我们必须指定单个套接字。这让 Socket.io 库知道哪些用户不应该得到这个事件。在这种情况下，我们在这里调用的用户不会获得事件，但其他人会。现在，我们需要调用`socket.broadcast`:

```
socket.on('createMessage', (message) => {
  console.log('createMessage', message);
  //io.emit('newMessage', {
  //  from: message.from,
  //  text: message.text,
  //  createdAt: new Date().getTime()
  //});
  socket.broadcast
});
```

广播是一个有自己发射功能的对象，其语法与`io.emit`或`socket.emit`完全相同。最大的不同是它被发送给谁。这将把事件发送给除了提到的插座之外的所有人，这意味着如果我触发一个`createMessage`事件，`newMessage`事件将触发除了我之外的所有人，这正是我们在这里可以做的。

它将是相同的，这意味着我们可以继续传递消息事件名称。论点将是相同的:第一个将是`newMessage`，另一个将是具有我们属性的对象，`from: message.from`和`text: message.text`。最后，我们有`createdAt`等于一个新的时间戳，`new Date().getTime`:

```
socket.broadcast.emit('newMessage', {
  from: message.from,
  text: message.text,
  createdAt: new Date().getTime()
});
```

有了这些，我们将看不到我们发送的信息，但其他人会看到。我们可以通过前往谷歌浏览器来证明这一点。我将刷新两个选项卡，从第二个选项卡，我们将再次发出一个事件。我们实际上可以使用 web 开发人员控制台中的向上箭头键来重新运行我们之前的一个命令，这正是我们要做的:

```
socket.emit('createMessage', {from: 'Andrew', text: 'This should work'});
```

这里，我们发出一个`createMessage`事件，其中`from`属性设置为`Andrew`，而`text`属性等于`This should work`。如果我点击*进入*发送此信息，您会注意到此标签不再接收信息:

![](images/a2355f90-e4e6-4efa-b16b-9d7b1c43e29a.png)

但是，如果我转到`localhost:3000`，我们会看到`newMessage`显示消息数据:

![](images/1ed3ea24-b881-4894-8ca8-9642376e2aff.png)

这是因为 tab 2 广播该事件，这意味着它只被其他连接接收，例如 tab 1 或任何其他连接的用户。

# 当用户连接时发出两个事件

有了广播，让我们进入我们发出信息的最后一种方式。我们将在`socket.io`中发出两个事件，就在用户连接的时候。现在，我们实际上不会在这个上下文中使用广播，所以我们将注释掉广播对象并取消旧代码的注释。应该是这样的:

```
socket.on('createMessage', (message) => {
  console.log('createMessage', message);
  io.emit('newMessage', {
    from: message.from,
    text: message.text,
    createdAt: new Date().getTime()
  });
  // socket.broadcast.emit('newMessage', {
  // from: message.from,
  // text: message.text,
  // createdAt: new Date().getTime()
  //});
});
```

您将首先调用`socket.emit`向加入的用户发出消息。你的信息应该来自管理员，`from Admin`，文本应该是类似`Welcome to the chat app`的内容。

现在，和`socket.emit`一起，你还会调用`socket.broadcast.emit`，它会发送给除了加入的用户之外的所有人，这意味着你可以继续将`from`设置为再次等于`Admin`，并且可以将`text`设置为等于`New user joined`:

```
// socket.emit from Admin text Welcome to the chat app
// socket.broadcast.emit from Admin text New user joined
```

这意味着当我们加入聊天室时，我们会看到一条问候我们的消息，其他人也会看到一条消息，让他们知道有人加入了。这两个事件都将成为`newMessage`事件。我们必须指定`from`(这是`Admin`)`text`(这是我们说的应该的)和`createdAt`。

# 问候个人用户

为了开始，我们将填写第一个电话。这是对`socket.emit`的呼叫，该呼叫将负责问候个人用户:

```
// socket.emit from Admin text Welcome to the chat app
socket.emit
```

我们仍将发送一个`newMessage`类型的事件和来自`text`和`createdAt`的完全相同的数据。这里唯一的区别是，我们将生成所有属性，而不是像前面那样从用户那里获取一些属性。让我们从`from`开始。这个来自`Admin`。每当我们通过服务器发送消息时，我们都会呼叫`Admin`，而文本将是我们的小消息，`Welcome to the chat app`。接下来，我们将添加`createdAt`，通过调用`Date().getTime`方法将其设置为等于`new Date`:

```
socket.emit('newMessage', {
  from: 'Admin',
  text: 'Welcome to the chat app',
  createdAt: new Date().getTime()
});
```

稍后，我们将称呼他们的名字。目前我们还没有这方面的信息，所以我们将继续使用一般的问候语。有了这个电话，我们可以删除评论，我们可以进入第二个。这是一个广播呼叫，它会提醒除了加入的用户之外的所有其他用户，有人新来了。

# 在聊天中广播新用户

要在聊天中广播新用户，我们将使用`socket.broadcast.emit`并发出`newMessage`事件，提供我们的道具。`from`属性将再次设置为等于`Admin`字符串；`text`将被设置为等于我们的小消息，`New user joined`；最后一个是`createdAt`，通过调用`Date().getTime`方法将其设置为等于`new Date`:

```
// socket.broadcast.emit from Admin text New user joined
socket.broadcast.emit('newMessage', {
  from: 'Admin',
  text: 'New user joined',
  createdAt: new Date().getTime()
})
```

现在，我们可以删除我们对第二次通话的评论，一切都将按预期进行。接下来你需要做的是通过进入浏览器测试所有这些是否如预期的那样工作。有几种方法你可以做到；只要你完成了，那就没什么大不了的。

# 测试用户连接

在访问该页面之前，我将关闭我的两个旧选项卡并打开开发人员工具。然后，我们可以转到`localhost:3000`，我们应该会在开发者工具中看到一条小消息:

![](images/edd24c86-928c-46a7-bbef-28fb3bca952d.png)

这里看到一条新消息，`Welcome to the chat app`，打印，太神奇了！

接下来，我们要测试广播是否按预期工作。对于第二个选项卡，我还将打开开发人员工具，再次转到`localhost:3000`。我们再一次得到了我们的小信息:

![](images/981514a6-2843-4033-bd4d-5af4c8a316b8.png)

如果我们转到第一个选项卡，我们还会看到一个新用户加入，这也太棒了！

现在，我将提交保存这些更改。让我们继续关闭服务器并使用`git status`命令:

![](images/351f2f54-3ca8-43fb-8482-c79c6892da6a.png)

然后，我们可以继续运行带有`-am`标志的`git commit`命令，并指定一条消息，`Greet new user and alert others`:

```
git commit -am 'Greet new user, and alert others'
```

一旦提交到位，我们可以使用`git push`命令将其推送到 GitHub。

现在没有必要部署到 Heroku，尽管如果您觉得有兴趣，可以轻松部署和测试。有了这些，我们就大功告成了！

# 摘要

在本章中，我们研究了 Socket.io 和 WebSockets，以实现服务器和客户端之间的双向通信。我们致力于建立一个基本的快递服务器，一个后端和一个前端，我们在 GitHub 和 Heroku 上提交了它。接下来，我们研究在应用程序中添加`socket.io`来建立服务器和客户端之间的通信。

然后，我们研究了在应用程序内部发出和监听定制事件。最后，我们通过广播事件来连接消息系统，这样当一个用户向服务器发送消息时，它实际上被发送给除发送消息的用户之外的每个连接的用户。

有了所有这些，我们现在有了一个基本的——但有效的——消息传递系统，这是一个很好的起点！我们将在下一章继续添加更多的特性并构建用户界面。