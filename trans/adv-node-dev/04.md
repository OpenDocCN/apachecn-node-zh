# MongoDB、Mongoose 和 REST 应用编程接口——第 3 部分

在本章中，您将在上一章玩完猫鼬之后解决猫鼬查询和 ID 验证。我们将进入不同类型的待办事项方法的细节，然后将 API 部署到 Heroku。最后，在了解更多关于 Postman 环境和运行各种测试用例之后，我们将创建我们的测试数据库。

# 猫鼬查询和身份验证

在本节中，您将学习一些可以使用 Mongoose 查询数据的替代方法。现在，在`server.test`文件里面，我们已经看了一个方法，`Todo.find`。我们将再看两个，然后我们还将探索如何验证 ObjectIDs。

为了完成所有这些，我们将在`playground`文件夹中创建一个新文件。我要把这个叫做`mongoose-queries.js`，我们首先要做的是加载`db`文件夹中的`mongoose`文件和`models`文件夹中的`todo`文件。我将使用 ES6 析构，就像我们已经对发生这种情况的所有文件使用的那样，然后我们可以在本地文件中`require`。使用相对路径，我们需要从`playgroundserverdb`中调出一个目录，最后我们要找的文件名叫做`mongoose`:

```js
const {mongoose} = require('./../server/db/mongoose');
```

我们可以为`todo`做同样的事情；我们将从`require`中获取常量`Todo`，返回结果，这里的文件将遵循相同的路径。我们需要返回一个目录并进入`server`，但是我们将进入`models`，而不是进入`db`。然后我们会得到`todo`文件:

```js
const {Todo} = require('./../server/models/todo');
```

现在，在我们真正能够进行任何查询之前，我们要为 Robomongo 中的一个现有 Todos 获取一个 ID。在`TodoApp`数据库中，我将浏览我们所有的文档，我将只抓取第一个:

![](images/3b212db1-09be-4c05-8b05-f3b72f3db2cd.png)

我会右键点击编辑它，然后我可以抓取除引号、括号和`ObjectId`标识符之外的标识。有了 Atom 内部剪贴板中的这个 ID，我可以创建一个名为`id`的变量，并将其设置为我刚才在单引号中复制的 ID，现在我们有了一个 ID，我们可以在所有查询中使用它。

# Todo.find 方法

现在，我知道你之前已经用过`Todo.find`了，但是我们要谈一些其他的事情。所以目前我们将从这个开始。`Todo.find`可以让你查询任意多的 Todos。你可以不传递任何参数来取回你所有的 Todos，或者你可以通过任何东西来查询。我们将通过`_id`进行查询。现在，猫鼬很棒，它不需要你传入 ObjectIDs，因为它实际上可以为你做到这一点。在这种情况下，我们所拥有的是完全有效的。我们传入一个字符串作为值，Mongoose 将接受这个字符串，将其转换为 ObjectID，然后运行查询。这意味着我们不需要手动将字符串转换成 ObjectID。现在，在我们进行查询之后，我们可以附加一个`then`回调，我们将获得所有的 Todos，我们将命名该参数，然后我们可以继续将它们打印到屏幕上，`console.log('Todos',)`，第二个参数将是实际的`todos`数组:

```js
var id = '5a87f714abd1eb05704c92c9';

Todo.find({
   _id: id
}).then((todos) => {
   console.log('Todos', todos);
});
```

除了你确实可以把一个`id`作为一个字符串传入之外，这里没有什么新东西。

# Todo.findOne 方法

我们要看的下一个方法是`Todo.findOne`。现在，`Todo.findOne`和 find 很像，唯一的区别就是最多返回一个文档。这意味着它只是抓取与您的查询相匹配的第一个。在我们的例子中，我们通过一个唯一的 ID 进行查询，所以它只会找到一个匹配的项目，但是如果有其他结果，例如，如果我们用 completed false 查询所有 Todos，那么第一个文档将是唯一返回的文档，即使有两个匹配查询。我们能做的就是调用`findOne`和我们用 find 做的一样，为了证明这一点，我实际上要复制代码。我们需要做的就是改变一些事情。我们得到的不是`todos`，而是`todo`，我们只得到一个文档，而不是一系列文档。这意味着我可以打印一个后面跟有`todo`变量的`Todo`字符串:

```js
Todo.findOne({
   _id: id
}).then((todo) => {
   console.log('Todo', todo);
});
```

有了这些，我们现在有足够多的例子来说明运行文件并看看到底发生了什么是有意义的。

在终端内部，我将通过运行这个文件来开始工作，我将使用以下命令来运行它:

```js
**nodemon playground/mongoose-queries.js**
```

当我们运行文件时，我们得到我们的`Todos`数组，一个文档的数组，我们得到我们的`Todo`对象:

![](images/d4e624d9-1dc2-46eb-b809-c0e8822d156e.png)

如果你知道你只是想获取一个单独的项目，我建议使用`findOne`而不是`find`。你得到的是文档，而不是数组。当你要找的待办事项的标识不存在时，这也变得容易多了；而不是得到一个空数组作为结果，你会得到`null`回来，你可以用它工作，做你喜欢的任何事情。也许这意味着你返回了一个 404，或者如果找不到身份证，你想做些别的事情。

# Todo.findById 方法

我们要看的最后一个方法是`Todo.findById`。现在，如果你只是通过文档的标识符来寻找文档，那么`findById`就太棒了。除了 id 之外，没有其他方法可以查询，您所做的就是将 ID 作为参数传入。您不必制作查询对象，也不必设置`_id`提示。有了这个，我们现在可以做与`findOne`完全相同的事情。我要证明的是，通过接`then`的电话，贴在`Todo.findById`里面，把打印语句从`Todo`改成`Todo By Id`:

```js
Todo.findById(id).then((todo) => {
   console.log('Todo By Id', todo);
});
```

现在，如果我保存文件，`nodemon`将重新运行，我们会得到两者完全相同的结果:

![](images/cc9738b1-42e3-49ba-a4d5-7ddc96528f5a.png)

如果你想通过 ID 以外的东西找到一个文档，我推荐使用`findOne`。如果你想通过 ID 找到一个文档，我总是推荐使用`findById`。现在，所有这些和更多内容都可以在文档中找到，所以如果你想深入了解我在这里讨论的任何事情，你可以随时去[mongoosejs.com](http://mongoosejs.com)。点击阅读文档链接，在左侧有几个链接；我们正在寻找的是查询:

![](images/2f8abc07-5bf2-4d7b-bd94-a602fe79de92.png)

您可以了解更多关于如何查询文档的信息，但我们几乎涵盖了本页讨论的所有内容。

# 处理标识不存在的情况

现在，我想谈论的下一件事是当 ID 不正确时会发生什么，这将是这样的情况，因为，记住，我们的 API 将从用户那里获得这个 ID，这意味着如果 ID 不正确，我们不希望我们的代码失败，我们希望优雅地处理这些错误。为了证明这一点，我将继续稍微调整一下 ID。ID 确实有特定的协议，所以我想让你做的是，在这个例子中，在你的 ID 中找到一个数字。我将使用第一个字符，因为它恰好是一个数字，只需将它增加 1。我要从`5`去`6`。现在我们有了一个有效的 id，但是这个 ID 不会在数据库中，因为我对它进行了调整，显然数据库中的其他 Todo 与这个 ID 不匹配。

现在，您可以看到，当我们重新启动服务器时，我们得到了一个空数组用于 find 调用，并且我们得到了两个空数组`findOne`和`findById`:

![](images/7c59ab25-aa86-4cb3-b4f4-0295b070e958.png)

当您的 ID 与数据库中的任何内容都不匹配时，就不会抛出错误；它仍然会激发成功案例，它只是用空数组或 null 来激发它，这意味着当我们想要处理数据库中不存在 ID 的那种情况时，我们所要做的就是添加一个`if`语句。在`Todo.findById`语句中，我可以添加一个`if`语句。如果没有待办事项，我们将做一些事情，而这些事情将会使用`return`来阻止其余功能的执行，我们将打印一条小消息，`console.log('Id not found')`:

```js
Todo.findById(id).then((todo) => {
   if(!todo) {
         return console.log('Id not found');
   }
   console.log('Todo By Id', todo);
});
```

现在，如果我保存文件，最后一次调用应该会有所不同:

![](images/9bf4952f-8946-444a-bf57-16b483e3eff5.png)

如前面的截图所示，我们得到的不是空值的 Todo，而是`Id not found`，这很完美。现在我们知道了如何使用`findOne`和`findById`进行查询，也知道了如何处理您所查询的 ID 实际上并不存在于集合内部的情况。我会将 ID 设置回其原始值，将`6`更改为`5`，如果我保存文件，nodemon 将重新启动，我们将取回文档。

# 验证 ObjectID

现在，我最不想谈论的是如何验证 ObjectID。到目前为止，我们已经创建了一个有效的 ObjectID。它只是一个不在集合中的值，但是如果我们要做一些类似于在两个`1`上钉钉子的事情，我们实际上会有一个无效的 id，这将导致程序中的错误。现在，您可能想知道为什么会发生这种情况，但它可能会发生，因为用户是指定标识的人。我们将在`findById`上添加一个`catch`呼叫。我们将获得该错误，并使用`console.log`简单地将其打印到屏幕上:

```js
Todo.findById(id).then((todo) => { 
  if(!todo) { 
    return console.log('Id not found'); 
  } 
  console.log('Todo By Id', todo); 
}).catch((e) => console.log(e));
```

现在，为了说明这一点，我们不需要所有三个查询。为了清理终端输出，我将继续注释掉`Todo.find`和`Todo.findOne`。有了这个，我们的无效 id，和`catch`回调，我们可以保存文件，在终端，我们应该得到一个非常长的错误消息:

![](images/271e562b-ff14-43a7-9ddf-950fcfb0494b.png)

对于给定值，我们有一条错误消息`CastError: Cast to ObjectId failed`。这是在警告你，你的`ObjectID`不只是不存在于收藏中，它实际上是完全无效的。现在，用`catch`方法运行这个确实让我们处理了错误。我们可以做一些事情，比如告诉用户，嘿，你发送的 ID 是无效的，但是还有另一种方法来完成它，我更喜欢。我们要做的是从 MongoDB 本地驱动程序中加载 ObjectID，这是我们以前做过的事情。就在这里`mongodb-connect`我们装上了，`ObjectID`。在`mongoose-queries`内部，我们也要做同样的事情。我将创建一个名为`ObjectID`的常量，我们将从`mongodb`库中获取它:

```js
const {ObjectID} = require('mongodb');
```

现在，在`ObjectID`上，我们有很多实用的方法。我们已经研究了如何创建新的对象，但是有一件事我们也可以使用，那就是一个叫做`ObjectId.isValid`的方法。`isValid`方法接受该值，在这种情况下，它是我们在`id`中的字符串，如果它有效，则返回 true，如果它无效，则返回 false，这意味着我们可以在运行查询之前添加`if`条件来验证该 id。

我们将添加一个`if`语句，并检查该值是否无效。我准备用感叹号翻转一下，然后我们就可以叫`ObjectID.isValid`了。通过翻转它，我们基本上创建了一个测试 ObjectID 是否无效的方法。我要传入的值只是存储在`id`变量中的字符串，现在我们可以添加一些代码，在 ID 无效时运行，`console.log('ID not valid')`:

```js
if(!ObjectID.isValid(id)) {
   console.log('ID not valid');
}
```

现在，如果我继续保存文件，我们应该得到我们的`ID not valid`消息，然后我们应该得到我们的错误消息打印到终端，因为我们仍然有我们的`catch`调用，并且这个查询仍然会运行。在这里我们得到的只是。`ID not valid`版画传到屏幕上:

![](images/7271def5-894b-4a9b-9afb-cee35c54b518.png)

但是现在我们知道如何验证身份证，这将在下一节中派上用场。

有了这些，现在是挑战的时候了。在我设置挑战之前，我将评论一下`id`和我们的`isValid`通话，下面我将评论一下`findById`。我要把它们留在这里；你可以把它们作为挑战中该做什么的参考。您的挑战将是查询用户集合。这意味着你会想继续前进，进入 Robomongo，从你的用户集合中获取一个 ID。这里我只有一个文档；如果您因为任何原因没有文档，您总是可以右键单击插入文档，您所要做的就是指定电子邮件。

现在，为了在 Atom 内部进行查询，您需要加载用户 Mongoose 模型，因为目前我们只有 Todo，require。在下面，我希望你使用`User.findById`来查询你在 Robomongo 中选择的 ID。然后你要继续处理这三个案子。将会有这样的情况，查询工作，但是没有用户。在这种情况下，你将打印类似`User not found`的东西。您还将处理找到用户的情况。我要你把用户打印到屏幕上。最后，您将处理可能发生的任何错误。您可以简单地将错误对象打印到屏幕上。这个不用用`isValid`，你只要填好`findById`就行了。

现在，我要做的第一件事是导入用户文件。我要做一个`const`，我要从 require 的返回结果中获取`User`变量，我们要遵循这里的相同路径。我们要走出`playground`目录，进入`server/models`目录，最后文件名是`user`:

```js
const {User} = require('./../server/models/user');
```

现在我们已经导入了用户，我们可以在下面进行查询。在写查询之前，我要在 Robomongo 中获取一个 ID:

![](images/3f7c8938-a78a-4d42-83e7-ded3e0b6a5ba.png)

我可以编辑文档，突出显示它，复制它，然后移回 Atom。在 Atom 内部，我将设置我的`User.findById`呼叫。我要做的就是传入身份证；我把它放在剪贴板上，我要用引号把它括起来。接下来是试镜。我要附加一个`then`回调，传入两个函数。第一个是承诺解决的时候，第二个是承诺被拒的时候。对于拒绝，我们要做的就是将错误对象打印到屏幕上，这意味着我们可以使用`console.log(e)`。现在，如果进展顺利，还是有一些例外。我们希望确保用户确实存在。如果该标识与集合中的任何内容都不匹配，查询仍将通过。如果没有用户，我们将使用`return`停止功能执行，然后使用`console.log('Unable to find user')`继续打印:

```js
User,findById('57bdb0fcdedf88450bfa2d66').then((user) => {
   if(!user) {
         return console.log('Unable to find user');
   }
}, (e) => {
   console.log(e);
});
```

现在，我们需要处理的最后一个情况是事情是否真的进展顺利，这意味着查询确实有效，并且在用户集合中找到了该 id。我将使用我们漂亮的打印技术添加`console.log`、变量`user`、`JSON.stringify`，传递我们的三个参数`user`、`undefined`和数字`2`:

```js
User.findById('5a8708e0e40b324268c5206c').then((user) => {
   if(!user) {
        return console.log('Unable to find user');
   }
   console.log(JSON.stringify(user, undefined, 2));
}, (e) => {
   console.log(e);
});
```

有了这个，我现在可以继续保存文件并打开终端，因为它目前是隐藏的，我们让我们的用户出现在终端:

![](images/b4f62900-9086-4a9b-b95e-795003c4df38.png)

这太棒了。如果你看到这个，你已经成功完成了挑战。现在我也可以测试我的其他案例是否如预期的那样工作。我要把 ID 末尾的`6`改成`7`并保存文件:

![](images/bb17f967-87b5-445b-82a3-16fdb0feb8f4.png)

当它重新启动时，我得到`Unable to find user`，这是意料之中的。接下来，我将把它改回一个`6`，但是我将添加几个`1`或者任何其他角色。在这种情况下，我将使用两个`1` s 和两个`a`字符。这一次我们确实得到了错误，我们无法将该值转换为 ObjectId。让我们撤销对标识的更改，现在我们完成了。

我将通过提交我们的更改来结束这一部分。我要关闭`nodemon`，运行一个`git status`命令，我们有一个新文件:

![](images/1fc9a660-f5f3-46e9-90f5-f7471359a469.png)

我可以使用`git add`将其添加到下一个提交中，然后我可以使用`git commit`进行提交。这一条的好消息是`Add queries playground file`:

```js
**git commit -m 'Add queries playground file'** 
```

有了这个，我将使用`git push`命令把它推送到 GitHub，我们就完成了。在下一节中，您将负责创建整个 API 请求。

# 获取单个资源–GET/todos/:id

在本节中，您将创建一个用于获取单个 Todo 的 API 路由。现在，这一部分的大部分都将是一个挑战，但是在我们开始之前，有一件事我想给你看，那就是如何获取一个通过网址传入的变量。现在，正如我提到的，这个网址的结构将是一个`GET`请求，`/todos`，然后我们将进入 Todos，获取一个 ID 被传递的单个项目，比如`/todos/12345`。这意味着我们需要将网址的标识部分动态化。无论用户传入什么，我都希望能够获取该值，并使用它进行查询。我们在像`User.findById`这样的`mongoose-queries`文件中设置的查询是按照 Id 获取待办事项。

现在为了做到这一点，让我们进入`server.js`文件并调用`app.get`，传入网址。

# 接受挑战

第一部分我们已经知道了，`/todos/`，但是现在我们需要的是一个 URL 参数。URL 参数遵循这种模式:它是一个冒号后跟一个名称。现在我可以称之为`:todoId`，或者其他任何东西，但是我们在这一部分称之为`:id`。这将创建一个`id`变量；它将在请求对象上，我们稍后将设置的对象，我们将能够访问该变量。这意味着当有人发出`GET /todos/1234324`请求时，回调将被触发，也就是我们现在要指定的回调，我们将能够通过他们传入的 ID 进行查询。现在，我们仍将获得请求和响应对象，唯一的区别是我们现在将使用请求之外的东西。这个是`req.params`。`req.params`对象将是一个对象，它将有键值对，其中键是 URL 参数，如 id，值是实际放在那里的任何值。为了演示这一点，我将简单地调用`res.send`，发回`req.params`对象:

```js
//GET /todos/12345
app.get('/todos/:id', (req, res) => {
   res.send(req.params);
});
```

这将让我们在邮递员内部测试这条路线，看看它是如何工作的。在终端内部，我可以启动我们的服务器。我将使用以下命令来启动:

```js
**nodemon server/server.js** 
```

现在服务器在`localhost:3000`上，我们可以对此做出`GET`请求，`/todos/:id`网址。在邮差里面，我会这样做；我们有 GET 方法，URL 是`localhost`，它还在端口`3000/todos/`上，然后我们可以输入任何我们喜欢的，比如`123`。现在，当我把这个发送出去的时候，我们得到的是`req.params`对象，在 Body 中你可以看到它有一个设置为`123`的`id`属性:

![](images/ba53ccec-d809-40de-a675-b04e78e148c6.png)

这意味着我们能够使用`req.params.id`访问网址中的值，这正是您在挑战中需要做的。在 Atom 内部，我将从创建这个变量开始，一个`var id = req.params.id`变量。

有了这个，你现在知道了完成挑战所需要的一切，也就是完成这条路线。首先，您将使用我们在`mongoose-queries`文件中探索的 ObjectID `isValid`方法来验证 ID。我会留下一点评论，`Valid id using isValid`。现在，如果无效，您要做的是停止函数执行，并使用`404`响应代码进行响应，因为传入的标识无效，并且它不可能在集合中。我们将使用`404`响应代码进行响应，让用户知道没有找到 Todo，您可以发回一个空的主体，这意味着您可以只调用 send 而不传入任何值。类似于`res.status(400).send(e)`语句，没有错误，你也可以将`400`改为`404`。

现在，在此之后，您将开始查询数据库，这将使用`findById`来实现。我要你拿着 Id 查询`Todos`集合，找匹配的文档；有两条路可以走。有成功的案例，也有错误的案例。如果我们得到了一个错误，这个错误就不言自明了:我们要做的就是发回一个`400`响应代码，让用户知道这个请求是无效的，我们也要继续下去，什么也不发回。我们不会发回该错误参数，因为为错误消息打印的错误可能包含私人信息。我们稍后将加强我们的错误处理。目前，如您所见，我们在相当多的地方复制了该功能。稍后会被转移到一个位置，但是现在你可以用`400`响应代码进行响应，并发送一个空的身体回来。这就引出了成功案例。现在，如果有一个待办事项，`if todo`，你要继续发送它回来。如果没有 Todo，`if no todo`，这意味着调用确实成功了，但是在集合中找不到 id。你要做的就是继续发送一个空体的`404`响应代码。

现在，这两种说法看起来非常相似。你发回了一个`404`，让用户知道他们传入的 ID 与`Todos`集合中的任何一个文档的 ID 都不匹配。现在你知道如何做所有这些，你可以使用任何你需要的东西来完成它。这意味着你可以使用`mongoose-queries`文件，你可以使用[mongoosejs.com](http://mongoosejs.com/)文档，你可以使用堆栈溢出，谷歌，或其他任何东西；这不是准确地记忆如何完成事情，而是靠你自己解决那些问题。最终，当这些技巧一次又一次出现时，你会记住很多，但现在你的目标是让它发挥作用。完成后，继续在邮递员应用程序中发出这个请求。这意味着你需要从 Robomongo 获取一个有效的 ID，并将其粘贴到 URL 中。您还可以测试有效但不存在于数据库中的 id 和无效的 id 会发生什么，例如`123`，它不是有效的 ObjectID。有了这些，你就可以开始挑战了。

# 挑战步骤 1 -填写代码

我要做的第一件事是填写代码。我们将验证该标识，如果无效，我们将发回一个`404`响应代码。在文件的最上面，我没有导入 ObjectID，所以我必须继续这样做。就在`bodyParser`下面，我可以创建一个变量`ObjectID`，并将其设置为等于`require`的返回结果；我们需要`mongodb`图书馆。现在我们已经有了`ObjectID`，我们可以继续使用它了。我们会写一个`if`语句，`if (ObjectID.isValid())`。现在，显然我们只想在无效的情况下运行这段代码，所以我将使用感叹号翻转返回结果，然后将`id`传入。现在我们有一个`if`条件，只有在作为网址参数传入的标识无效时才会通过。在这种情况下，我们将使用`return`来阻止函数执行，然后我将继续使用`res.status`进行响应，将其设置为等于`404`，并且我将在没有参数的情况下调用`send`，这样我就可以发回一个空体。好了，我们的第一件事完成了。有了这些，我们现在可以继续创建查询:

```js
//GET /todos/12345
app.get('/todos/:id', (req, res) => {
   var id = req.params.id;

   if(!ObjectID.isValid(id)) {
         return res.status(404).send();
   }
});
```

在这一点上，我们确实有一些东西可以测试:我们可以传入无效的身份证，并确保我们得到 404 回来。在终端内部，我使用`nodemon`运行应用程序，因此它在 Postman 中自动重启。我可以重新运行`localhost:3000/todos/123`请求，我们得到我们的 404，这太棒了:

![](images/a933a96a-a659-45b8-a47b-e09de0c84cd9.png)

这不是有效的 ObjectID，条件失败，404 确实被返回。

# 挑战步骤 2 -进行查询

接下来，我们将进行查询`Todo.findById`。这里我们要传入 ID，它在`id`变量中，然后我们要附加我们的成功和错误处理程序，`.then`，传入我们的成功回调。这可能会被单独的 Todo 文档调用，我也会调用`catch`，得到错误。我们可以先做错误处理。如果有错误，我们将保持事情非常简单，`res.status`，将其设置为`400`，然后我们将继续调用`send`，有意忽略错误对象:

```js
Todo.findById(id).then((todo) => {

}).catch((e) => {
   res.status(400).send();
});
```

有了这个，剩下唯一要做的就是填写成功处理程序。我们需要做的第一件事是确保一个 to do 被实际找到。此查询如果成功，可能不会总是返回实际的文档。我将使用`if`语句来检查是否没有 Todo。如果没有 Todo，我们想用`404`响应代码进行响应，就像之前一样。我们要去`return`停止功能执行，`res.status`。这里的状态将是`404`，我们将使用`send`无数据回应:

```js
Todo.findById(id).then((todo) => {
   if(!todo) {
         return res.status(404).send();
   }
}).catch((e) => {
   res.status(400).send();
});
```

# 挑战步骤 3 -成功之路

最后一种情况是幸福的道路，成功的情况，当一切按计划进行。该标识是有效的，我们在 Todos 集合中找到一个文档，它的标识与传入的标识匹配。在这种情况下，我们要做的就是使用`res.send`进行响应，发回 to do。现在，你可以像`res.todo(todo)`一样发送它；这确实有效，但我想做的是稍微调整一下。我将使用 ES6 对象定义发送回一个对象，其中 Todo 被附加为`todo`属性，而不是作为主体发送回 Todo，该定义与此相同:

```js
res.send({todo: todo});
```

这给了我一点灵活性。我总是可以在响应中添加其他属性，比如自定义状态代码或其他任何东西。这类似于我们用于`GET /todos`的技术。就在这里，`res.send({todos})`，我们不是用数组来响应，而是用一个具有`todos`属性的对象来响应，这个对象就是数组:

```js
Todo.findById(id).then((todo) => {
   if(!todo) {
         return res.status(404).send();
   }
   res.send({todo});
}).catch((e) => {
   res.status(400).send();
});
```

既然我们已经做好了，我们就可以测试了。我将保存文件，删除我们所有的注释，在需要的地方添加一个分号，我们将从 Robomongo 获取一个 ID。在 Robomongo 里面，我可以找到我的一个 Todos 的 ID。我要用第二个。我将编辑文档并将其复制到剪贴板。现在，在 Postman 中，我们可以继续发出请求，将 ID 设置为我们刚刚复制的 ID 值:

![](images/d1cb9eff-7242-47b7-ad97-c2601367793d.png)

我要把它送走。我们在拥有`todo`属性的地方获取对象，在该`todo`属性上，我们拥有文档的所有属性:`_id`、`text`、`completedAt`和`completed`:

![](images/94030e07-434b-4e56-a0b9-48fc1bbc1047.png)

现在，我想测试的最后一种情况是，当我们用一个有效的 ObjectID 请求一个 Todo，但是恰好不存在时会发生什么。我要这样做，取身份证上的最后一个号码，从`a`改成`b`:

![](images/16fbd9e5-d0d9-48b6-96a2-c7a3f4d4b0cc.png)

如果我把这个发出去，我们就能拿回我们的`404`响应代码，这太棒了；当我请求待办事项时，这正是我期望发生的事情。ObjectID 是有效的，只是不在集合中。既然我们已经提出了这个请求，我们实际上可以将它保存在我们的待办事项应用程序集合中，所以以后更容易启动这个。我将使用另存为来保存它:

![](images/455f68bc-e917-43fc-8007-6e1b356b7532.png)

我们可以将请求描述留空，并将请求名称更改为`GET /todos/:id`。我将把它添加到我们现有的集合中，Todo 应用程序集合。现在我们有三条路线；这条路线唯一剩下要做的就是添加一些测试用例，这将是下一节的主题。

为了总结这一点，让我们提交我们的更改，并将其推送到 GitHub。我要关闭服务器运行`git status`。

我们可以看到我们已经修改了文件；这意味着我可以用`-a`标志和`-m`标志运行`git commit`，然后我将提供我的提交消息。现在，如果你使用的是`-a`旗和`-m`旗，你实际上可以使用一个快捷方式，也就是`-am`旗，做完全一样的事情。它会将我们所有修改过的文件添加到提交中；这也将为我们提供一个添加消息的地方。这一条的好消息是`Add GET /todos/:id`:

```js
**git commit -am 'Add GET /todos/:id'** 
```

有了这些，我将进行提交，将其推送到 GitHub，我们就完成了。在下一节中，我们将继续为这条路线编写测试用例。这将是一个挑战，就像这次一样。

# 测试 GET /todos/:id

在本节中，我们将为这条路线创建三个测试用例，一个获取单个 Todo 项目的测试用例。一个是确保当我们传入一个无效的 ObjectID 时，我们得到一个`404`响应代码。另一个是验证当我们传入一个有效的 ObjectID，但它与一个文档不匹配时，我们得到一个`404`响应代码，最后我们将编写一个测试用例，确保当我们传入一个与一个文档匹配的 ObjectID 时，该文档实际上返回到响应主体中。

我们将一起为有效调用编写测试用例，然后您将自己编写两个测试用例。这将是本部分的挑战。

# 为 GET/todos/:id 编写测试用例

在`server.test.js`内部，我们可以通过添加`describe`块从最底部开始。我要调用 description，这个`describe`块将被命名为`GET /todos/:id`，我们可以添加我们的箭头函数(`=>`)作为回调函数。在我们的`describe`回调中，我们现在可以设置我们将要一起创建的测试用例`it('should return todo doc')`。这将是一个测试，确保当我们传入一个与文档匹配的有效 id 时，文档会返回。这将是一个异步测试，因此我们将指定`done`参数:

```js
describe('GET /todos/:id', () => {
   it('should return todo doc', (done) => {

   });
});
```

现在，为了运行这个测试用例，我们需要一个 Todo 的 ID，它实际上在集合中，如果你记得的话，我们确实向集合中添加了两个 Todo，但是不幸的是我们没有 ID。身份证是在幕后自动生成的；为了解决这个问题，我们要做的是添加 ID 属性，`_id`。这意味着我们将能够访问测试用例中的标识，并且一切都将如预期的那样工作。现在，为了做到这一点，我们必须从 MongoDB 中加载一个 ObjectID，这是我们以前做过的。我将使用 ES6 析构来创建一个常数。我要从要求`mongodb`的返回结果中抓取`ObjectID`:

```js
const {ObjectID} = require('mongodb');
```

现在，在`todos`数组内部，我们可以为我们的两个`todos`、`new ObjectID()`添加一个`_id`属性，用逗号——这是为第一个`todo`而设置的——下面我们还可以为第二个`todo`、`new ObjectID()`添加一个`_id`:

```js
const todos = [{
   _id: new ObjectID(),
   text: 'First test todo'
},{
   _id: new ObjectID(),
   text: 'Second test todo'
}];
```

现在我们有了 _ id，并且可以通过从`todos`数组中访问它们来访问这些 _ id，我们准备好编写测试用例了。

# 测试 1 -超级测试请求

我们将从创建超级测试请求开始。我们将从`app`快速应用程序中获取一些东西；这将是一个`get`请求，也就是我们正在测试的网址，实际的网址将是`/todos/id`，其中`id`等于`todos`中的这些 _ ids 之一。我将继续使用第一个`todo`的`_id`。在下面，我们可以通过将我们的字符串更改为模板字符串来解决这个问题，这样我们就可以注入`_id`、`/todos/`然后我们将添加我们的语法来将一个值注入到模板字符串中。在这种情况下，我们从`todos`阵列中访问一些东西。我们想抢第一件，这是第一件`todo`，我们在找它的`_id`属性。这是一个 ObjectID 我们需要把它转换成一个字符串，因为这就是我们要传入的 URL。要将 ObjectID 转换为字符串，我们可以使用`toHexString`方法:

```js
describe('GET /todos/:id', () => {
   it('should return todo doc', (done) => {
         request(app)
         .get(`/todos/${todos[0]._id.toHexString()}`)
   });
});
```

开始了。现在我们已经生成了正确的 ID，并且可以开始断言当这个请求被激发时应该发生什么。首先，HTTP 状态代码。那应该是一个`200`，所以我可以叫`expect`，路过`200`。下一步:我们确实想要验证返回的身体与`todos`数组中先前的身体匹配，最值得注意的是`text`属性等于我们设置的`text`属性。我将创建一个自定义`expect`调用来完成这项工作。我们将传入用响应对象调用的函数，现在我们可以使用`expect`库进行断言。我将使用`expect(res.body.todo)`，这是我们在使用 ES6 对象语法时在`res.send({todo})`中设置的，并且`todo`属性有一个等于使用`toBe`的`text`属性，也就是我们第一个`todo`的`text`属性。这将是`todos`，抓取第一个，零索引的待办事项，我们将抓取它的`text`属性。有了这些，我们所有的断言都完成了；我们可以调用`end`，传入`done`，这将结束测试用例:

```js
describe('GET /todos/:id', () => {
   it('should return todo doc', (done) => {
         request(app)
         .get(`/todos/${todos[0]._id.toHexString()}`)
         .expect((res) => {
               expect(res.body.todo.text).toBe(todos[0].text);
         })
```

```js
         .end(done);
   });
});
```

现在我们可以通过运行`npm run test-watch`在终端内部运行这个测试。这将启动我们的测试套件，我们应该有我们的测试用例通过的新部分:

![](images/970e9653-b8a6-4fcd-a4aa-a2b79168b5fe.png)

就在这里，我们得到`should return todo doc`，那就是传球，这太棒了。现在是你自己写两个测试用例的时候了。我会给你它的调用，所以我们在同一个页面上，但你将负责填写实际的测试函数，`it('should return 404 if todo not found')`。这将是一个异步测试，所以我们将指定`done`参数，您在这里的工作将是使用一个真正的 ObjectID 发出请求，并且您将调用它的`toHexString`方法。这将是一个有效的 id，但在集合中找不到，所以我们应该得到一个 404 回来。现在，您需要设置的唯一期望是状态代码；确保你能找回`404`。

# 测试 2 -验证无效标识

您要编写的第二个测试将验证当我们有一个无效的 id 时，我们会得到一个`404`响应代码`it('should return 404 for non-object ids')`。这也将是一个异步测试，所以我们将指定`done`。对于这一个，你要传入一个网址，像这样:`/todos/123`。这确实是一个有效的网址，但是当我们试图将`123`转换为 ObjectID 时，它会失败，这应该会触发`return res.status(404).send()`代码，我们应该会得到一个`404`响应代码。同样，您需要为这个测试设置的唯一期望是，当您向 URL 发出 get 请求时，一个`404`是状态代码。花一点时间淘汰这两个测试用例，确保它们在您实际设置好调用时如预期的那样工作。当你完成时，如果你所有的测试用例都在终端中通过，那么你就可以继续前进了。

对于第一个，我将继续通过创建一个变量来获得这个`HexString`。现在，你不需要创建一个变量；你本可以做得稍微不同。我将创建一个名为`hexId`的变量，将其设置为`new ObjectID`。现在在这个`ObjectID`上，我们确实想要调用我们之前使用的那个`toHexString`方法。这将获取我们的 ObjectID 并给我们一个字符串，我们可以将该字符串指定为 URL 的一部分。现在，如果你在 get call 里面做这个也没关系，就像我们在这里做的一样；只要测试用例通过，这两种方法都有效。我们将调用`request`，传入我们的应用程序。接下来，我们将提出一个`get`请求，所以我将调用那个`get`方法，我们可以设置我们的网址。这个将是`/todos/`，我们将在模板字符串中注入`hexId`值。我们需要设置的唯一期望是一个`404`状态代码返回。我们期待`404`。我们可以通过调用`end`来包装这个测试用例，传入我们的`done`函数:

```js
it('should return 404 if todo not found', (done) => {
   var hexId = new ObjectID().toHexString();

   request(app)
   .get(`/todos/${hexId}`)
   .expect(404)
   .end(done);
});

it('should return 404 for non-object ids', (done) => {
   // /todos/123
});
```

现在我们可以保存文件，这个测试用例应该重新运行。最后一次测试仍然会失败，但这没关系，在这里，您可以看到我们得到的正是，`should return todo doc`通过和`should return 404 if todo not found`通过:

![](images/6f06ef81-b971-4988-85eb-4ad1b3f5d404.png)

最后要写的测试是当我们有一个无效的 ObjectID 时会发生什么。

# 测试 3 -验证无效的对象

我将呼叫`request`，传入`app`，然后我将继续呼叫`get`，设置网址。我们不需要在这里使用模板字符串，因为我们只需要传入一个普通字符串`/todos/123abc`。确实是无效的 ObjectID。正如我们所谈到的，ObjectIDs 有一个非常具体的结构，这个没有通过那个标准。要了解更多关于 ObjectID 的信息，您可以回到本章开头的 ObjectID 部分。接下来，我们将通过调用`expect`并期望`404`返回来开始设置我们的断言，并且我们可以通过调用`end`方法并传入`done`来结束这个测试:

```js
it('should return 404 for non-object ids', (done) => {
   request(app)
   .get('/todos/123abc')
   .expect(404)
   .end(done);
});
```

有了这些，我们的`GET /todos/:id`测试套件就完成了。在终端，它只是重新运行，所有的测试用例都通过了，这太棒了:

![](images/aeccb951-303d-495e-9f59-c56fda1495f6.png)

我们现在已经为路由设置了一个完整的测试套件，这意味着我们已经完成了，如果数据返回不正确，例如，如果主体数据附加了一个像字符`1`一样的额外字符，那么测试用例将会失败。一切都非常非常好。

剩下要做的最后一件事就是提交我们的变更。在终端内部，我将关闭`nodemon`并运行`git status`。以下是我们对`server.test`文件的更改，这是一个修改过的文件——git 已经在跟踪它，这意味着我可以使用带有`-a`或`-m`标志的`git commit`或组合的`-am`标志，提供一条消息，`Add test cases for GET /todos/:id`:

```js
**git commit -am 'Add test cases for GET /todos/:id'** 
```

我将提交并将其推送到 GitHub。在下一节中，我们将稍微改变一下。我们将使用真实世界的 MongoDB 数据库将我们的应用程序部署到 Heroku，而不是继续添加新的路由，我们稍后会做这些。这意味着我们在 Postman 中进行的所有调用都可以在真正的服务器上进行，任何人都可以进行这些调用，不仅仅是本地机器上的人，因为 URL 将不再在本地主机上。

# 将应用编程接口部署到 Heroku

在本节中，您将把待办事项应用编程接口部署到 Heroku，这样任何拥有该网址的人都可以访问这些路由，添加和获取待办事项。现在，在我们把它推给 Heroku 之前，有很多东西我们需要改变，一些小的调整让它为 Heroku 服务器做好准备。其中一个更大的调整是建立一个真正的 MongoDB 数据库，因为目前我们使用的是一个本地主机数据库，一旦我们在 Heroku 上获得应用程序，这个数据库就不可用了。

为了开始工作，我们将进入`server`文件并设置`app`变量，以使用 Heroku 将要设置的`environment`端口变量，这是我们在上一节部署到 Heroku 时所做的。如果你还记得，我们所做的是我们创建了一个名为`port`的变量，并将其设置为`process.env.PORT`。这是可以设置也可以不设置的变量；如果应用程序在 Heroku 上运行，它将被设置，但是如果它在本地运行，它将不会被设置。如果没有定义端口，我们可以使用`||`(或)语法来设置一个值。这将在本地主机上使用，我们将继续使用端口`3000`:

```js
var app = express();
const port = process.env.PORT || 3000;
```

如果`process.env.PORT`变量存在，我们将使用它；如果不是我们就用`3000`。现在，我们需要将`app.listen`中的`3000`换成`port`，这意味着我们对`app.listen`的调用将有`port`传入，我们下面的字符串将被转换为模板字符串，因此我们可以注入实际的端口。在`app.listen`内部，我将使用`Started up at port`，然后我将把实际的端口变量注入模板字符串:

```js
app.listen(port, () => {
   console.log(`Started on port ${port}`);
});
```

好了，端口设置好了，现在我们可以进入`package.json`文件了。有两件事我们需要调整。首先，我们需要告诉 Heroku 如何启动这个项目。这是通过`start`脚本完成的。`start`脚本是 Heroku 将要运行以启动应用程序的命令。在我们的例子中是`node`，然后我们进入`server`目录，运行`server.js`文件。我在结尾有一个逗号，我们可以继续`start`脚本:

```js
"scripts": {
  "start": "node server/server.js",
  "test":"mocha server/**/*.test.js",
  "test-watch":"nodemon --exec 'npm test'"
}
```

接下来我们需要做的是告诉 Heroku 我们想要使用哪个版本的 Node。当前的默认版本是 Node 的 v5 版本，这将导致一些问题，因为我们在这个项目中利用了许多 ES6 特性，而这些特性在 Node 的 v6 版本中是可用的。为了弄清楚您使用的是什么版本的节点，您可以从终端运行`node -v`:

![](images/5bd2f4bd-ccb0-4ef8-83e3-4d79bf3343fc.png)

这里我用的是 9 . 3 . 0；如果您使用的是不同的 v6 版本，那就再好不过了。在`package.json`里面，我们将告诉 Heroku 使用我们在这里使用的同一个版本。这是通过设置一个`engines`属性来实现的，`engines`允许我们为 Heroku 允许我们配置的东西指定不同的版本。其中之一就是`node`。属性名为`node`，值为要使用的节点版本`6.2.2`:

```js
"engines": {
  "node": "9.3.0"
},
```

现在我们的`package.json`文件已经为 Heroku 准备好了。Heroku 知道如何启动应用程序，并且它确切知道我们想要使用哪个版本的 Node，因此我们在部署时不会出现任何奇怪的错误。

随着`package.json`的退出，我们最不需要做的事情就是建立一个数据库，我们将通过一个 Heroku 插件来实现这一点。如果你去 Heroku 的网站，点击你的任何一个应用，我们还没有为这个创建一个，所以点击上一部分的一个应用。我要去点击我的一个。您将看到一个小仪表板，您可以在其中做很多事情:

![](images/2d3cf4cd-110f-4f91-8b04-491a124357f9.png)

如前面的截图所示，您可以看到有一个“已安装的加载项”部分，但是我们真正想要的是配置我们的加载项。当您配置您的附加组件时，您可以添加 Heroku 内置的各种非常酷的工具。现在，并非所有这些都是免费的，但大多数都有一个很好的免费计划:

![](images/64dbf0fc-816e-41bc-822c-266c7a5d7921.png)

你可以看到我们有各种数据库相关的项目；在下面，我们有数据存储实用程序，我们有监控工具，以及许多非常酷的东西。我们将使用一个名为 mLab 的附加组件:

![](images/933af428-a4ba-4c37-8d70-5cb0bf05186b.png)

这是一个 MongoDB 数据库服务；它有一个很棒的免费计划，它将让我们将 MongoDB 与我们的 Heroku 应用程序集成在一起。现在，您实际上不需要在网站上做任何事情，因为我们将在终端上做所有事情。我只想让你知道它到底住在哪里。在下面，你可以看到他们确实有一个免费的沙盒计划，他们的计划一直到每月 5000 美元。我们将坚持零美元计划。

# 创建英雄库应用程序

为了进行设置，在终端内部，我们将创建一个新的 Heroku 应用程序，因为目前我们还没有。`heroku create`是完成该操作的命令:

![](images/228770c5-058b-4d63-9a08-6b772f713115.png)

一旦创建了应用程序，我们需要告诉应用程序我们想要使用`mLab`，这是 Mongo Lab 的缩写。为了添加这个插件，我们将运行以下命令:

```js
**heroku addons:create**
```

现在，附加项是`mongolab:`，在`:`之后，我们将指定我们想要使用的计划。我们将使用沙盒计划，这是免费的:

```js
**heroku addons:create mongolab:sandbox** 
```

当我们运行这个命令时，它将用我们的 Heroku 应用程序配置`mLab`，我们就可以开始了。现在，如果您运行`heroku config`命令，您实际上可以获得 Heroku 应用程序的所有配置变量列表:

![](images/6530f625-915e-42d0-8859-4e2222687f14.png)

现在，我们只有一个配置变量；这是 URI 的蒙古数据库。这是`mLab`给我们的数据库 URL。这是我们需要连接的一个，这是我们的应用程序唯一可用的一个。现在，这个 MONGODB_URI 变量，当应用程序在 Heroku 上运行时，它实际上在`process.env`上，这意味着我们可以使用类似于我们在`mongoose.js`文件中所做的技术。在`mongoose.js`内部，在我们对`connect`的调用中，我们可以检查`process.env.MONGODB_URI`是否存在。如果有，我们就要用它；如果没有，在我们的`||`语句之后，我们将使用 localhost URL:

```js
mongoose.connect(process.env.MONGODB_URI || 'mongodb://localhost:27017/TodoApp');
```

这将确保我们的 Heroku 应用程序连接到实际的数据库，因为连接到 localhost 将失败，导致应用程序崩溃。有了这些，我们现在已经准备好让事情进行下去。

在终端内部，我将运行`git status`来检查我们更改的文件:

![](images/cda444d3-55d5-44f9-b5f2-e01c9615739d.png)

我们有三个；一切看起来都很好。我可以用`-am`旗跑`git commit`。这将让我们指定我们的提交消息，`Setup app for heroku`:

```js
**git commit -am 'Setup app for heroku'**
```

我将提交并将其推送到 GitHub。现在，我们需要将我们的应用程序推送到 Heroku。我将使用以下命令来实现这一点:

```js
**git push heroku master** 
```

请记住，当您创建一个 Heroku 应用程序时，它会自动添加 Heroku remote，这里我们将它发布到主分支。主分支是 Heroku 实际上要处理的唯一分支。应用程序正在被推高；它应该在几秒钟内准备好。一旦完成，我们就可以在浏览器中打开网址，看看我们到底得到了什么。

# 希洛库日志

另外一个我想稍微说一下的命令是一个叫做`heroku logs`的命令。`heroku logs`命令向您显示应用程序的服务器寿命。如果出现任何问题，您通常会在终端内部收到一条错误消息:

![](images/f50b0316-8ace-4d3a-982b-4b82dbe139da.png)

现在，如您所见，我们在底部有我们的 Started on port 4765 消息打印，这很棒；你的港口会有所不同。只要你有这个消息，一切都应该好走了。我要去跑步。

这将在我的浏览器中打开应用程序。我打算选择复制网址。我将进入 Chrome，我可以访问它:

![](images/666649b2-58e3-4844-87c0-fe79f551c4e8.png)

现在，访问应用程序的根应该没有什么作用，因为我们还没有设置根网址，但是如果我们去`/todos`我们应该让我们的`todos JSON`回来:

![](images/10bcefb2-8817-4860-b2fa-50106753b2c0.png)

在这里，您可以看到我们有一个空数组，这是预期的，因为我们没有添加任何 Todo 项，所以让我们继续这样做。

我想做的是抓取网址，然后走向邮递员。在邮差内部，我们要打几个电话。我要创建一个`POST /todos`请求；我所需要做的就是获取网址，并将其与我刚刚复制的网址交换，然后我就可以发送请求了，因为主体数据已经配置好了。我要把它送走。我们得到了我们的待办事项，这不是来自我们的本地机器，这是来自我们的 Heroku 应用程序，它正在与我们的 Mongo Lab MongoDB 数据库进行对话:

![](images/090d8e5a-d281-40ea-b91b-c981c6c8ec73.png)

现在，所有其他命令也应该可以工作了。我要去`GET /todos`，粘贴网址，我们应该可以得到我们所有的待办事项:

![](images/7e5e7556-9672-493d-a82a-d29be9feb3c7.png)

我还将检查当我们尝试获取单个 Todo 时会发生什么。我将复制`_id`，将其添加到网址上，并发送该请求:

![](images/711071d6-9ab7-4e77-9a4f-f8c9ef5cbbb5.png)

我得到了单个 Todo 项目。所以，无论我们使用哪种电话，一切都在按预期进行，这太棒了。我们的应用程序现在运行在 Heroku 上，有一个真实的生产数据库，这就是我们的应用程序。现在我们已经了解了 Heroku，在下一节中，我将向您展示我们可以在 Postman 内部使用的一些调整和技巧，以使我们的本地环境和 Heroku 环境之间的切换变得更加容易。

# 邮递员环境

在我们回到创建我们的快速路线之前，我们将花一点时间来探索邮递员的一个功能，它将使您在本地环境和 Heroku 应用程序之间切换变得更加容易。这叫做邮差环境。

# 管理邮递员环境

现在，为了说明这一点，我将通过运行`node server/server.js`命令来启动我的本地服务器，在 Postman 内部，我们将开始发出一些请求。现在，如果你还记得，在最后一节中，我们向 Heroku 应用程序提出了一个请求。我点击`GET /todos`网址上的发送，果然得到了`todos`数组。问题是，实际的项目保存在集合选项卡中，它们都使用该本地主机网址，并且没有很好的方法在两者之间切换。为了解决这个问题，我们将创建环境，一个用于本地机器，一个用于 Heroku。这将让我们创建一个变量作为网址，我们可以通过在无环境下拉菜单中切换来更改该变量。为了确切说明这将如何工作，我现在将复制 Heroku URL，然后我将转到无环境下拉列表，并单击管理环境:

![](images/86476d86-6921-457e-9108-e9d0850f025e.png)

这里我们目前没有，但我们可以继续添加两个。

# 待办事项应用本地环境

对于第一个环境，我将称之为`Todo App Local`。这将是本地 Todo 应用程序，我们可以设置一组键值对。现在，我们要设置的唯一键是 url。我们将为 Todo 应用程序本地环境设置一个本地主机网址，并为 Todo 应用程序 Heroku 环境设置 Heroku 网址，我们将在一秒钟内创建该网址。我们将以`localhost:3000`的身份进入`url`:

![](images/0cd6eac1-9736-46fa-bb60-cd05c0dab9b3.png)

我们不走小路，因为这取决于具体的路线。我将继续添加那个环境。

# Todo 应用 Heroku 环境

我们可以创造第二个；这个将被称为`Todo App Heroku`，我们将再次设置`url`键。虽然这次我们将它设置为等于我复制到剪贴板的值，但是 Heroku 应用程序 URL:

![](images/d25b6893-7c19-4bcc-b91e-f5e984739785.png)

我要补充的是，现在我们有了两个环境，我可以关闭窗口管理器。

我将关闭我的所有选项卡，我不会通过保存进行任何更改，然后我将转到`GET /todos`。现在，目前，`GET /todos`自动从`localhost`获取。我们要做的是用下面的语法替换 URL，斜杠之前的所有内容，如果您熟悉任何模板引擎，它看起来会很相似:两个大括号后跟变量名，`url`，后跟两个右括号，`{{url}}`。这将注入 URL，意味着`GET /todos`请求现在是动态的。我们可以根据环境改变它向哪个端点请求，localhost 还是 Heroku。我将保存此请求并将其关闭，当您尝试启动此请求时，您会注意到我们得到一个错误:

![](images/dfb4ed04-4556-437c-b818-084110cafd94.png)

它试图请求一个以大括号开头的网址；它是编码字符、`url`、结束大括号和 todos。那是因为`url`变量目前没有定义。我们需要换一个环境。在环境列表中，我们现在有待办事项应用英雄库和待办事项应用本地。如果我单击“待办事项应用本地”并发送该请求，我会在本地数据库中获得我的两个项目:

![](images/ec632d3c-ebe0-4764-8f55-92e12132b1e0.png)

如果我切换到 Todo 应用 Heroku，这将向 Heroku 应用程序发出请求。它将更新网址，当我们启动它时，我们会得到一组不同的数据:

![](images/ed631fd9-25a4-46e1-a145-68b9d360c2bc.png)

这一次，我们只有一个待办事项，可以在 Heroku 应用程序上找到。有了这个，现在`GET /todos`可以很容易地用来获取 localhost 或者 Heroku 的物品，我们可以用`POST /todos`的请求做同样的事情。我将把网址替换成大括号，在这些大括号中我们会有`url`变量。现在我可以保存这个请求，启动它，它将在 Heroku 应用程序上创建一个新的 Todo:

![](images/bac62164-ff98-4f51-9de7-fae6a35c6012.png)

如果我切换到本地待办事项应用程序，我们可以关闭它，现在我们在本地环境中有了一个新的待办事项:

![](images/e9962c29-7867-4a3c-b2b5-35ad1ece5a3b.png)

最后一个变更请求将是`GET /todos/:id`请求。我们将再次使用`localhost:3000`，然后我们将继续使用`url`替换它，就像这样，`{{url}}`，现在我们完成了。我们可以保存请求，然后继续执行并取消它。现在，这个有第二个变量:

![](images/f3f4c26f-c323-4fc7-b655-20f97d8f21ad.png)

这是实际的待办事项标识；您也可以将此作为变量添加。不过现在，因为它会随着我们添加和删除 Todos 而改变，所以我将简单地从本地数据库中获取一个，移入`GET /todos`请求，将其交换出去，并发送出去，然后我们得到我们的待办事项:

![](images/03fbcf9f-d253-4b67-8134-cb994c78507d.png)

如果我把它变成一个不存在的 Todo ObjectID，通过把其中一个数字改成`6`，我会得到一个`404`状态码。一切仍在按预期进行，它也将在 Heroku 环境中工作。我将从 Heroku 环境中获取所有 todo，抓取一个`_id`的，移动到`GET /todos/:id`请求，交换出 ID，发送出去，然后我们得到 todo 项。

希望你开始明白为什么这些邮差环境如此方便。您可以很容易地在两个环境之间切换，准确地改变请求发生的情况。现在，在这种情况下，我们恰好只有一个变量`url`；你可以添加其他人，我们稍后会添加。不过现在，就是这样，我们有办法在邮递员内部的两个环境之间进行交换。现在我们已经准备好了，我们将返回到 Atom 编辑器，并开始添加新的路线。还有两个。在下一节中，您将学习如何按 ID 删除 Todos。

# 删除资源–DELETE/todos/:id

在本节中，我们将探讨如何使用 Mongoose 从 MongoDB 集合中移除文档。然后你要负责填写`delete`路线，这会让某人通过 ID 删除一个 Todo。

首先，我们将复制那个`mongoose-queries`文件，调用新文件`mongoose-remove`。在文件中，我们可以删除低于初始导入的所有内容。我将突出显示文件中的所有内容，包括未注释的输出代码，删除它，最后得到一个如下所示的文件:

```js
const {ObjectID} = require('mongodb');

const {mongoose} = require('./../server/db/mongoose');
const {Todo} = require('./../server/models/todo');
const {User} = require('./../server/models/user');
```

猫鼬给了我们三种删除记录的方法；第一个允许您删除多条记录。

# Todo.remove 方法

这个是`Todo.remove`，`Todo.remove`的作品有点像`Todo.find`。您传入一个查询，该查询匹配多个记录，并删除所有记录。如果不匹配，则不会删除任何内容。现在，`Todo.find`和`Todo.remove`的区别，除了移除移除文档的事实，就是你不能传入一个空的参数并期望所有的文档都被移除。如果你想从你的收藏中移除所有东西，你需要像`Todo.remove({})`一样运行它。如果我们这样做，我们会把所有东西都搬走。我要去钉`then`。我们将返回结果，我们可以使用`console.log(result)`将结果打印到屏幕上，如下所示:

```js
Todo.remove({}).then((result) => { 
   console.log(result); 
});
```

现在我们可以运行`mongoose-remove`文件，它将从我们的数据库中删除所有的 Todos:

```js
**node playground/mongoose-remove.js**
```

![](images/8c04ea2d-7a16-4a78-b0b9-c0f6b1114821.png)

现在当我们运行`remove`方法时，我们再次得到一个`result`对象；这些东西很多对我们没有用，但是在最上面有一个`result`房产。我们可以看到删除确实起了作用，我们得到了一个`1`而不是`0`，我们有被删除的记录数量。在这种情况下，记录的数量恰好是`3`。

# todo . findone 和 move 方法

还有另外两种方法可以删除文档，在这一节中，这两种方法对我们会更有用。第一个将是`Todo.findOneAndRemove`。现在，`findOneAndRemove`将像`findOne`一样工作:它将匹配第一个文档，只是它将删除它。这也将返回文档，以便您可以对删除的数据进行处理。数据将从数据库中删除，但您将取回对象，以便可以将其打印到屏幕上或发送回用户。这与`remove`方法不同。在`remove`方法中，我们不拿回被移除的文档，我们只是得到一个数字，表示有多少被移除。通过`findOneAndRemove`我们确实得到了信息。

# Todo.findByIdAndRemove 方法

另一种方法是`Todo.findByIdAndRemove`。`findByIdAndRemove`方法的工作原理就像`findById`:你传入 ID 作为参数，它就把它去掉了。现在，这两个都将返回文档，这正是我们想要的。没有必要两个都跑，我们可以只跑一个。`Todo.findByIdAndRemove`方法，这将让我们删除一个`Todo ById`，一些像`asdf`这样的 ID，我们将能够附加一个`then`方法来提供我们的回调，回调将会取回文档。你可以称之为文档，或者在这种情况下我们可以称之为`todo`，因为它是一个待办事项:

```js
Todo.findByIdAndRemove('asdf').then((todo) => {

});
```

现在我们已经准备好了，我们只需要创建一个 Todo，因为我们已经删除了所有的 Todo，并且包含了 ID。在 Robomongo 内部，我可以右键单击该`todos`集合并插入一个文档。我们只需设置一个`text`属性，我会将该`text`属性设置为`Something to do`，我们就可以保存该记录。我将确保当我单击“查看文档”时，我们得到一个文档:

![](images/4d70010f-0594-4a0c-a4f4-edf08d09155c.png)

现在很明显，自从我在 Robomongo 中创建它以来，它丢失了一些属性，但是对于我们的目的来说，这很好。我现在要编辑该文档并获取 ID，这是我们可以添加到我们的游戏场文件中的 ID，以确保该文档被删除。在 Atom 内部，在`findByIdAndRemove`方法中，我们将传入我们的字符串。这是字符串标识，在我们的`then`回调中，我们将使用`console.log`将待办事项打印到控制台。我将注释掉这个移除上一个的调用，因为否则它将移除我们试图移除的文档:

```js
//Todo.remove({}).then((result) => {
// console.log(result);
//});
Todo.findByIdAndRemove('5aa8b74c3ceb31adb8043dbb').then((todo) => {
   console.log(todo);
});
```

有了这些，我现在可以保存文件，进入终端，并重新运行脚本。我将关闭它并重新启动它:

![](images/18facfc6-160e-471b-9854-7064243c797a.png)

我们得到了我们的文档，这太棒了，如果我进入 Robomongo 并尝试在 todos 中获取文档，我们会得到一个没有文档的错误；我们有一个，但我们删除了它。现在，在 Atom 里面我们也可以玩`findOneAndRemove`。`findOneAndRemove`方法的工作原理与`findByIdAndRemove`完全相同，只是它采用了那个查询对象。这将是`Todo.findOneAndRemove`；我们将像这样传入查询对象，粘贴我们的 ID，我们可以附加我们的`then`回调，它将被文档调用:

```js
Todo.findOneAndRemove({_id: '57c4670dbb35fcbf6fda1154'}).then((todo) => {

});
```

这两者的工作原理非常相似，但最大的区别是，您是否需要不仅仅通过 ID 进行查询。现在你知道如何使用`findByIdAndRemove`了，我们将进入`server`文件，开始填写实际路线。这将是让我们删除 Todo 的路径。我将为您设置路由，但是您将负责填写回调函数中的所有内容。

# 创建删除路线

要创建删除路线，我们将使用`app.delete`。然后，我们将提供网址，它看起来与我们获取个人待办事项标识`/todos/:id`的网址相同。这将是我们可以在回调函数内部访问的 ID。回调函数将获得相同的请求和响应参数，在内部，我将留下一些注释来引导您朝着正确的方向前进，但是您将负责填写每一件事情。首先，拿到身份证。你要像我们在上面做的那样，把身份证拿出来，我们要这样做，因为你要做的下一件事是验证身份证。如果无效，返回`404`。如果无效，你要像上面一样发送一个 404。接下来，您将按 id 删除 todo，这将要求您使用我们刚刚在`mongoose-remove`文件中讨论过的那个函数。你将通过身份证删除它，有两种方法。我们可能会成功，也可能会出错。如果我们确实得到一个错误，你可以用通常的方式回应，发送回一个空体的`400`状态码。现在，如果成功了，我们需要通过检查文档是否回来来确保一个 Todo 确实被删除了；如果没有单据，则发送`404`，这样该人就知道找不到 ID，无法删除，如果`doc`，则用`200`发回`doc`。现在，我们需要检查文档是否存在的原因是，即使没有 Todo 被删除，这个函数`findByIdAndRemove`仍然会调用它的成功案例。

我可以证明这一点，在删除了具有该标识的项目后，重新运行该文件。我要注释掉`findOneAndRemove`，进入终端，重新运行脚本:

![](images/2d54687a-389c-48ad-ad10-3c64281e02a9.png)

我们得到空值作为 Todo 的值。这意味着您想要设置一个`if`语句，如果实际上没有删除任何项目，则执行特定的操作。有了这些，你就可以走了。你知道如何做所有这些，大部分都是在上面的路线中完成的，所有移除物品的具体操作都在这个`playground`文件中完成。

我们需要做的第一件事是从请求对象中获取标识。我要做一个名为`id`的变量，设为等于`req.params`；这是我们所有 URL 参数的存储位置，然后我们通过值来获取它。我们已经建立了身份证，所以我们将获得`id`的财产。我将删除评论，下面我们可以验证标识`if(ObjectID.isValid)`。现在，我们正在检查这个 ID 是否有效，如果有效，那么我们真的不想做任何事情，我们只关心它是否无效。所以，我将翻转布尔值，在`if`条件中，我们现在可以在标识无效时运行一些代码。该代码将发回一个`404`状态代码。我准备用`return`阻止剩下的功能被执行，然后我们继续响应，设置状态，`res.status`，等于`404`，我们调用`send`在没有身体数据的情况下发起响应。现在 ObjectID 是有效的，我们可以在下面继续实际移除它。

我们将通过呼叫`Todo.findByIdAndRemove`来开始事情。现在，正如您所知，`findByIdAndRemove`只需要一个参数，实际的`id`要移除，我们可以调用`then`，传递我们的成功回调，正如我们所知，这将与单独的`todo`文档一起调用。现在，在成功案例中，我们仍然需要确保一个 Todo 被实际删除。如果没有托多，我们就送一辆 404 回去；如果没有 Todo，我们将使用`return`进行响应，并使用`res.status`将状态设置为`404`，并调用`send`启动响应。现在，如果这个 if 语句没有运行，这意味着一个 Todo 实际上被删除了。在这种情况下，我们想用`200`来回应，让用户知道一切都很顺利，我们将把`todo`的参数发回`res.send`，传入`todo`。这次托多挑战唯一剩下要做的就是呼叫`catch`。我们将调用 catch，这样我们就可以处理任何潜在的错误。我们要做的就是使用`res.status`进行响应，将其设置为等于`400`，然后我们将继续调用`send`，没有参数的情况下发回一个空响应:

```js
app.delete('/todos/:id', (req, res) => {
   var id = req.params.id;

   if(!ObjectID.isValid(id)) {
         return res.status(404).send();
   }

   Todo.findByIdAndRemove(id).then((todo) => {
         if(!todo) {
               return res.status(404).send();
         }
         res.send(todo);
   }).catch((e) => {
         res.status(400).send();
   });
});
```

有了这些，我们现在可以走了。我们已经按照我们想要的方式设置了一切，这意味着我们可以从下面移除注释，您会注意到我们下面的方法看起来与上面的方法非常相似，这将是我们管理单个 Todo 项目的许多路线的情况。我们总是想要得到那个 ID，我们总是想要验证 ObjectID 确实是一个真正的 ObjectID，在我们的成功和错误案例中，类似的事情也会发生。我们想确认一份文件确实被删除了。如果不是，我们将发回`404`，有了这个，我们现在可以验证这条路线是可行的。

现在我们可以保存文件并在终端中启动服务器。我将使用`clear`命令清除终端输出，然后我们可以运行以下命令:

```js
**node server/server.js** 
```

一旦服务器启动，我们就可以进入 Postman 并开始发出一些请求。首先，我要创建几个 Todos。我先把这个`POST /todos`送掉，然后把`text`属性改一下，再送掉。我将正文改为`Some other todo item`，发送出去，现在我们应该有两个 todos。如果我去`GET /todos`取它们，我们就得到我们的两个`todos`:

![](images/f5298901-ec78-45b8-acad-fd01a11d843c.png)

现在，我需要一个这样的身份证；这将是我们删除的待办事项，所以我要做的是将它复制到剪贴板，然后我们可以继续创建我们的新路线。这条新路线将使用`delete`方法，因此我们将从 GET 切换到 DELETE，然后我们可以继续使用我们在上一节中创建的环境变量 URL 提供 URL。路线为`/todos/id`。我要把身份证贴在那里:

![](images/f0366096-9c4b-482c-ba9a-40ec8db5264c.png)

现在我可以继续运行请求了。当我们运行它时，我们得到的状态代码是 200 OK 一切都很顺利，我们删除了文档:

![](images/f80c4479-640d-4a61-9f98-62d9c48fad2c.png)

如果我回到`GET /todos`重新运行，现在我们只有一个文档；我们作为要删除的 ID 传入的项目确实被删除了。我将把这个请求保存到我们的集合中，这样我们就可以启动它，而不必手动输入所有这些信息。我们先存为`DELETE`，后面是路线`/todos/:id`:

![](images/b99a8f13-fdf1-4a17-a2e5-375f4f3b8a3b.png)

我们将把它保存到一个现有的集合，Todo 应用程序集合。现在我们在 Collections 中有了一个`DELETE /todos/:id`路线，我们可以随时访问它。现在，从这里开始，我们将继续并再次激发请求，这将尝试删除一个标识有效但与集合中的标识不匹配的 Todo，然后我们将获得`404`。现在，如果我通过删除一堆字符使这个 id 无效，并且我把它发送出去，我们也会得到一个`404`状态代码，因为 ID 无效，这太棒了。

有了这些，我们现在可以做出承诺了。在终端内部，我要关闭服务器，运行`git status`，你会看到我们有两个文件。

我们有一个新的文件，猫鼬游乐场文件，我们有我们修改的`server`文件。我将使用`git add .`将所有这些添加到下一个提交中，我们将使用带有`-m`标志的`git commit`进行提交，`Add DELETE/todos/:id route`:

```js
**git commit -m 'Add DELETE /todos/:id route'** 
```

我将提交并将其推送到 GitHub。我们还可以使用以下命令继续部署我们的应用程序:

```js
**git push heroku master** 
```

现在我们可以在 Heroku 应用程序中删除我们的 Todos 了。有了这些，我们就完成了。在下一节中，我们将为刚刚设置的路线编写一些测试用例。

# 正在测试 DELETE /todos/:id

在本节中，您将编写一些测试用例来验证我们的`delete`路线是否如预期的那样工作。现在，在开始之前，我们要做的是对删除路由进行一个快速更改，使其与其他路由相匹配。我们的其他路由返回一个对象，在该对象上，即响应体上，我们有一个`todo`属性，我们为`todos`调用做了同样的事情。在响应体上，我们有`todos`属性，它存储数组。对于删除请求，我们从未这样做。

我要做的是发回一个对象作为响应体，其中`todo`属性等于被删除的`todo`，尽管我们将只使用 ES6 语法发回该对象:

```js
Todo.findByIdAndRemove(id).then((todo) => {
   if(!todo) {
         return res.status(404).send();
   }
   res.send({todo});
}).catch((e) => {
   res.status(400).send();
});
```

有了这些，我们现在可以继续编写一些测试用例来验证`delete`路线是否如预期的那样工作，这将发生在我们的`server.test`文件的最底部。我将为`DELETE /todos/:id`路线创建一个新的`describe`街区。我们将提供我们的箭头功能，我们可以继续调用它三次。

# 测试用例 1 -应该删除一个待办事项

第一个测试用例`it('should remove a todo')`，这将是第一个测试用例；它将验证当我们传入一个确实存在于 Todos 集合内部的 ID 时，该项目被移除:

```js
describe('DELETE /todos/:id', () => {
   it('should remove a todo', (done) => {

   });
});
```

# 测试用例 2 -如果没有找到 todo，应该返回 404

接下来，`it('should return 404 if todo not found')`。如果我们试图删除待办事项，但实际上什么也没有删除，我们将发送一个`404`状态代码回来，这样用户就知道调用可能没有像预期的那样工作。是的，呼叫不一定失败，但是您从未删除过您想要删除的项目，因此我们认为这是失败，这就是我们发回`404`状态代码时所做的:

```js
describe('DELETE /todos/:id', () => {
   it('should remove a todo', (done) => {

   }); 
   it('should return 404 if todo not found', (done) => {

   });
});
```

# 测试用例 3 -如果对象 id 无效，应该返回 404

我们要写的最后一个测试是`it('should return 404 if object id is invalid')`。该测试将验证当我们有一个无效的 ObjectID 时，我们确实得到一个`404`状态代码，它是预期的响应状态代码:

```js
describe('DELETE /todos/:id', () => {
   it('should remove a todo', (done) => {

   }); 
   it('should return 404 if todo not found', (done) => {

   });
   it('should return 404 if object id is invalid', (done) => {

   });
});
```

现在，这两个测试我们稍后会填写；我们将继续关注第一个，因为这是我们需要做一些复杂事情的地方。我们不仅需要发送请求，而且在请求返回之后，我们将想要断言一些关于它的事情，并且我们将想要查询数据库，确保 Todo 实际上已经从`Todos`集合中移除。我要做的第一件事是弄清楚我想删除哪个 to do。我们在上面有两个选择。我将删除第二个 Todo 项目，尽管这个选择无关紧要；你可以很容易地用第一个来做。在下面，我们将创建一个`hexId`变量，就像我们之前的测试用例一样。我们将它设置为等于来自`todos`数组的第二个项目，然后我们将继续获取它的`_id`属性，调用`toHexString`方法:

```js
var hexId = todos[1]._id.toHexString();
```

现在我们有了第二个待办事项的`hexId`，我们可以开始担心提出请求了。我将调用`request`，传入我们想要发出请求的`app`，然后我们可以调用`delete`，这将触发删除 HTTP 请求。下面的网址将有一些变量注入其中，所以我将使用模板字符串:它是`/todos/`后跟标识。我要注入`hexId`变量。既然我们已经建立了`delete`方法，我们就可以继续前进，开始实现我们的期望。我们将`expect`返回一个`200`状态代码；我们应该得到一个`200`状态代码，因为`hexId`将存在于数据库中。接下来，我们可以断言数据作为响应体返回。我将进行一个定制的`expect`调用，传入我们的函数，在那里我们发送响应参数，我们要做的就是断言 ID 是`hexId`变量中正确的 ID。我们将在`expect`中看到`res.body`属性有一个`todo`属性，其中`_id`属性等于`hexId`、`toBe(hexId)`。如果是这种情况，那么我们可以验证呼叫是否如预期的那样工作:

```js
request(app)
.delete(`/todos/${hexId}`)
.expect(200)
.expect((res) => {
   expect(res.body.todo._id).toBe(hexId);
})
```

我们需要做的最后一件事是查询数据库，并确保该项目实际上已被删除。我将调用`end`，传入一个回调，这样我们就可以在结束测试用例之前做一些异步的事情，如果你还记得的话，它会被调用并给出一个错误和响应。如果有错误，我们需要处理，因为否则就不需要查询数据库了。我们要去`return`阻止函数执行，`done`，传入那个错误，所以这个错误被摩卡渲染了。现在我们可以继续进行查询，这实际上是您在这一部分的挑战。

我想让你做的是使用`findById`查询数据库。您将尝试查找存储在`hexId`变量中的标识的待办事项。当你试图找到那个身份时，它应该会失败，你应该什么也拿不回来。您将在您的`then`调用中创建那个`Todo`变量，并确保它不存在。你可以使用`toNotExist`断言来确定某些东西不存在。看起来像这样，我们`expect(null).toNotExist()`。尽管，你将传递`Todo`参数，而不是`null`，该参数将出现在你的成功处理器中。现在，这通常会包含 Todo 项，但是由于我们刚刚删除了它，它不应该存在；这将完成所有这些。现在，如果有一个错误，你要做和我们在`POST /todos`测试用例中做的完全一样的事情。我们只需添加一个`catch`子句，将错误传递给`done`。既然你知道该做什么，你的工作就是完成它。我希望你做的是填写这个，填写查询，确保处理错误，确保调用`done`，然后你可以继续运行测试套件，验证这个测试用例是否通过。最后两个测试用例将会失败，所以目前我只是将它们注释掉；他们会失败，因为我们指定了一个`done`参数，但我们从未调用它，所以测试将在两秒钟后超时。

首先要做的就是调用`Todo.findById`，传入那个`hexId`。这是应该被删除的项目。现在我们可以调用了，传入我们的回调，它将被 doc 调用，`todo`变量，我们要做的就是验证它不存在。我们刚刚删除了，所以`findById`应该为单据返回 null。我们将使用期望库中可用的`toNotExist`方法去`expect`证明`todo`变量不存在。现在，我们确实需要调用`done`来结束测试用例。从这里，我们可以继续呼叫`catch`。我要打电话给`catch`，抓住那个错误论点并把它传递给`done`。这里不需要提供花括号；我们只有一条语句，因此可以使用快捷方式，这在 ES6 中可用于错误函数。有了实际的查询，我们就可以删除概述了应该发生的事情的注释，并且可以运行测试用例:

```js
.end((err, res) => {
   if(err){
         return done(err);
   }

   Todo.findById(hexId).then((todo) => {
         expect(todo).toBeFalsy();
         done();
   }).catch((e) => done(e));
});
```

在终端内部，我们现在可以运行测试套件，以验证我们设置的一切都如预期的那样工作。在终端内部，我将运行以下命令，用 Nodemon 启动我们的测试套件:

```js
**npm run test-watch**  
```

当它运行时，我们看到我们在`DELETE`描述块下有一个测试，它通过了；它应该移除没有任何错误地传递的 todo:

![](images/864712bc-7e32-458c-a2ec-c3b6d5f2440b.png)

现在我们已经有了一个测试用例，我们可以填写另外两个。这些测试用例将与我们在`GET /todos/:id`路线上的测试用例基本相同。当您:

*   确切知道代码的作用；我们知道它做什么，因为我们写了它
*   实际上确实需要它——我们不能重用它，我们需要稍微调整一下，所以复制它确实有意义

# 测试用例 4 -如果没有找到 todo，应该返回 404

我将复制`should return 404 if todo not found`测试的`should return 404`测试用例，我们将把它粘贴到`delete`路线的完全相同的测试中，我们所要做的就是将`.get`更改为`.delete`，并保存文件。这将重新运行测试套件，现在我们在 delete 下有两个测试；他们都路过:

![](images/f4e108cd-f803-4800-b1de-e99de825b274.png)

你可以看到我们的最后一次测试仍然失败，所以我们可以继续做同样的事情。我将从`should return 404 for non-object ids`复制代码，它验证非 ObjectIDs 导致一个`404`状态代码。我要把它粘贴到最后一个测试用例中，把`.get`方法调用改为`.delete`。如果我保存该文件，它将重新运行测试套件，这一次所有 9 个测试用例都通过了:

![](images/ccac1fd1-7cd8-4665-b5b6-c5a64d0195c4.png)

有了这个，我们现在已经测试了`DELETE /todos`。让我们继续，通过在终端内部进行提交来结束这个过程。

我要跑`git status`看看我发生了什么变化。我们对`server`文件做了一个小改动，并将我们的测试添加到了`server.test`文件中。我可以使用带有`-am`标志的`git commit`来使其生效，这个标志的一个好消息是`Test the DELETE /todos/:id route`:

```js
**git commit -am 'Test the DELETE /todos/:id route'** 
```

我将接受这个提交，并将其推送到 GitHub，没有必要部署到 Heroku，因为我们还没有创建任何视觉上不同的东西。我们确实稍微修改了一下`server`代码，但是我们稍后会再考虑这个问题。眼下，一切都好；我们可以进入下一部分，您将创建管理 Todos 的最终路线。这将是一个让你更新待办事项的路线。

# 正在更新资源- PATCH /todos/:id

`delete`路线现在已经建立并测试，所以是时候开始管理我们的 Todo 资源的最终路线了。这将是允许您更新待办事项的路径，无论您是想要将文本更改为其他内容，还是想要在完成后切换它。这将是我们写的最复杂的路线。到目前为止，一切都相对简单。我们需要做一些额外的事情来让这个更新路线按预期运行。

在我们继续创建下面的路线之前，我想做的第一件事是安装我们在本课程的前面部分中使用的洛达什库。

# 安装 Lodash 库

如果你还记得，洛达什提供了一些非常棒的实用功能，我们将在更新路线中利用其中的一些功能。在终端中，我将使用带有`--save`标志的`npm i`来安装它；模块名本身叫做`lodash`，我们将使用最新版本`@4.15.0`:

```js
**npm i --save lodash@4.17.5** 
```

现在，一旦安装了这个，我们就可以把它放在上面，然后我们就可以继续添加我们的路线了。在`server.js`文件的最上面，我们可以做一个常数；我们将使用下划线作为存储洛达什库的变量的名称，然后我们将继续并`require`它，`require('lodash')`。现在，我已经在我的其他导入中使用了常规变量而不是常量，所以我可以继续将这些变量切换为常量:

```js
const _ = require('lodash');

const express = require('express');
const bodyParser = require('body-parser');
const {ObjectID} = require('mongodb');
```

现在我们已经准备好了，我们准备移动到文件的底部，开始添加新的路径。这条路线将使用 HTTP `patch`方法；`patch`是您想要更新资源时使用的。现在请记住，这些都不是一成不变的。我可以有一条创建新 todos 的`delete`路线，也可以有一条删除 Todos 的`post`路线，但这些只是 API 开发的一般准则和最佳实践。我们将通过调用`app.patch`来设置`patch`方法路线。这将允许我们更新 Todo 项目。现在，该网址将与我们管理单个待办事项`/todos/:id`时的网址完全相同。然后我们可以用我们的请求和响应参数设置回调。在回调过程中，我们需要做的第一件事就是获取 id，就像我们获取所有其他路径一样。我将制作一个名为`id`的变量，并将其设置为等于`req.params.id`。现在，在下一行中，我们将继续创建一个名为`body`的变量，这就是我在洛达什加载的原因。正文，请求正文，这是要存储更新的地方。如果我想将 Todos 文本设置为其他内容，我会提出一个`patch`请求。我会将`text`属性设置为我想要的 Todo 文本。这里的问题是，有人可以送任何财产；他们可以发送不在待办事项中的属性，或者他们可以发送我们不想让他们更新的属性，例如`completedAt`。`completedAt`属性将会是一个被更新的属性，但是它不会被用户更新，它会在用户更新完成的属性时被我们更新。`completedAt`将由程序生成，这意味着我们不希望用户能够更新它。

为了完成我们希望用户更新的属性，我们将使用`pick`方法，`_.pick`。`pick`方法很神奇；它需要一个对象，我们要传入`req.body`，然后它需要一组你想要获取的属性，如果它们存在的话。例如，如果`text`属性存在，我们希望将其从`req.body`中去掉，添加到 body 中。这是用户应该能够更新的东西，我们将对 completed 做同样的事情。这是用户能够更新的仅有的两个属性；我们不需要用户更新标识或添加猫鼬模型中没有指定的任何其他属性:

```js
app.patch('/todos/:id',(req, res) => {
   var id = req.params.id;
   var body = _.pick(req.body, ['text', 'completed']);
});
```

现在我们已经准备好了，我们可以按照通常的方式开始，通过验证我们的身份来开始工作。没有必要重写代码，因为我们以前已经编写过它，并且我们知道它做什么；我们可以简单的从`app.delete`块复制粘贴到`app.patch`中:

```js
if(!ObjectID.isValid(id)){
   return res.status(404).send();
}
```

现在我们可以继续进入`patch`稍微复杂的部分，它将检查`completed`值并使用该值设置`completedAt`。如果用户将 Todos `completed`属性设置为`true`，我们希望将`completedAt`设置为时间戳。如果他们将其设置为`false`，我们希望清除该时间戳，因为待办事项不会完成。我们将添加一个`if`语句，检查`completed`属性是否为布尔值，并且它在`body`上。我们将使用`_.isBoolean`实用方法来完成这项工作。我们要检查`body.completed`是否为布尔值；如果它是布尔值，并且该布尔值为真，`body.completed`，那么我们将继续运行一些代码。如果它是布尔值并且是`true`，这个代码将会运行，否则如果它不是布尔值或者不是`true`，我们将会运行一些代码。

如果是布尔值并且是`true`，我们将设置`body.completedAt`。我们在 body 上设置的所有内容最终都会在模型中更新。现在，我们不想让用户更新所有的东西，所以我们从`req.body`中挑选了一些，但是我们可以自己做一些修改。我们将设置`body.completedAt`等于当前时间戳。我们将创建一个新的日期，这是我们以前做过的，但是我们将使用一个名为`getTime`的方法，而不是调用`toString`，这是我们在上一节中使用的方法。`getTime`方法返回一个 JavaScript 时间戳；这是自 1970 年 1 月 1 日午夜以来的毫秒数。只是个普通号码。大于零的值是从那一刻起的毫秒数，小于零的值是过去的时间，所以如果我有一个-1000 的数字，那将是 1970 年 1 月 1 日午夜之前的 1000 毫秒。

```js
if(_.isBoolean(body.completed) && body.completed) {
   body.completedAt = new Date().getTime();
} else {

}
```

既然我们已经准备好了，我们可以继续填写`else`条款。在`else`子句中，如果它不是布尔值或者不是`true`，我们将继续设置`body.completed = false`，并且我们还将清除`completedAt`。`body.completedAt`将被设置为等于`null`。当您想从数据库中删除一个值时，只需将其设置为 null:

```js
if(_.isBoolean(body.completed) && body.completed) {
  body.completedAt = new Date().getTime();
} else {
  body.completed = false;
  body.completedAt = null;
}
```

现在我们将继续遵循一个通常的模式:我们将进行一个查询来实际更新数据库。我们将要进行的查询将与我们在`mongodb-update`文件中进行的查询非常相似。在`mongodb-update`里面，我们使用了一种叫做`findOneAndUpdate`的方法。它需要一个查询、更新对象和一组选项。我们将使用一种叫做`findByIdAndUpdate`的方法，它采用一组非常相似的参数。就在这里`server`，我们称之为`Todo.findByIdAndUpdate`。`findByIdAndUpdate`的第一个论点将是`id`本身；因为我们使用的是`findById`方法，所以我们可以简单地传入`id`，而不是传入查询。现在我们可以继续设置对象的值，这是第二个参数。记住，你不能只设置键值对——你必须使用那些 MongoDB 操作符，比如增量，或者在我们的例子中，`$set`。现在，正如我们所探索的，`$set`取一组键值对，这些将被设置。在这种情况下，我们已经生成了对象，如下面的代码所示:

```js
$set: {
   completed:true
}
```

我们只是碰巧在`app.patch`块中生成它，它恰好被称为`body`。所以我将把`$set`运算符设置为等于`body`变量。现在我们可以继续进行最后的选择。这些只是让你调整函数工作方式的一些选项。如果你记得的话，在`mongodb-update`我们把`returnOriginal`设置为`false`；这意味着我们得到了新的对象，更新的对象。我们将使用具有不同名称的类似选项；叫做`new`。它有类似的功能，只是有一个不同的名字，因为这是猫鼬开发者选择的。查询完成后，我们可以添加一个`then`回调和一个`catch`回调，并添加我们的成功和错误代码。如果进展顺利，我们将取回我们的`todo`文档，如果进展不顺利，我们将获得一个错误参数，我们可以继续发送并取回一个`400`状态代码，`res.status(400).send()`:

```js
Todo.findByIdAndUpdate(id, {$set: body}, {new: true}).then((todo) => {

}).catch((e) => {
   res.status(400).send();
})
```

现在，我们需要检查`todo`对象是否存在。如果没有，如果没有`todo`，那么我们将继续并以`404`状态代码`return res.status(404).send()`回应。如果`todo`确实存在，这意味着我们能够找到它并且它被更新了，所以我们可以简单地把它发送回去，`res.send`，我们将把它作为`todo`属性发送回去，其中 todo 等于使用 ES6 语法的`todo`变量:

```js
Todo.findByIdAndUpdate(id, {$set: body}, {new: true}).then((todo) => {

if(!todo)
{
   return res.status(404).send();
}
res.send({todo});
}).catch((e) => {
   res.status(400).send();
})
```

有了这些，我们就完成了。还不算太坏，但比我们以前做过的任何路线都要复杂一点，所以我想一步一步地带大家了解一下。让我们花一点时间来回顾一下我们做了什么以及为什么做。首先，我们做的第一件不寻常的事情是我们创建了`body`变量；这是用户传递给我们的东西的子集。我们不希望用户能够更新他们选择的任何内容。接下来，我们根据已完成的房产更新了`completedAt`房产，最后我们致电`findByIdAndUpdate`。通过这三个步骤，我们可以在打补丁的时候成功更新 Todos。

# 测试 Todos 的补丁调用

现在，为了测试这一点，我将保存`server`文件，并在终端中启动服务器。我将使用`clear`清除终端输出，我们可以运行`npm start`启动应用程序。该应用程序在端口 3000 上启动并运行，因此在邮递员内部，我们可以发出一些请求，看看它是如何工作的。我将切换到待办事项应用程序本地环境，并发出`GET /todos`请求，这样我们就可以获得一个待办事项的真实标识，您可以在这里看到我们测试中的一些旧数据:

![](images/715574f4-2129-456e-9d21-eea992ab313b.png)

我将抓取第二个`text`属性等于`Second test todo`的请求，然后创建一个新的请求，将方法从 GET 改为 PATCH。我们将提供我们的网址，它将是`{{url}}`，然后我们将有`/todos/`我们复制的 ID:

![](images/999eead1-07b4-49df-83b6-12e3e30939a7.png)

现在记住，PATCH 请求是关于更新数据的，所以我们必须提供数据作为请求主体。为了做到这一点，我将转到 Body | raw | JSON。让我们继续对 Todo 进行一些更新。我将设置`"completed": true`，如果你查看 GET /todos 标签，你可以看到第二个 Todo 有一个`completed`值`false`，所以它应该改变并且`completedAt`属性应该被添加。设置好请求后，我将继续发送:

![](images/7f5eb1b0-0f13-4616-863e-cdbb88ba73d7.png)

我们得到我们的`todo`，完成被设置为`true`，并且`completedAt`被设置为时间戳。现在我也可以继续调整这个，将`"completed": true`改为`"completed": false`发送请求；这将设置`"completed": false`并清除`completedAt`。最后，我们可以继续设置`text`属性。我将把它设置回`true`并添加第二个属性`text`，设置为等于`Updates from postman`。我可以发出这个请求，下面我们得到我们的待办事项，看起来就像我们预期的那样:

![](images/972a6f06-70fb-4c95-839d-1909ef468be8.png)

我们有我们的`text`更新；我们也有我们的`completed`更新和显示在`completedAt`字段的时间戳。有了这些，我们现在能够获取、删除、更新和创建 Todo 项——这是四个主要的 CRUD 操作。

接下来我们要做的是编写一些测试来验证`patch`是否如预期的那样工作，这样我们就可以自动运行它们并捕捉代码中的任何回归。现在，就是这样，我们将继续前进，在终端中，做出承诺并推进我们的更改。我们将把它们推到 Heroku，并进行测试。`git status`显示我们只有这两个已更改的文件，这意味着我们可以使用带有`-am`标志的`git commit`进行提交。给这个人的一个好消息是，`Add PATCH /todos/:id`:

```js
**git commit -am 'Add PATCH /todos/:id'** 
```

我将提交并将其推送到 GitHub，一旦它在 GitHub 上，我们就可以使用以下命令将其推送到 Heroku:

```js
**git push heroku master** 
```

记住，主分支是 Heroku 唯一可以访问的分支；在本书中，我们不会使用分支，但是如果您已经知道分支，并且遇到了任何问题，您确实需要推送到 Heroku 主分支来重新部署您的应用程序。就像我说的，如果你像我一样使用所有的命令，这不是问题。

现在应用部署好了，我们可以继续打开了；我们将通过在邮递员内部发出请求来打开它。我将切换到 Todo 应用程序 Heroku 环境，然后我将在 GET /todos 内部启动请求:

![](images/06715bc4-eb01-4126-b230-eb5d6ce81706.png)

这些都是 Heroku 上提供的 Todos。我要抓住第一个。我将转到 PATCH 请求，交换出 ID，并保留相同的正文。我要设置`"completed": true`和`"text": "Updates from postman"`:

![](images/20e9d378-b340-4006-aa2a-a540ce8bb0c1.png)

当我们发送它时，我们会得到更新的 Todo。`completed`看起来很棒，`completedAt`看起来很棒，`text`也很棒。现在，我将继续将它添加到我的收藏中；接下来补丁调用会派上用场，所以我会单击另存为，给它起一个我们所有人都用过的名字，HTTP 方法，后跟 URL。我将把它保存到我们现有的收藏中，托多应用:

![](images/79c288af-be83-462b-b760-5893ecc28dab.png)

有了这些，我们就完了；我们有我们的`patch`路线工作，现在是时候进入下一部分，我们将在那里测试这段代码。

# Testing PATCH /todos/:id

在这一节中，我们，嗯，我想更恰当的是你，将编写两个测试用例来验证`patch`是否如预期的那样工作。我们将采取一个未完成的 Todo 并使其完整，我们将采取第二个完整的 Todo 并使其不完整。

现在，为了做到这一点，我们需要调整`server.test`文件中的种子数据。`server.test`文件中的种子数据权限是两个 Todo 项；他们都没有指定`completed`属性，这意味着它将默认为`false`。对于第二项，我们将继续设置它。我们将设置`completed: true`并且我们也将设置`completedAt`等于我们想要的任何值。你可以选择任何号码。我将继续使用`333`:

```js
const todos = [{
   _id: new ObjectID(),
   text: 'First test todo'
},{
   _id: new ObjectID(),
   text: 'Second test todo',
   completed: true,
   completedAt: 333
}];
```

现在我们有两个 Todos，让我们双向切换。首先，我将帮助您创建描述一个`It`块，这样我们就在同一个页面上了，但是您将负责填写实际的测试用例。这部分基本上是一个挑战，因为我们以前做过很多这样的事情。首先是`describe`块。我们要去`describe`这组测试；我们将使用后跟 URL 的方法来做到这一点，然后我们可以继续添加我们的函数，然后我们可以定义我们的两个测试用例:

```js
describe('PATCH /todos/:id', () => {

});
```

第一个测试将采用我们的第一个 Todo，并将其`text`设置为其他值，我们将`completed`从`false`更改为`true`、`it('should update the todo')`。我们可以用`done`参数来提供我们的功能，我将在稍后留下一些评论，让您知道我希望您如何实现这一点。第二个测试是切换第二个 Todo，其中`completed`值已经等于`true`，然后是`it('should clear completedAt when todo is not completed')`。这个测试用例将确保当我们继续并移除`completed`状态时，将其设置为`false`，`completedAt`被清除。现在，对于第一个测试用例，您要做的是抓取第一个项目的 ID，`grab id of first item`，然后您要发出我们的补丁请求；您将提供适当的 URL，其中包含 ID，并且您将使用 send 发送一些数据作为请求主体。对于这个，我想让你更新文本，把它设置成你喜欢的任何值，然后你就可以从`set completed equal`到`true`了。现在，一旦你发送了它，你就准备好做出你的断言，你将使用基本系统做出一个断言，断言你得到一个`200`状态代码回来，你将做出一个定制的断言。自定义断言将验证响应主体的`text`属性是否等于您发送的文本`text is changed`。你要验证`completed`是`true`，你也要验证`completedAt`是一个数字，你可以使用`expect`里面的`.toBeA`方法来完成。现在，对于第二个测试，我们要做一些类似的事情，但是我们只是要去另一个方向；我们要去`grab id of second todo item`，你要把`text`更新到不同的东西，你要把`completed`设置为`false`。然后你可以做出你的断言。我们将再次期待`200`对这一个，我们将期待响应体现在代表那些变化，文本被改变为你碰巧选择的任何内容。我还想让你检查一下`completed`现在是`false`并且检查一下`completedAt`是`null`，你可以使用`.toNotExist`方法进行断言。这是您完成测试套件所需要做的。完成后，我希望您运行`npm test`并确保两个测试用例都通过。

# 测试 1 -完成未完成的任务

让我们先填写第一个测试用例，我将通过获取正确的 ID 来开始工作。让我们创建一个名为`hexId`的变量，将它设置为等于第一个 todos，`_id`属性，我们将调用`toHexString`来获取我们可以传入到 URL 的字符串。接下来，我将继续创建一些虚拟文本；这将是新的更新文本。让我们制作一个名为`text`的变量，并将其设置为您喜欢的任何值。`This should be the new text`。现在我们可以使用`request`向我们的快速应用程序发出请求。我们将使用`patch`方法；希望你能够自己解决这个问题，如果你没有，也许你使用了超级测试的文档，因为我没有明确告诉你如何进行`patch`调用。接下来，我们将使用模板字符串作为我们的网址`/todos/`，然后我们将注入`hexId`。现在，在我们做出断言之前，我们确实需要发送一些数据，所以我将调用`send`，传递数据。这将是我们想要改变的事情。对于这个测试，我们确实想将`completed`设置为等于`true`。我要设置`completed: true`，我们确实想更新文本，所以我会将`text`设置为等于上面的`text`变量，我可以使用 ES6 始终省略这一部分:

```js
it('should update the todo', (done) => {
   var hexId = todos[0]._id.toHexString();
   var text = 'This should be the new text';

   request(app)
   .patch(`/todos/${hexId}`)
   .send({
         completed: true,
         text
   })
});
```

现在我们已经发送到位，我们可以开始作出我们的断言。第一个很简单，我们只期待 200 个。我将`expect(200)`作为返回状态代码，在我们添加自定义断言之前，我们可以调用`end`，传入`done`。现在，我们需要做的最后一件事是对返回的数据做出断言。我要调用`expect`，传入一个函数；我们现在所知道的这个函数被响应调用，我们可以进行自定义断言。我们将对`text`、`completed`和`completedAt`进行断言。首先是`text`。我们使用`expect(res.body.todo.text).toBe(text)`，上面定义的变量。如果这等于返回的数据，那么我们就可以走了。

接下来，让我们对`completed`属性做一些断言。我们将使用`expect(res.body.todo.completed)`并使用`.toBe(true)`检查其真实性。我们将`completed`设置为`true`，所以它应该从`false`更改为`true`。现在，我们将在自定义期望调用中做出的最后一个断言是关于`completedAt`的断言，确保它是一个数字。我们将使用`expect(res.body.todo.completedAt)`等于使用`.toBeA`的数字，引号内的`number`类型:

```js
it('should update the todo', (done) => {
   var hexId = todos[0]._id.toHexString();
   var text = 'This should be the new text';

   request(app)
   .patch(`/todos/${hexId}`)
   .send({
         completed: true,
         text
   })
   .expect(200)
   .expect((res) => {
         expect(res.body.todo.text).toBe(text);
         expect(res.body.todo.completed).toBe(true);
         expect(res.body.todo.completedAt).toBeA('number');
   })
   .end(done);
});
```

有了这些，我们的第一次测试就完成了。我们可以继续删除这些评论，并通过在终端中运行它来验证它是否有效。我们的第二次测试将会失败；没关系，只要第一个通过，我们就可以继续前进。我要运行`npm test`，这将触发测试套件。我们可以看到我们的第一次`PATCH`测试成功；这是我们刚刚填写的，我们的第二个失败了。两秒钟后我们将超时，这是意料之中的，因为我们从未呼叫`done`:

![](images/d8a67b4f-4cca-4143-8b7e-c196c25b3555.png)

现在第一个已经就位，我们可以继续填写第二个。现在，这两个测试的代码将非常非常相似。现在，由于我们刚刚编写了代码，并且确切知道它的功能，我们可以复制并粘贴它。我不是复制粘贴不懂代码的粉丝，但我是高效的粉丝。因为我知道代码是做什么的，所以我可以把它直接粘贴到第二个测试用例中，现在我们可以继续进行一些更改。

# 测试 2 -使完整的待办事项不完整

我们想要抓取第二个 Todo 项的`hexId`变量，而不是抓取`hexId`变量或第一个 Todo 项，然后我们需要做的下一件事是更新我们正在发送的数据。我们不想将`completed`设为等于`true`；我们已经在上面手动完成了。这一个我们正试图设置为`false`。我们还将更新`text`，这样我们就可以保留它。我将继续稍微调整文本值，在末尾添加几个感叹号。接下来是断言。我们仍然期待`200`成为返回的状态代码。那部分很棒，我们仍然期待`text`和`text`一样。然而，对于已完成的，我们期望那是`false`并且我们不期望`completedAt`是一个数字；它原本是一个数字，但在这次更新后，它应该已经被清除，因为 Todo 不再完成。我们可以用`toNotExist`来断言`completedAt`不存在:

```js
it('should clear completedAt when todo is not completed', (done) => {
   var hexId = todos[1]._id.toHexString();
   var text = 'This should be the new text!!';

   request(app)
   .patch(`/todos/${hexId}`)
   .send({
         completed: false,
         text
   })
   .expect(200)
   .expect((res) => {
         expect(res.body.todo.text).toBe(text);
         expect(res.body.todo.completed).toBe(false);
         expect(res.body.todo.completedAt).toNotExist();
   })
   .end(done);
});
```

有了这些，我们的测试用例就完成了。我们现在可以删除这些评论，保存文件，并从终端重新运行。我将重新运行测试套件:

我们两个`PATCH`测试都通过了。现在，你可能已经注意到了，对于`patch`我们没有为无效的 objectid 或者没有找到的 objectid 编写那些测试用例；你可以添加这些，但是到目前为止我们已经做了很多次了，我不认为这是一个必要的练习。然而，这两个测试用例确实验证了我们的`patch`方法如预期的那样工作，尤其是当涉及到`patch`完成所有事情所需的稍微复杂的逻辑时。尽管如此，我们已经完成了对最后一条路线的测试。

我们可以继续，做出承诺，进入这一章的最后一节。在终点站，我要跑了。我们将看到我们有一个修改过的文件，`server.test`文件，看起来很棒。我们可以用`git commit`和`-am`旗来做承诺，`Add tests for PATCH /todos/:id`:

```js
**git commit -am 'Add tests for PATCH /todos/:id'**  
```

我将继续进行这个提交，然后我将花一点时间把它推送到 GitHub，这样我们就完成了。下一节是本章的最后一节，在这一节中，您将学习如何在本地使用一个单独的测试数据库，这样在运行测试时就不会总是擦除开发数据库中的数据。

# 创建测试数据库

现在，我们所有的 Todo 路线都已经设置好并经过测试，在最后一节中，我们将探讨如何为我们的应用程序创建一个单独的测试数据库。这意味着当我们运行测试套件时，我们不会删除`TodoApp`数据库中的所有数据。我们将在`Test`和`TodoApp`旁边有一个单独的数据库，用于测试数据库。

现在，为了设置所有这些，我们需要一种方法来区分本地运行我们的应用程序和本地运行我们的测试套件，这正是我们要开始的地方。整个问题源于这样一个事实:在我们的`mongoose.js`文件中，我们要么使用`MONGODB_URI`环境变量，要么使用 URL 字符串。这个字符串用于测试和开发，当我说测试时，我指的是当我们运行我们的`test`脚本时，当我说开发时，我指的是当我们在本地运行我们的应用程序时，这样我们就可以在像邮递员这样的工具中使用它。我们真正需要的是一种在本地设置环境变量的方法，所以我们总是使用`MONGODB_URI`变量，我们从来没有像在`mongoose.js`文件中那样的默认字符串。现在，为了做到这一点，我们将看看一个实际上非常特殊的环境变量:它是`process.env.NODE_ENV`，您不必编写这段代码。我马上就要删除它了。这个`NODE_ENV`环境变量被 Express 库所普及，但是现在它已经被几乎所有的节点托管公司所采用。例如，默认情况下，Heroku 将该值设置为字符串`production`。这意味着我们总共将有三个环境。我们已经有了`production`环境。这就是我们在 Heroku 上所说的应用；当我们在本地运行我们的应用程序时，我们将有一个`development`环境，当我们通过摩卡运行我们的应用程序时，我们将有一个`test`环境。这意味着我们将能够为这三者设置不同的`MONGODB_URI`值，创建一个单独的测试数据库。

为了开始工作，我们将在最上面的`server.js`文件中添加一些代码。稍后我们将把这段代码移出`server.js`，但是现在我们将把它放在顶部。让我们创建一个名为`env`的变量，并将其设置为`process.env.NODE_ENV`:

```js
var env = process.env.NODE_ENV;
```

现在，这个变量目前只设置在 Heroku 上；我们没有在本地设置这个环境变量。环境变量通常不仅仅用于节点。你的机器可能有将近 24 个环境变量，告诉计算机各种事情:某些程序存在于哪里，你想使用什么版本的库，诸如此类的东西。然而，`NODE_ENV`变量是我们在开发和测试环境的`package.json`文件中需要配置的。然后，就在下面，我们将能够根据环境添加一些`if else`语句来配置我们的应用程序。如果我们在开发中，我们将使用一个数据库，如果我们在测试中，我们将使用不同的数据库。现在要在`package.json`内部启动，我们需要调整`test`脚本，设置`NODE_ENV`环境变量。您可以通过将多个命令链接在一起来设置环境变量。我们将要编写的代码也将有一个针对 Windows 的后备，因此如果您在 macOS、Linux 或 Windows 上，您可以编写完全相同的代码行。这将适用于所有地方，包括 Heroku。这里的目标是在我们运行测试套件之前将`NODE_ENV`设置为等于`test`。为此，我们将从使用`export`命令开始。`export`命令在 macOS 和 Linux 中都有。这是完成它的方法，即使你在 Windows 中也要键入这个，因为当你部署到 Heroku 时，你将使用 Linux。我们将导出`NODE_ENV`，将其设置为等于`test`:

```js
"scripts": {
   "start": "node server/server.js",
   "test": "export NODE_ENV = test mocha server/**/*.test.js",
   "test-watch": "nodemon --exec 'npm test'"
}
```

现在，如果你在 Windows 上，`export`命令会失败；`export`将要触发一个错误，沿着导出命令的思路找不到东西。对于 Windows 用户，我们将添加这个`||`块，我们称之为`SET`。`SET`和导出是一样的只是它的命令是 Windows 版本。紧接着，我们将提供完全相同的参数`NODE_ENV=test`。在最后的测试之后，我们将添加两个&符号来将这些命令链接在一起:

```js
"scripts": {
   "start": "node server/server.js",
   "test": "export NODE_ENV = test || SET NODE_ENV = test && mocha server/**/*.test.js",
   "test-watch": "nodemon --exec 'npm test'"
}
```

所以，让我们继续分析将要发生的事情。如果你在 Linux 上，你要运行`export`命令；`SET`命令永远不会运行，因为第一个命令运行了。然后我们将执行第二个命令，运行`mocha`。如果你在 Windows 上，`export`命令将失败，这意味着你将运行第二个命令；无论哪种方式，你都可以得到`NODE_ENV`变量集，然后最后你会连接到`mocha`上。有了这个，我们现在有一种方法可以在`package.json`中设置我们的`NODE_ENV`变量。

This is a quick cross-OS update; as you can see here, we have a modified version of that `test` script:
`"test": "export NODE_ENV=test || SET \"NODE_ENV=test\" && mocha server/**/*.test.js"`
The original test script had a problem on the Windows side of things: it would set the environment variable equal to the string test with a space at the end, as opposed to just the string `test`. In order to properly set the `env` variable to just `test`, and not `test`, we're going to be wrapping the entire set argument inside of quotes, and we're escaping those quotes since we use quotes inside of our JSON file. This command is going to work on Linux, macOS, and Windows.

现在我实际上不打算为`scripts`添加`start`脚本。用于开发环境的`start`脚本只是默认脚本。我们将在 Heroku 上将它设置为生产，我们将在我们的`test`脚本中将其设置为`test`，在这个脚本中，我们将在`server.js`中默认它，因为我们倾向于运行文件而不实际通过`start`脚本。就在`server.js`文件中，我将默认设置为`development`。如果是生产的话`NODE_ENV`会被设置，如果是测试的话`development`会被设置，如果是开发的话`NODE_ENV`不会被设置，会用到`development`，也就是说我们准备增加一些`if`语句。`if(env)`是`development`我们要做的事情。我们要做的是设置 MongoDB 的网址。`else if (env)`是`test`的环境。在这种情况下，我们还想设置一个自定义数据库网址:

```js
if(env === 'development') {

} else if(env === 'test') {

}
```

现在我们可以开始实际设置环境变量了。我们在整个应用程序中使用了两个环境变量，这两个变量都是在 Heroku 上设置的，因此没有理由担心那个环境，即生产环境。我们有我们的`PORT`环境变量，我们有我们的`MONGODB_URI`变量。在`server.js`内部，如果我们在开发环境中，我们将继续设置`process.env.PORT=3000`。这意味着我们实际上可以从`port`变量中移除默认值；不需要有默认值，因为`PORT`已经要设置了。它将被设置在 Heroku 上用于生产，它将被本地设置为`development`，并且就在`else if`块中，我们将为我们的最终环境，测试环境设置它，将它设置为等于`3000`。在`mongoose.js`内部，我们要做的是为`development`和`test`设置一个`MONGODB_URI`环境变量，这与我们在生产中使用的变量名称完全相同。我将删除我们的缺省值，取出字符串并将其剪切掉，这样它就在我的剪贴板中了，然后我可以删除设置该缺省值的所有多余代码，剩下的只是对环境变量的引用:

```js
mongoose.connect(process.env.MONGODB_URI);
```

在`server.js`内部，我们现在可以为两个环境`process.env.MONGODB_URI`设置环境变量，我们将把它设置为等于我刚才复制的字符串`mongodb://localhost:27017/TodoApp`。我们正在使用`TodoApp`数据库。

现在，在下面的`else if`块中，我们可以将`process.env.MONGODB_URI`设置为等于我们刚刚复制的字符串，但是我们将把它设置为等于`TodoApp`数据库，而不是将其设置为等于`TodoAppTest`数据库:

```js
if(env === 'development') {
  process.env.PORT = 3000;
  process.env.MONGODB_URI = 'mongodb://localhost:27017/TodoApp';
} else if(env === 'test') {
  process.env.PORT = 3000;
  process.env.MONGODB_URI = 'mongodb://localhost:27017/TodoAppTest';
}
```

当我们在测试模式下运行我们的应用程序时，我们将使用一个完全不同的数据库，所以它不会删除我们用于开发的数据库。为了测试一切都如预期的那样工作，就在`env`变量的正下方，我要做的就是使用`console.log`注销环境变量。我将打印带有两个星号的字符串`env`，以便在终端输出中很容易发现，然后我将继续传递`env`变量作为第二个参数:

```js
console.log('env *****', env);
```

现在我们可以继续测试一切是否如预期的那样运行。在终端内部，我将使用以下命令启动我们的应用程序:

```js
**node server/server.js** 
```

我们得到的`env`等于`development`，这正是我们所期望的:

![](images/fe710e73-932e-4ea9-aca3-636d2fc4611b.png)

现在我们可以在《邮差》中玩它了。在邮递员内部，我将切换到我的本地环境，托多应用本地，然后我将继续获取我所有的托多，你可以看到我们有一些剩余的测试数据:

![](images/f3e33401-f769-49cf-898a-1fb19f534bf1.png)

我想做的是继续调整第一个，让它与众不同。然后我们将运行我们的测试，并确保调整后的 Todo 仍然显示，因为当我们运行测试时，我们不应该访问同一个数据库，所以这些数据都不应该被更改。我将复制第一个项目的 id，将其移动到我的`PATCH`呼叫中。我正在更新`text`属性和`completed`属性，所以这很好，我不需要更改。我将继续交换 URL 中的 ID，发送呼叫，现在我们有了更新后的 Todo 和`Updates from postman`的`text`属性:

![](images/ab22622f-3104-4e9e-a66b-a3a230dc96a3.png)

接下来，我将进入终端，关闭节点服务器，并使用`npm test`运行我们的测试:

![](images/3e10b405-a47c-4baa-b08b-b5702220d4a3.png)

我们将`env`变量设置为`test`，然后它在测试套件中运行；我们所有的测试都通过了，这太棒了。关于我们设置的是否有效的真正测试是，我们是否再次启动服务器，并尝试从`development`数据库获取数据。

在邮递员内部，我将最后一次发出`GET /todos`请求，就在那里，我们的待办事项数据仍然如预期的那样显示。即使测试套件确实运行了，这也没有关系，因为它不再擦除这个数据库，现在它正在擦除一个全新的数据库，您可以在 Robomongo 中查看。如果我点击连接并点击刷新，我们现在有两个`TodoApp`数据库:我们有`TodoApp`和`TodoAppTest`。这太棒了。一切都准备好了，我们准备开始了。

现在，在我们走之前，我想做的是把所有这些代码从`server.js`中取出，并把它移到别的地方；它并不真正属于这里，它只会使服务器文件比它需要的更复杂。在`server`文件夹中，我将创建一个名为`config`的全新文件夹，在`config`文件夹中，我将创建一个名为`config.js`的新文件，在里面我们可以进行所有的过程环境变量配置。我将复制所有代码，并用对该文件的`require`调用替换它。这是一个相对文件，所以我们将转到`/config/config`:

```js
require('./config/config');
```

在`config.js`内部，我们现在可以复制代码并删除与`console.log`相关的行。让我们通过提交我们的更改并部署到 Heroku 来结束这一部分。

在终端内部，我将清除终端输出，然后我们可以继续运行`git status`来查看我们更改了哪些文件，我们有相当多的文件:

![](images/a5e2bfee-c91b-4d80-a530-2e908b981b26.png)

我们在`server`目录下也有一些新文件。我将使用`git add .`将所有这些添加到下一个提交中，我将再次使用`git status`来确认一切看起来都很好。现在我们已经为提交做好了准备，我可以继续做了，`git commit`用`-m`旗提供我们的信息，`Setup separate test and development envs`:

```js
**git commit -m 'Setup separate test and development envs'**
```

我还将把它部署到 Heroku，这样我们就可以验证我们没有破坏那里的任何东西:

```js
**git push heroku master**
```

一旦完成了这一步，我们将进入 Postman 并向 Heroku 应用程序发出`GET /todos`请求，从而结束这一部分。在 Postman 内部，我将把环境从 Todo 应用本地切换到 Todo 应用 Heroku，我们可以发出请求:

![](images/eac61e9b-7445-4495-8747-d1ae04f00551.png)

现在，如前面的截图所示，我们从真实的数据库中获得了我们的两个`todo`项，这意味着 Heroku 应用程序上没有任何东西被破坏，也不应该被破坏——从技术上来说，我们没有改变任何东西。在 Heroku 中，我们所做的就是运行`config`文件，但是我们没有使用默认值，因为它已经设置好了，并且它不会传递这些语句中的任何一个，因为`env`变量将等于字符串生产，所以就 Heroku 而言，没有任何变化，它显示了这一点，因为数据仍然如预期的那样返回。

这一节到此为止，这一章到此为止。在这一节中，我们了解了 MongoDB、Mongoose APIs、Postman、测试、路由以及各种各样的优秀特性。在下一章中，我们将通过添加身份验证来总结 Todo 应用程序。

# 摘要

在本章中，我们学习了 Mongoose 查询和 ID 验证。接下来，我们研究了获取单个资源，并着手应对一些挑战。在将该应用编程接口部署到 Heroku 并探索了 Postman 环境之后，我们了解了删除资源的不同方法。最后，我们研究了创建测试数据库。

在下一章中，我们将了解带有 Socket.io 的实时网络应用