Using Node to Access the Filesystem <link rel="stylesheet" href="css/style.css" type="text/css">   .koboSpan { -webkit-text-combine: inherit; }

# 使用节点访问文件系统

"We have persistent objects - they're called files." – *Ken Thompson*

一个文件就是一个数据块，通常保存在某些硬盘介质（如硬盘驱动器）上。文件通常由字节序列组成，其编码映射到其他模式，如数字序列或电脉冲。编码的数量几乎是无限的，常见的有文本文件、图像文件和音乐文件。文件具有固定长度，要读取，其字符编码必须由某种读取器（如 MP3 播放器或文字处理器）解密。

当一个文件在传输过程中，在从某个存储设备中被虹吸出来后通过电缆移动时，它与通过导线运行的任何其他数据流没有什么不同。它以前的固态只是一个稳定的蓝图，可以轻松无限地复制。

我们已经看到了事件流如何反映通知节点设计的核心设计原则，其中字节流将从其他流中读取和写入，并通过管道传输到其他流中，从而发出相关的流事件，例如`end`。文件很容易被理解为数据的容器，充满了可以部分或整体提取或插入的字节。

除了与流的自然相似性之外，文件还显示对象的特征。文件具有描述可用于访问具有属性和关联访问方法的文件内容数据结构的接口的属性。

**文件系统**反映了文件应该如何组织的一些概念—如何识别、存储在哪里、如何访问等等。UNIX 用户常用的文件系统是**UFS**（**UNIX 文件系统**），而 Windows 用户可能熟悉**NTFS**（**新技术文件系统**）。

有趣的是，Plan 9 操作系统的设计者（包括*Ken Thompson*在内的团队）决定将*所有*控制接口表示为文件系统，以便将所有系统接口（跨设备、跨应用程序）建模为文件操作。将文件视为一流公民是 UNIX 操作系统也采用的理念；使用文件作为对命名管道和套接字的引用，除其他外，为开发人员在形成数据流时提供了巨大的能力。

文件对象也很强大，它们所在的系统公开了基本的 I/O 接口，这些接口必须易于使用、一致且非常快速。毫不奇怪，Node 的`file`模块公开了这样一个接口。

我们将从以下两个角度考虑在节点中处理文件：文件数据内容如何流入和流出（读取和写入），以及文件对象的属性如何修改，例如更改文件权限。

此外，我们还将介绍节点服务器在接受文件上传和服务文件请求方面的职责。通过使用目录迭代器和文件服务器的示例，节点的文件系统 API 的完整范围和行为应该变得清晰。

最后，我们将把 JavaScript 带回桌面，使用 GitHub 的 Electron 框架制作我们自己的桌面应用程序，一个简单的文件浏览器。

# 目录，并对文件和文件夹进行迭代

通常，文件系统将文件分组到集合中，通常称为目录。一个是在目录中导航以查找单个文件。一旦找到目标文件，文件对象必须由一个接口包装，该接口公开文件内容以供读取和写入。

由于节点开发通常涉及创建同时接受和发送文件数据的服务器，因此应该清楚地知道，在这个活跃且重要的 I/O 层上，传输速度有多重要。如前所述，文件也可以理解为对象，对象具有某些属性。

# 文件类型

UNIX 系统上通常会遇到六种类型的文件：

*   **普通文件**：包含一维字节数组，不能包含其他文件。
*   **目录**：这些也是以特殊方式实现的文件，可以描述其他文件的集合。
*   **套接字**：用于 IPC，允许进程交换数据。
*   **命名管道**：像`ps aux | grep node`这样的命令会创建一个管道
    ，一旦操作终止，该管道就会被销毁。命名管道是持久的和可寻址的，可以由多个进程无限期地使用它们。
*   **设备文件**：这些是 I/O 设备的表示，即接受数据流的进程；`/dev/null`通常是字符设备文件（接受串行 I/O 流）的示例，`/dev/sda`是表示数据驱动器的块设备文件（允许对数据块进行随机访问 I/O）的示例。
*   **链接**：这是指向其他两种类型文件的指针：硬链接和符号链接。硬链接直接指向另一个文件，与目标文件无法区分。符号链接是间接指针，可与普通文件区分开来。

大多数节点文件系统交互只会遇到前两种类型，第三种仅通过节点 API 间接实现。对其余类型的更深入解释超出了本文讨论的范围。但是，Node 通过`file`模块提供了一整套文件操作，读者至少应该对文件类型的完整范围和功能有所了解。

研究命名管道将有助于读者了解 Node 是如何设计用于处理流和管道的。从终端尝试此操作：

```
$ mkfifo namedpipe
```

如果您得到当前目录`-ls -l`的扩展列表，将显示类似于此的列表：

```
prw-r--r-- 1 system staff 0 May 01 07:52 namedpipe
```

注意文件模式下的`p`标志（第一段，带破折号）。您已经创建了一个名为`(p)ipe`的。现在，将其输入同一终端，将一些字节推入命名管道：

```
echo "hello" > namedpipe
```

这一过程似乎已经暂停。它没有像水管一样的水管，两端都必须打开才能完成冲洗内容物的工作。我们已经输入了一些字节。。。现在怎么办？

打开另一个终端，导航到同一目录，然后输入以下内容：

```
$ cat namedpipe.
```

当`namedpipe`的内容被刷新时，`hello`将出现在第二个终端中。请注意，第一个端子不再挂起，而是已冲洗。如果您还记得[第 3 章](03.html)中关于节点流的讨论，*在节点和客户端之间传输数据，*您会注意到与 Unix 管道有一些相似之处，这是有意的。

# 文件路径

Node 提供的大多数文件系统方法都需要对文件路径进行操作，为此，我们使用了`path`模块。我们可以用这个模块组合、分解和关联路径。不要手动滚动您自己的路径字符串拆分、正则化和连接例程，而是尝试通过将路径操作委托给此模块来规范化您的代码：

*   使用源不可信或不可靠的文件路径字符串时，请使用`path.normalize`，以确保格式可预测：

```
const path = require('path'); 
path.normalize("../one////two/./three.html"); 
// -> ../one/two/three.html 
```

*   在路径段之外构建单个路径时使用`path.join`：

```
path.join("../", "one", "two", "three.html"); 
// -> ../one/two/three.html 
```

*   使用`path.dirname`从路径中剪下目录名：

```
path.dirname("../one/two/three.html"); 
// ../one/two
```

*   使用`path.basename`操纵最终路径段：

```
path.basename("../one/two/three.html"); 
// -> three.html 

// Remove file extension from the basename 
path.basename("../one/two/three.html", ".html"); 
// -> three 
```

*   使用`path.extname`从最后一个句点（`.`到路径字符串的末尾进行切片：

```
var pstring = "../one/two/three.html"; 
path.extname(pstring); 
// -> .html 
```

*   使用`path.relative`查找从一个绝对路径到另一个绝对路径的相对路径：

```
path.relative( 
  '/one/two/three/four',  
  '/one/two/thumb/war' 
); 
// -> ../../thumb/war 
```

*   使用`path.resolve`将路径指令列表解析为绝对路径：

```
path.resolve('/one/two', '/three/four'); 
// -> /three/four 
path.resolve('/one/two/three', '../', 'four', '../../five') 
// -> /one/five 
```

将传递给`path.resolve`的参数视为一系列`cd`调用：

```
cd /one/two/three 
cd ../ 
cd four 
cd ../../five 
pwd 
// -> /one/five 
```

如果传递给`path.resolve`的参数列表无法传递绝对路径，则也将使用当前目录名。例如，考虑到我们是在 T1。

```
path.resolve('one', 'two/three', 'four'); 
// -> /users/home/john/one/two/three/four
```

这些参数解析为相对路径`one/two/three/four`，因此以当前目录名为前缀。

# 文件属性

文件对象公开其某些属性，包括一组关于文件数据的有用元数据。例如，如果使用节点运行 HTTP 服务器，则需要确定通过 GET 请求的任何文件的文件长度。确定文件最后一次修改的时间可用于多种类型的应用程序。

要读取文件的属性，请使用`fs.stat`：

```
fs.stat("file.txt", (err, stats) => { 
  console.log(stats); 
}); 
```

在前面的示例中，`stats`将是通过属性映射描述文件的`fs.Stats`对象：

```
  dev: 2051, // id of device containing this file 
  mode: 33188, // bitmask, status of the file 
  nlink: 1, // number of hard links 
  uid: 0, // user id of file owner 
  gid: 0, // group id of file owner 
  rdev: 0, // device id (if device file) 
  blksize: 4096, // I/O block size 
  ino: 27396003, // a unique file inode number 
  size: 2000736, // size in bytes 
  blocks: 3920, // number of blocks allocated 
  atime: Fri May 3 2017 15:39:57 GMT-0500 (CDT), // last access 
  mtime: Fri May 3 2017 17:22:46 GMT-0500 (CDT), // last modified 
  ctime: Fri May 3 2017 17:22:46 GMT-0500 (CDT)  // last status change 
```

`fs.Stats`对象公开了几种访问文件属性数据的有用方法：

*   使用`stats.isFile`检查标准文件
*   使用`stats.isDirectory`检查目录
*   使用`stats.isBlockDevice`检查块类型设备文件
*   使用`stats.isCharacterDevice`检查字符类型设备文件
*   在`fs.lstat`之后使用`stats.isSymbolicLink`查找符号链接
*   使用`stats.isFIFO`标识命名管道
*   使用`stats.isSocket`检查插座

还有两种`stat`方法可用：

*   `fs.fstat(fd, callback)`：与`fs.stat`类似，只是传递了文件描述符`fd`而不是文件路径
*   `fs.lstat(path, callback)`：符号链接上的`fs.stat`将为目标文件返回`fs.Stats`对象，而`fs.lstat`将为链接文件本身返回`fs.Stats`对象

以下两种方法简化了文件时间戳操作：

*   `fs.utimes(path, atime, mtime, callback)`：在`path`处更改文件的访问和修改时间戳。文件的访问和修改时间存储为 JavaScript`Date`对象的实例。例如，`Date.getTime`将返回自 1970 年 1 月 1 日午夜（UTC）以来经过的毫秒数。
*   `fs.futimes(fd, atime, mtime, callback)`：更改文件描述符`fd`上的访问和修改时间戳；类似于`fs.utimes`。

More information about manipulating dates and times with JavaScript can be found at:
[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date).

# 打开和关闭文件

管理节点项目的非官方规则之一是不要不必要地从现有操作系统实现细节中抽象出来。正如我们将看到的，对文件描述符的引用出现在节点的文件 API 中。对于**POSIX**（**便携式操作系统接口**），文件描述符只是唯一引用特定文件的（非负）整数。由于 Node 在 POSIX 上对其文件系统方法建模，所以毫不奇怪，文件描述符在 Node 中表示为整数。

回顾我们关于如何将设备和操作系统的其他元素表示为文件的讨论，标准 I/O 流（`stdin`、`stdout`、`stderr`）也会有文件描述符。事实上，情况就是这样：

```
console.log(process.stdin.fd); // 0 
console.log(process.stdout.fd); // 1 
console.log(process.stderr.fd); // 2 

fs.fstat(1, (err, stat) => { 
  console.log(stat); // an fs.Stats object 
}); 
```

文件描述符很容易获得，并且是传递文件引用的方便方法。让我们通过研究如何使用 Node 执行低级文件打开和关闭操作来了解文件描述符是如何创建和使用的。随着本章的深入，我们将研究到文件流的更精细的接口。

# 打开（路径、标志、[模式]、回调）

正在尝试在`path`处打开文件。`callback`将接收任何异常，操作作为其第一个参数，文件描述符作为其第二个参数。在这里，我们打开一个文件进行读取：

```
fs.open("path.js", "r", (err, fileDescriptor) => { 
  console.log(fileDescriptor); // An integer, like `7` or `23` 
}); 
```

`flags`接收一个字符串，指示调用者希望对返回的文件描述符执行的操作类型。其含义应明确：

*   `r`：打开文件读取，如果文件不存在则抛出异常。
*   `r+`：打开文件进行读写操作，如果文件不存在则抛出异常。
*   `w`：打开文件进行写入，如果文件不存在则创建文件，如果文件存在则将文件截断为零字节。
*   `wx`：与`w`类似，但以独占方式打开文件，即如果文件已经存在，则**不会被**打开，打开操作失败。如果多个进程可能同时尝试创建同一个文件，这将非常有用。
*   `w+`：打开一个文件进行读写，如果不存在则创建文件，如果存在则将文件截断为零字节。
*   `wx+`：如`wx`（和`w`），额外打开文件进行读取。
*   `a`：打开文件进行追加，如果文件不存在，则创建文件。
*   `ax`：与**a**类似，但以独占方式打开文件，即如果文件已经存在，则**不会被打开**，打开操作失败。如果多个进程可能同时尝试创建同一个文件，这将非常有用。
*   `a+`：打开一个文件进行读取和追加，如果该文件不存在，则创建该文件。
*   `ax+`：如`ax`（和`a`），额外打开文件进行读取。

当操作可能创建新文件时，使用可选的`mode`以八进制数字设置此文件的权限，默认为 0666（有关八进制权限的详细信息，请参阅`fs.chmod`：

```
fs.open("index.html", "w", 755, (err, fd) => { 
   fs.read(fd, ...); 
}); 
```

# fs.关闭（fd，回调）

`fs.close(fd, callback)`方法关闭一个文件描述符。回调函数接收一个参数，即调用中抛出的任何异常。关闭所有已打开的文件描述符是一个好习惯。

# 文件操作

节点实现了标准 POSIX 函数，用于处理 UNIX 用户熟悉的文件。我们将不深入介绍这个广泛集合中的每个成员，而是重点介绍一些常用的示例。特别是，我们将深入讨论打开文件描述符和操作文件数据、读取和操作文件属性以及在文件系统目录中移动的方法。尽管如此，我们还是鼓励读者尝试一下整个集合，下面的列表简要描述了这一集合。请注意，所有这些方法都是异步的、非阻塞的文件操作。

# fs.rename（旧名称、新名称、回调）

`fs.rename(oldName, newName, callback)`方法将`oldName`处的文件重命名为`newName`。回调函数接收一个参数，即调用中抛出的任何异常。

# fs.truncate（路径、len、回调）

`fs.truncate(path, len, callback)`方法将`path`处的文件长度更改为`len`字节。如果`len`表示比文件当前长度短的长度，则文件将被截断为该长度。如果`len`更大，则通过追加空字节（x00）来填充文件长度，直到达到`len`。回调函数接收一个参数，即调用中抛出的任何异常。

# fs.ftruncate（fd、len、回调）

`fs.ftruncate(fd, len, callback)`方法与`fs.truncate`类似，不同之处在于不指定文件，而是将文件描述符作为`fd`传递。

# fs.chown（路径、uid、gid、回调）

`fs.chown(path, uid, gid, callback)`方法更改`path`处文件的所有权。使用此选项设置用户`uid`或组`gid`是否有权访问文件。回调函数接收一个参数，即调用中抛出的任何异常。

# fs.fchown（fd、uid、gid、回调）

`fs.fchown(fd, uid, gid, callback)`方法与`fs.chown`类似，不同之处在于不指定文件路径，而是将文件描述符作为`fd`传递。

# fs.lchown（路径、uid、gid、回调）

`fs.lchown(path, uid, gid, callback)`方法与`fs.chown`类似，只是在符号链接的情况下，链接文件本身的所有权发生了变化，但引用的链接没有发生变化。

# chmod（路径、模式、回调）

`fs.chmod(path, mode, callback)`方法更改`path`处文件的`mode`（权限）。您正在为此文件设置读取（4）、写入（2）和执行（1）位，这些位可以八进制数字发送：

|  | [r] ead | [w] 仪式 | E[x]ecute | 全部的 |
| 物主 | **4** | **2** | **1** | **7** |
| 组 | **4** | **0** | **1** | **5** |
| 另外 | **4** | **0** | **1** | **5** |
|  |  |  |  | **chmod（755）** |

您也可以使用符号表示法，例如用于组读写的`g+rw`，类似于我们前面看到的用于`file.open`的参数。有关设置文件模式的更多信息，请参阅：[http://en.wikipedia.org/wiki/Chmod](http://en.wikipedia.org/wiki/Chmod) 。

回调函数接收一个参数，即调用中抛出的任何异常。

# fs.fchmod（fd、模式、回调）----

`fs.fchmod(fd, mode, callback)`方法与`fs.chmod`类似，不同之处在于不指定文件路径，而是将文件描述符作为`fd`传递。

# fs.lchmod（路径、模式、回调）

`fs.lchmod(path, mode, callback)`方法与`fs.chmod`类似，只是在符号链接的情况下，链接文件本身的权限会改变，而被引用链接的权限不会改变。

# 链接（srcPath、dstPath、回调）

`fs.link(srcPath, dstPath, callback)`在`srcPath`和`dstPath`之间创建硬链接。这是一种为完全相同的文件创建许多不同路径的方法。例如，以下目录包含一个`target.txt`文件和两个硬链接—`a.txt`和`b.txt`——每个链接都指向此文件：

![](assets/071fe6c3-13e6-4da9-8a4c-5df632547f06.png)

注意，`target.txt`是空的。如果目标文件的内容更改，链接文件的长度也将更改。考虑更改目标文件的内容：

```
echo "hello" >> target.txt  
```

这就产生了这种新的目录结构，清楚地展示了硬引用：

![](assets/a761ddfa-c59c-4fa5-8c97-f744588b811a.png)

回调函数接收一个参数，即调用中抛出的任何异常。

# fs.symlink（srcPath，dstPath，[type]，回调）

`fs.symlink(srcPath, dstPath, [type], callback)`方法在`srcPath`和`dstPath`之间创建符号链接。与使用`fs.link`创建的硬链接不同，符号链接只是指向其他文件的指针，本身不会响应目标文件中的更改。默认链接`type`为文件。其他选项包括 directory 和 junction，最后一个选项是在其他系统上被忽略的 Windows 特定类型。回调函数接收一个参数，即调用中抛出的任何异常。

将`fs.link`讨论中描述的目录更改与以下内容进行比较和对比：

![](assets/e0bc810e-ef05-4e42-af3f-9c69b5d91603.png)

与硬链接不同，符号链接在其目标文件（在本例中为`target.txt`）更改长度时不会更改长度。在这里，我们看到将目标的长度从零字节更改为六字节对任何绑定符号链接的长度没有影响：

![](assets/117fd84c-d6db-404a-b48f-87c81a872b97.png)

# fs.readlink（路径，回调）

`path`处的给定符号链接返回目标文件的文件名：

```
fs.readlink('a.txt', (err, targetFName) => { 
  console.log(targetFName); // target.txt 
}); 
```

# fs.realpath（路径，[cache]，回调）

`fs.realpath(path, [cache], callback)`方法试图在`path`找到文件的实际路径。这是一种查找文件绝对路径、解析符号链接、甚至清除无关斜杠和其他格式错误的路径的有用方法。考虑这个例子：

```
fs.realpath('file.txt', (err, resolvedPath) => { 
  console.log(resolvedPath); // `/real/path/to/file.txt` 
}); 
```

或者，考虑一下：

```
fs.realpath('.////./file.txt', (err, resolvedPath) => { 
  // still `/real/path/to/file.txt` 
}); 
```

如果要解析的某些路径段已经已知，则可以传递映射路径的`cache`：

```
let cache = {'/etc':'/private/etc'}; 
fs.realpath('/etc/passwd', cache, (err, resolvedPath) => { 
  console.log(resolvedPath); // `/private/etc/passwd` 
});
```

# fs.unlink（路径，回调）

`fs.unlink(path, callback)`方法删除`path`处的文件-相当于删除一个文件。回调函数接收一个参数，即调用中抛出的任何异常。

# fs.rmdir（路径，回调）

`fs.rmdir(path, callback)`方法删除`path`处的目录，相当于删除一个目录。

请注意，如果目录不是空的，这将引发异常。回调函数接收一个参数，即调用中抛出的任何异常。

# fs.mkdir（路径，[模式]，回调）

`fs.mkdir(path, [mode], callback)`方法在`path`处创建一个目录。要设置新目录的模式，请使用`fs.chmod`中描述的权限位图。

请注意，如果此目录已存在，将引发异常。回调函数接收一个参数，即调用中抛出的任何异常。

# 存在（路径，回调）

`fs.exists(path, callback)`方法检查`path`是否存在文件。回调将接收布尔值 true 或 false。

# fs.fsync（fd，回调）

在请求将某些数据写入文件和数据完全存在于存储设备之间，候选数据存在于核心系统缓冲区中。这种延迟通常不相关，但在某些极端情况下，如系统崩溃，有必要坚持文件反映稳定存储设备上的已知状态。

`fs.fsync`将文件描述符`fd`引用的文件的所有核心数据复制到磁盘
（或其他存储设备）。回调函数接收一个参数，即调用中抛出的任何异常。

# 同步性

为了方便起见，节点的`file`模块为我们讨论过的每种异步方法提供了同步对应项，由`Sync`后缀表示。例如，`fs.mkdir`的同步版本为`fs.mkdirSync`。

同步调用还可以直接返回其结果，从而无需回调。在[第 3 章](03.html)、*跨节点和客户端的流式数据传输*中演示 HTTPS 服务器的创建时，我们看到了一个很好的同步代码用例和一个无回调直接分配结果的示例：

```
key: fs.readFileSync('server-key.pem'), 
cert: fs.readFileSync('server-cert.pem') 
```

嘿节点是否严格执行异步编程？阻塞代码不总是错误的吗？我们鼓励所有开发人员坚持非阻塞设计，并鼓励您避免同步编码。如果遇到同步操作似乎是唯一解决方案的问题，则很可能是错误地理解了该问题。然而，在执行进一步的指令（阻塞操作）之前，确实存在需要文件对象完全存在于内存中的边缘情况。Node 为开发人员提供了打破异步传统的能力，如果它是唯一可能的解决方案（可能不是！）。

开发人员经常使用的一个同步操作（可能没有意识到）是`require`指令：

```
require('fs') 
```

在 require 所针对的依赖项完全初始化之前，后续 JavaScript 指令将不会执行（文件加载会阻塞事件循环）。*Ryan Dahl*为将同步操作（尤其是文件操作）引入 Node 的决定而苦苦挣扎，正如他在 2013 年 7 月的谷歌技术演讲中所提到的：

According to [http://www.youtube.com/watch?v=F6k8lTrAE2g](http://www.youtube.com/watch?v=F6k8lTrAE2g),
"I think this is an OK compromise. It pained me for months, to drop the purity of having an asynchronous module system. But, I think it's ok.

...

It simplifies the code a lot to be able to just stick in "require, require, require" and not have to do an onload callback...I think that's been a relatively OK compromise. [...] There's really two parts to your program: there's the loading and starting up phase...and you don't really care how fast that runs...you're going to load modules and stuff...the setup phase of your daemon, generally, is synchronous. It's when you get into your event loop for serving requests that you want to be very careful about this. [...] I will give people synchronous file I/O. If they do it in servers...it won't be terrible, right? The important thing is to never let them do synchronous network I/O."

同步代码确实具有明显的可预测性的优势，因为在该指令完成之前，不会发生其他任何事情。当启动一台服务器时（这种情况很少发生），Dahl 建议，一点确定性和简单性会大有帮助。例如，在服务器初始化时加载配置文件可能有意义。

有时，在节点开发中使用同步命令的愿望仅仅是求救；被深度嵌套的回调结构淹没的开发人员。如果曾经遇到过这种痛苦，请尝试[第 2 章](02.html)*理解异步事件驱动编程*中提到的一些回调驯服库。

# 在目录中移动

让我们应用所学内容并创建一个目录迭代器。该项目的目标是创建一个函数，该函数将接受目录路径并返回反映文件目录层次结构的 JSON 对象，其节点由文件对象组成。我们还将使我们的目录遍历器成为一个更强大的基于事件的解析器，这与节点原理是一致的。

要在嵌套目录中移动，首先必须能够读取单个目录。节点的文件系统库为此提供了`fs.readdir`命令：

```
fs.readdir('.', (err, files) => { 
  console.log(files); // list of all files in current directory 
}); 
```

记住，一切都是一个文件，我们需要做的不仅仅是得到一个目录列表；我们必须确定文件列表中每个成员的类型。通过添加`fs.stat`，我们已经完成了大部分逻辑：

```
(dir => { 
  fs.readdir(dir, (err, list) => { 
    list.forEach(file => { 
      fs.stat(path.join(dir, file), (err, stat) => { 
        if (stat.isDirectory()) { 
          return console.log(`Found directory: ${file}`); 
        }
        console.log(`Found file: ${file}`); 
      }); 
    }); 
  }); 
})("."); 
```

此自动执行函数接收目录路径参数`(".")`，将目录列表折叠成一个文件名数组，为每个文件名获取一个`fs.Stats`对象，并根据指定的文件类型（目录或非目录）决定下一步要做什么。此时，我们还可以使用当前文件的名称及其属性。显然，我们已经映射了一个目录。

我们现在必须在目录中映射目录，将结果存储在反映嵌套文件系统树的 JSON 对象中，树上的每个叶都是一个文件对象。下一步是递归地将目录读取器函数路径传递到子目录，并将返回的结果作为最终对象的分支追加：

```
let walk = (dir, done) => { 
  let results = {}; 
  fs.readdir(dir, (err, list) => { 
    let pending = list.length;    
    if (err || !pending) { 
      return done(err, results); 
    } 
    list.forEach(file => { 
      let dfile = require('path').join(dir, file); 
      fs.stat(dfile, (err, stat) => { 
        if(stat.isDirectory()) { 
          return walk(dfile, (err, res) => { 
            results[file] = res; 
            !--pending && done(null, results); 
          }); 
        }  
        results[file] = stat; 
        !--pending && done(null, results); 
      }); 
    }); 
  }); 
}; 
walk(".", (err, res) => { 
  console.log(require('util').inspect(res, {depth: null})); 
});
```

我们创建一个`walk`方法，该方法接收目录路径和一个回调，该回调在`walk`完成时接收目录图或错误，遵循节点的样式。不需要太多代码就可以创建一个非常快速、无阻塞的文件树遍历器，并完成文件统计。

现在，让我们在遇到目录或文件时发布事件，为将来的实现提供构建自己的文件系统表示的灵活性。为此，我们将使用友好的`EventEmitter`对象：

```
let walk = (dir, done, emitter) => { 
  ... 
  emitter = emitter || new (require('events').EventEmitter); 
  ... 
  if (stat.isDirectory()) { 
    emitter.emit('directory', dfile, stat); 
    return walk(dfile, (err, res) => { 
      results[file] = res; 
      !--pending && done(null, results); 
    }, emitter); 
  }  
  emitter.emit('file', dfile, stat); 
  results[file] = stat; 
  ... 
  return emitter; 
} 
walk("/usr/local", (err, res) => { 
  ... 
}).on("directory", (path, stat) => { 
  console.log(`Directory: ${path} - ${stat.size}`); 
}).on("file", (path, stat) => { 
  console.log(`File: ${path} - ${stat.size}`); 
}); 
// File: index.html - 1024 
// File: readme.txt - 2048 
// Directory: images - 106 
// File images/logo.png - 4096 
// ... 
```

既然我们知道了如何发现和寻址文件，我们就可以开始读取和写入文件了。

# 从文件中读取

在我们对文件描述符的讨论中，我们讨论了一种打开文件、获取文件描述符并最终通过该引用推送或拉取数据的方法。读取文件是一种常见的操作。有时，可能需要精确管理读取缓冲区，节点允许逐字节控制。在其他情况下，只需要一个简单易用的无装饰流。

# 逐字节读取

`fs.read`方法是 Node 提供的读取文件的最低级方式。

# 读取（fd、缓冲区、偏移量、长度、位置、回调）

文件由有序字节组成，这些字节可通过其`position`寻址，相对于文件中的开头（位置零[0]）。一旦我们有了
一个文件描述符`fd`，我们就可以开始读取`length`个字节，并将其插入`Buffer`对象`buffer`，插入从给定缓冲区`offset`开始。例如，要将可读文件`fd`中从`position`309 开始的 8366 字节复制到从`offset`100 开始的
a`buffer`，我们将使用`fs.read(fd, buffer, 100, 8366, 309, callback)`。

以下代码演示如何打开和读取 512 字节块中的文件：

```
fs.open('path.js', 'r', (err, fd) => { 
  fs.fstat(fd, (err, stats) => { 
    let totalBytes = stats.size; 
    let buffer = Buffer.alloc(totalBytes); 
    let bytesRead = 0; 
    // Each call to read should ensure that chunk size is 
    // within proper size ranges (not too small; not too large). 
    let read = chunkSize => { 
      fs.read(fd, buffer, bytesRead, chunkSize, bytesRead, (err, numBytes, bufRef) => { 
        if((bytesRead += numBytes) < totalBytes) { 
          return read(Math.min(512, totalBytes - bytesRead)); 
        } 
        fs.close(fd); 
        console.log(`File read complete. Total bytes read: ${totalBytes}`); 
        // Note that the callback receives a reference to the 
        // accumulating buffer  
        console.log(bufRef.toString()); 
      }); 
    } 
    read(Math.min(512, totalBytes)); 
  }); 
}); 
```

生成的缓冲区可以通过管道传输到其他地方（包括服务器响应对象）。它也可以使用节点的`Buffer`对象的方法进行操作，例如使用`buffer.toString("utf8")`转换为 UTF8 字符串。

# 一次获取整个文件

通常，只需要获取整个文件，而不需要任何仪式或精细控制。节点为此提供了一个快捷方式方法。

# readFile（路径，[options]，回调）

获取`path`文件中包含的数据可以一步完成：

```
fs.readFile('/etc/passwd', (err, fileData) => { 
  if(err) { 
    throw err; 
  } 
  console.log(fileData); 
  // <Buffer 48 65 6C 6C 6F ... > 
}); 
```

我们看到`callback`如何接收缓冲区。可能更希望以通用编码（例如 UTF8）接收文件数据。我们可以使用`options`对象指定返回数据的编码以及读取模式，该对象有两个可能的属性：

*   **编码**：字符串，如`utf8`，默认为空（无编码）
*   **标志**：文件模式为字符串，默认为`r`

修改前面的示例：

```
fs.readFile('/etc/passwd', (err, { encoding : "utf8" }, fileData) => { 
  ... 
  console.log(fileData); 
  // "Hello ..." 
});
```

# 创建可读流

虽然`fs.readFile`是一种出色、简单的完成普通任务的方法，但它确实有一个显著的缺点，即要求在将文件的任何部分发送到回调之前将整个文件读入内存。对于大文件或大小未知的文件，这不是一个好的解决方案。

在上一章中，我们学习了数据流和`Stream`对象。虽然使用可读流可以轻松自然地处理文件，但 Node 提供了一个专用的文件流接口，该接口提供了一个紧凑的文件流设施，无需额外的构建工作，比`fs.readFile`提供的灵活性更强。

# fs.createReadStream（路径，[选项]）

`fs.createReadStream(path, [options])`方法返回`path`处文件的可读流对象。然后，您可以对返回的对象执行流操作，例如`pipe()`。

以下选项可用：

*   `flags`：文件模式参数为字符串。默认为`r`。
*   `encoding`：是`utf8`、`ascii`或`base64`中的一种。默认为无编码。
*   `fd`：可以将`path`设置为 null，而不是将调用传递给文件描述符。
*   `mode`：文件模式八进制表示，默认为 0666。
*   `bufferSize`：内部读取流的块大小，以字节为单位。默认为 64*1024 字节。您可以将其设置为任何数字，但内存分配由主机操作系统严格控制，主机操作系统可能会忽略请求。参见：[https://groups.google.com/forum/?fromgroups#!topic/nodejs/p5fuu1oxby](https://groups.google.com/forum/?fromgroups#!topic/nodejs/p5FuU1oxbeY)。
*   `autoClose`：是否自动关闭文件描述符（a la`fs.close`）。默认为 true。如果要跨多个流共享文件描述符，可能需要将此设置为 false 并手动关闭，因为关闭描述符会中断任何其他读取器。
*   `start`：从这个位置开始阅读。默认值为 0。
*   `end`：在此位置停止读取。默认值是文件字节长度。

# 逐行读取文件

虽然逐字节读取文件流对于任何文件解析工作都是足够的，但文本文件通常更适合逐行读取，例如在读取日志文件时。更准确地说，任何流都可以用换行符分隔的数据块来理解，在 UNIX 系统上通常是`rn`。节点提供了一个本机模块，其方法简化了对数据流中新行分隔块的访问。

# Readline 模块

`Readline`模块有一个简单但强大的目标，即使逐行读取数据流变得更容易。它的大部分界面都是为了使命令行提示更简单而设计的，这样接受用户输入的界面就更容易设计。

记住节点是为 I/O 设计的，I/O 操作通常涉及在可读和可写流之间移动数据，`stdout`和`stdin`是与`fs.createReadStream`和`fs.createWriteStream`返回的文件流相同的流接口，我们将研究如何类似地使用此模块来提示文件流输入一行文本。

要开始使用`Readline`模块，必须创建一个定义输入流和输出流的接口。默认接口选项将优先使用作为终端接口。我们感兴趣的选项如下：

*   `input`：必填项。正在收听的可读流。
*   `output`：必填项。正在写入的可写流。
*   `terminal`：如果输入和输出流都应被视为 Unix 终端或**电传打字机**（**TTY**），则将此设置为 true。对于文件，您将此设置为 false。

通过这个系统，读取文件行变得很容易。例如，假设有一个列出英语常用词的词典文件，则可能需要将该列表读入数组进行处理：

```
const fs = require('fs'); 
const readline = require('readline'); 

let rl = readline.createInterface({ 
  input: fs.createReadStream("dictionary.txt"), 
  terminal: false 
}); 
let arr = []; 
rl.on("line", ln => { 
  arr.push(ln.trim()) 
}); 
// aardvark 
// abacus 
// abaisance 
// ...  
```

注意我们是如何禁用 TTY 行为的，我们自己处理这些行，而不重定向到输出流。

正如节点 I/O 模块所预期的那样，我们正在处理流事件。可能感兴趣的事件侦听器如下所示：

*   `line`：以字符串形式接收最近读取的行
*   `pause`：流暂停时调用
*   `resume`：流恢复时调用
*   `close`：流关闭时调用

除`line`外，这些事件名称反映了`Readline`方法，用`Readline.pause`暂停流，`resume`用`Readline.resume`暂停流，`close`用`Readline.close`暂停流。

# 写入文件

与读取文件一样，Node 提供了丰富的工具集合，用于写入文件。我们将看到 Node 如何使逐字节定位文件内容变得容易，就像将连续的数据流导入单个可写文件一样。

# 逐字节写入

`fs.write`方法是 Node 提供的最底层的文件写入方式。这种方法使我们能够精确地控制在文件中写入字节的位置。

# 写入（fd、缓冲区、偏移量、长度、位置、回调）

将`buffer`的 309 和 8675**（**长度 8366）之间的字节集合写入文件描述符`fd`引用的文件，插入从位置 100 开始：

```
let buffer = Buffer.alloc(8675); 
fs.open("index.html", "w", (err, fd) => { 
  fs.write(fd, buffer, 309, 8366, 100, (err, writtenBytes, buffer) => { 
    console.log(`Wrote ${writtenBytes} bytes to file`); 
    // Wrote 8366 bytes to file 
  }); 
}); 
```

Note that for files opened in the append (`a`) mode, some operating systems may ignore `position` values, always adding data to the end of the file. Additionally, it is unsafe to call `fs.write` multiple times on the same file without waiting for the callback. Use `fs.createWriteStream` in those cases.

有了这样精确的控制，我们可以智能地构造文件。在下面（有些人为的）示例中，我们创建了一个基于文件的数据库，其中包含单个球队 6 个月的棒球成绩的索引信息。我们希望能够快速查看这支球队在某一天是赢了还是输了（或者没有比赛）。

由于一个月最多有 31 天，我们可以（随机）在此文件中创建一个 6 x 31 的数据网格，在每个网格单元中放置三个值之一：L（损失）、W（胜利）、N（无游戏）。为了好玩，我们还使用基本查询语言为我们的数据库创建了一个简单的**CLI**（**命令行界面**。本例应明确说明如何使用`fs.read`、`fs.write`和`Buffer`对象精确操作文件中的字节：

```
const fs = require('fs'); 
const readline = require('readline'); 
let cells  = 186; // 6 x 31 
let buffer = Buffer.alloc(cells); 
let rand;
while(cells--) { 
  //  0, 1 or greater 
  rand = Math.floor(Math.random() * 3); 
  //  78 = "N", 87 = "W", 76 = "L" 
  buffer[cells] = rand === 0 ? 78 : rand === 1 ? 87 : 76; 
} 
fs.open("scores.txt", "r+", (err, fd) => { 
  fs.write(fd, buffer, 0, buffer.length, 0, (err, writtenBytes, buffer) => {          
    let rl = readline.createInterface({ 
      input: process.stdin, 
      output: process.stdout 
    }); 

    let quest = () => { 
      rl.question("month/day:", index => { 
        if(!index) { 
          return rl.close(); 
        } 
        let md = index.split('/'); 
        let pos = parseInt(md[0] -1) * 31 + parseInt(md[1] -1); 
        fs.read(fd, Buffer.alloc(1), 0, 1, pos, (err, br, buff) => { 
          let v = buff.toString(); 
          console.log(v === "W" ? "Win!" : v === "L" ? "Loss..." : "No game"); 
          quest(); 
        }); 
      }); 
    }; 
    quest(); 
  }); 
}); 
```

一旦运行，我们可以简单地输入月/日对，并快速访问该数据单元。为输入值添加边界检查将是一个简单的改进。通过可视化 UI 推送文件流可能是一个不错的练习。

# 写入大块数据

对于简单的写操作，`fs.write`可能会有过大的杀伤力。有时，所需要的只是一种创建包含某些内容的新文件的方法。同样常见的是需要将数据附加到文件的末尾，就像在日志系统中一样。`fs.writeFile`和`fs.appendFile`方法可以帮助我们处理这些场景。

# fs.writeFile（路径、数据、[选项]、回调）

`fs.writeFile(path, data, [options], callback)`方法将`data`的内容写入`path`处的文件。数据参数可以是缓冲区或字符串。以下选项可用：

*   `encoding`：默认为`utf8`。如果数据是缓冲区，则忽略此选项。
*   `mode`：文件模式八进制表示，默认为 0666。
*   `flag`：写入标志，默认为`w`。

用法很简单：

```
fs.writeFile('test.txt', 'A string or Buffer of data', err => { 
  if (err) { 
    return console.log(err); 
  } 
  // File has been written 
}); 
```

# appendFile（路径、数据、[选项]、回调）

与`fs.writeFile`类似，只是`data`附加在`path`处的文件末尾。此外，`flag`选项默认为`a`。

# 创建可写流

如果写入文件的数据以块的形式到达（例如文件上载时发生的），则通过`WritableStream`对象接口将该数据流化可提供更大的灵活性和效率。

# fs.createWriteStream（路径，[options]）

`fs.createWriteStream(path, [options])`方法为`path`处的文件返回一个可写流对象。

以下选项可用：

*   `flags`：文件模式参数为字符串。默认为`w`。
*   `encoding`：是`utf8`、`ascii`或`base64`中的一种。默认为无编码。
*   `mode`：文件模式八进制表示，默认为 0666。
*   `start`：表示文件中开始写入的位置的偏移量。

例如，这个小程序就像世界上最简单的字处理器，将所有终端输入写入一个文件，直到终端关闭：

```
let writer = fs.createWriteStream("novel.txt", 'w'); 
process.stdin.pipe(writer);
```

# 警告

打开文件描述符并从中读取的副作用很小，因此在正常开发中，很少考虑系统中实际发生的事情。通常，读取文件不会改变它。

在写入文件时，必须解决一些问题，例如：

*   是否有足够的可写存储空间可用？
*   另一个进程是否同时访问此文件，甚至删除它？
*   如果写入操作失败或中途非自然终止，必须执行什么操作？

我们已经看到了独占写入模式标志（`wx`），它在多个写入进程同时尝试创建一个文件时会有所帮助。在一般情况下，或者简单地说，很难获得写入文件时可能遇到的所有问题的完整解决方案。Node 鼓励异步编程。然而，特别是对于文件系统，有时需要同步的、确定性的编程。我们鼓励您牢记这些和其他问题，并尽可能保持 I/O 非阻塞。

# 提供静态文件

任何使用 Node 创建 web 服务器的人都需要智能地响应 HTTP 请求。向 web 服务器请求资源的 HTTP 请求需要某种响应。基本文件静态文件服务器可能如下所示：

```
http.createServer((request, response) => { 
  if(request.method !== "GET") { 
    return response.end("Simple File Server only does GET"); 
  } 
  fs 
  .createReadStream(__dirname + request.url) 
  .pipe(response); 
}).listen(8000); 
```

此服务器服务在端口`8000`上获取请求，期望在与 URL 路径段等效的相对路径上找到本地文件。我们可以看到 Node 使我们能够很容易地流式传输本地文件数据，只需将一个`ReadableStream`管道传输到一个`WritableStream`代表客户端套接字连接。这是一个巨大的功能，可以在少数几行中安全地实现。

最终，将添加更多内容，例如处理标准 HTTP 方法的例程、处理错误和格式错误的请求、设置正确的头、管理 favicon 请求等等。

让我们用 Node 构建一个相当有用的文件服务器，它将通过流式返回资源来响应 HTTP 请求，并尊重缓存请求。在此过程中，我们将讨论如何管理内容重定向。在本章后面，我们还将介绍如何实现文件上传。请注意，完全符合 HTTP 所有功能的 web 服务器是一个复杂的野兽，因此我们所创建的应该被视为一个良好的开端，而不是结束。

# 重定向请求

有时，客户端会尝试`GET`一个 URL，该 URL 在某种程度上不正确或不完整，资源可能已被移动，或者有更好的方法发出相同的请求。其他时候，`POST`可能会在客户端不知道的新位置创建新资源，需要一些指向新创建的 URI 的响应头信息。让我们看一下使用节点实现静态文件服务器时可能面临的两种常见重定向场景。

两个响应头是重定向的基础：

*   `Location`：这表示重定向到可以找到所述内容体的位置
*   `Content-Location`：这表示请求者将在其中找到响应正文中包含的实体的原始位置的 URL

此外，这些标题还有两个特定的用例：

*   为响应`POST`提供新创建的资源
    的位置信息
*   响应`GET`通知客户请求的资源
    的备用位置

There are many possible pairings of `Location` and `Content-Location` headers with HTTP status codes, the **3xx** (redirection) set in particular. In fact, these headers may even appear together in the same response. The user is encouraged to read the relevant sections of the HTTP/1.1 specification, as only a small set of common cases is discussed here.

# 地方

使用`201`状态代码响应`POST`表示已经创建了一个新的资源，并将其 URI 分配给`Location`头，并且客户端将来可能会继续使用该 URI。请注意，是否以及何时获取此资源由客户机决定。因此，严格来说，这不是重定向。

例如，系统可能会通过将新用户信息发布到服务器来创建新帐户，希望接收新用户页面的位置：

```
    POST /path/addUser HTTP/1.1
    Content-Type: application/x-www-form-urlencoded
    name=John&group=friends 
    ...
    Status: 201 
    Location: http://website.com/users/john.html  
```

类似地，在资源创建请求已被接受但尚未完成的情况下，服务器将指示状态`202`。如果已将新用户记录的创建委托给工作队列，则在上一示例中就是这种情况，该工作队列可能在将来的某个时间点在给定的`Location`处创建记录。

在本章后面讨论文件上载时，我们将看到一个实际的实现来演示这种用法。

# 内容位置

当对具有多个表示且可在不同资源位置找到的资源进行`GET`时，应返回特定实体的`content-location`头。例如，内容格式协商是`Content-Location`处理的一个很好的候选者。你可能会对检索某个月的所有博客帖子感兴趣，也许可以通过如下 URL 获得：`http://example.com/september/`。`Accept`头为`application/json`的 GET 请求将收到 JSON 格式的响应。对 XML 的请求将收到该表示。

如果正在使用缓存机制，则这些资源可能具有备用的永久位置，例如`http://example.com/cache/september.json`或`http://example.com/cache/september.xml`。用户将通过`Content-Location`发送此附加位置信息，响应对象类似于：

```
    Status: 200 
    Content-Type: application/json
    Content-Location: http://blogs.com/cache/allArticles.json
    ... JSON entity body  
```

如果请求的 URL 已被永久或临时移动，**3xx**组状态代码可与`Content-Location`一起使用以指示此状态。例如，要将请求重定向到已永久移动的 URL，应发送 301 代码：

```
function requestHandler(request,response) { 
  let newPath = "/thedroids.html"; 
  response.writeHead(301, { 
    'Content-Location': newPath 
  }); 
  response.end(); 
} 
```

# 实现资源缓存

一般来说，永远不要花费资源向客户提供不相关的信息。对于 HTTP 服务器来说，重新发送客户端已经拥有的文件是不必要的 I/O 成本，这恰恰是实现节点服务器的错误方式，增加了延迟以及为占用的带宽付费的财务损失。

浏览器维护他们已经获取的文件的缓存，并且**实体标记**（**ETag**）标识这些文件。ETag 是服务器发送的一个响应头，用于唯一标识它们返回的实体，如文件。当服务器上的文件发生更改时，该服务器将为所述文件发送不同的 ETag，从而允许客户端跟踪文件更改。

当客户端向服务器请求包含在该客户端缓存中的资源时，该请求将包含一个`If-None-Match`头，该头设置为与所述缓存资源相关联的 ETag 的值。`If-None-Match`表头可以包含一个或多个 ETag：

```
If-None-Match : "686897696a7c876b7e" 
If-None-Match : "686897696a7c876b7e", "923892329b4c796e2e"
```

服务器理解此标头，仅当发送的 ETag 与当前资源实体标记均不匹配时，才会返回请求资源的完整实体体。如果发送的 ETag 之一与当前实体标记匹配，服务器将以 304（未修改）状态响应，这将导致浏览器从其内部缓存中获取资源。

假设我们有一个可用的`fs.Stats`对象，那么使用节点可以轻松地管理资源上的缓存控制：

```
let etag = crypto.createHash('md5').update(stat.size + stat.mtime).digest('hex'); 
if(request.headers['if-none-match'] === etag) { 
  response.statusCode = 304; 
  return response.end(); 
} else { 
  // stream the requested resource 
} 
```

我们通过创建当前文件大小及其上次修改时间的 MD5，为当前文件创建一个`etag`，并与发送的`If-None-Match`头匹配。如果两者不匹配，则资源表示已更改，必须将新版本发送回请求客户端。请注意，创建`etag`时应使用的特定算法没有正式指定。示例技术在大多数情况下都应该很好地工作。

Hey! What about `Last-Modified` and `If-Unmodified-Since`? These are fine headers and are also useful in the case of caching files. Indeed, one should set the `Last-Modified` header where possible when responding to entity requests. The techniques we're describing here using ETag will work similarly with these tags, and in fact, using both Etags and these other tags is encouraged. For more information, consult: [http://www.w3.org/Protocols/rfc2616/rfc2616-sec13.html#sec13.3.4](http://www.w3.org/Protocols/rfc2616/rfc2616-sec13.html#sec13.3.4).

# 处理文件上载

读过这句话的人可能至少有一次从客户机上传文件到服务器的经验。有些人甚至可能已经实现了文件上传服务，这是一个服务器，它将接收多部分数据流并对其执行一些有用的操作。在流行的开发环境中，这项任务变得非常简单。例如，在 PHP 环境中，上传的数据会被自动处理并全局可用，被整齐地解析并打包成一组文件或表单字段值，而开发人员无需编写一行代码。

不幸的是，Node 将文件上传处理的实现留给了开发人员，许多开发人员可能无法成功或安全地完成这项具有挑战性的工作。

幸运的是，Felix Geisendorfer 创建了**强大的**模块，这是 Node 项目最重要的早期贡献之一。这是一个广泛实现的企业级模块，具有广泛的测试覆盖范围，它不仅可以快速处理文件上传，还可以作为处理表单提交的完整工具。我们将使用此库向文件服务器添加文件上载功能。

For more information about how HTTP file uploads are designed, and the tricky implementation problems developers must overcome, consult the multipart/form-data specification at [http://www.w3.org/TR/html401/interact/forms.html#h-17.13.4.2](http://www.w3.org/TR/html401/interact/forms.html#h-17.13.4.2) and Geisendorfer's breakdown of how **Formidable** was conceived of and evolved at [http://debuggable.com/posts/parsing-file-uploads-at-500-mb-s-with-node-js:4c03862e-351c-4faa-bb67-4365cbdd56cb](http://debuggable.com/posts/parsing-file-uploads-at-500-mb-s-with-node-js:4c03862e-351c-4faa-bb67-4365cbdd56cb).

首先，通过 npm 安装`formidable`：

```
 npm install formidable 
```

您现在可以`require`它：

```
    let formidable = require('formidable');  
```

我们将假设文件上传将沿着
`/uploads/`的路径发布到我们的服务器，并且上传将通过如下所示的 HTML 表单到达：

```
<form action="/uploads" enctype="multipart/form-data" method="post"> 
Title: <input type="text" name="title"><br /> 
<input type="file" name="upload" multiple="multiple"><br /> 
<input type="submit" value="Upload"> 
</form> 
```

此表单允许客户端为上载编写某种标题，并选择一个（或多个）文件进行上载。此时，我们在服务器上的唯一职责是正确地检测何时发出了`POST`请求，并将相关的请求对象传递给服务器。

我们不会涵盖全面而强大的 API 设计的每一部分，但我们将重点关注库公开的关键事件。随着`EventEmitter`的扩展，我们使用`on(eventName,callback)`格式捕获文件数据、字段数据和终止事件，并向客户端发送响应，描述服务器已成功处理的内容：

```
http.createServer((request, response) => { 
  let rm = request.method.toLowerCase(); 
  if(request.url === '/uploads' && rm === 'post') { 
    let form = new formidable.IncomingForm(); 
    form.uploadDir = process.cwd(); 
    let resp = ""; 
    form 
    .on("file", (field, File) => { 
      resp += `File: ${File.name}<br />`; 
    }) 
    .on("field", (field, value) => { 
      resp += `${field}: ${value}<br />`; 
    }) 
    .on("end", () => { 
      response.writeHead(200, {'content-type': 'text/html'}); 
      response.end(resp); 
    }) 
    .parse(request); 
    return; 
  } 
}).listen(8000); 
```

我们在这里看到`formidable`实例如何通过`parse`方法接收`http.Incoming`对象，以及如何使用该实例的`uploadDir`属性设置传入文件的写入路径。该示例将此目录设置为本地目录。真正的实现可能以专用上传文件夹为目标，甚至将接收到的文件定向到存储服务，以接收最终存储位置作为回报（可能通过 HTTP 和`Location`头接收）。

还要注意文件事件回调如何接收强大的`File`对象作为第二个参数，其中包含重要的文件信息，包括以下内容：

*   **大小**：上传文件的大小，以字节为单位
*   `*`**路径**：上传文件在本地文件系统上的当前位置，如
    如`/tmp/bdf746a445577332e38be7cde3a98fb3`
*   **名称**：客户端文件系统上存在的文件的原始名称，如`lolcats.jpg`
*   **类型**：文件 mime 类型，如`image/png`

在几行代码中，我们实现了大量的`POST`数据管理。强大还提供了处理进度指标、处理网络错误等工具，读者可以通过访问[了解这些工具 https://github.com/felixge/node-formidable](https://github.com/felixge/node-formidable) 。

# 把它们放在一起

回顾我们在上一章中对 favicon 处理的讨论，并添加我们对文件缓存和文件上载的了解，我们现在可以构建一个简单的文件服务器来处理`GET`和`POST`请求：

```
http.createServer((request, response) => { 
  let rm = request.method.toLowerCase(); 
  if(rm === "post") { 
    let form = new formidable.IncomingForm(); 
    form.uploadDir = process.cwd(); 
    form 
    .on("file", (field, file) => { 
      // process files 
    }) 
    .on("field", (field, value) => { 
      // process POSTED field data 
    }) 
    .on("end", () => { 
      response.end("Received"); 
    }) 
    .parse(request); 
    return; 
  } 
  // Only GET is handled if not POST
  if(rm !== "get") { 
    return response.end("Unsupported Method"); 
  } 
  let filename = path.join(__dirname, request.url); 
  fs.stat(filename, (err, stat) => { 
      if(err) { 
        response.statusCode = err.errno === 34 ? 404 : 500; 
      return response.end() 
      }  
    var etag = crypto.createHash('md5').update(stat.size + stat.mtime).digest('hex');     
    response.setHeader('Last-Modified', stat.mtime); 
    if(request.headers['if-none-match'] === etag) { 
      response.statusCode = 304; 
      return response.end(); 
    } 
    response.setHeader('Content-Length', stat.size); 
    response.setHeader('ETag', etag); 
    response.statusCode = 200; 
    fs.createReadStream(filename).pipe(response); 
  }); 
}).listen(8000); 
```

注意 404（未找到）和 500（内部服务器错误）状态代码。

`Content-Length` is measured in bytes, not characters. Normally, your data will be in single byte characters (hello is five bytes long), but this is not always the case. If you are determining the length of a stream buffer, use `Buffer.byteLength`.

# 简单的文件浏览器

现在，让我们利用我们所学到的关于文件和节点的知识来做一些真正（并且希望）没有网页能够做到的事情；让我们直接浏览您个人电脑的整个硬盘！为了实现这一点，我们将使用 JavaScript 和节点家族中最近添加的两个功能强大的组件：*Electron*和*Vue.js*。

从终端开始，使用以下命令：

```
$ mkdir hello_files
$ cd hello_files
$ npm init
$ npm install -S electron
```

默认答案可以，除了输入点而不是`index.js`，输入`main.js`。完成后，您应该有一个如下的`package.json`文件：

```
{
  "name": "hello_files",
  "version": "0.0.1",
  "description": "A simple file browser using Node, Electron, and Vue.js",
  "main": "main.js",
  "dependencies": {
    "electron": "^1.7.9"
  }
}
```

现在，让我们来看看这三个命令：

```
$ ./node_modules/.bin/electron --version
$ ./node_modules/.bin/electron
$ ./node_modules/.bin/electron .
```

尝试第一种方法，确保 npm 在您的计算机上获得了一份电子的工作副本。在撰写本文时，当前版本为 v1.7.9。第二个命令将执行 electron“empty”，也就是说，不给它运行应用程序。第三个命令告诉 electron 运行此文件夹中的应用程序：electron 将读取`package.json`以查找并运行`main.js`。

或者，您可以使用`-g`全局安装 Electron，然后使用以下命令更容易地访问可执行文件：

```
$ npm install -g electron

$ electron --version
$ electron
$ electron .
```

# 电子

让我们运行第二个命令。结果可能令人惊讶：屏幕上会出现一个图形窗口！：

![](assets/74646cbc-c5e5-41ff-b207-9d1524a547a4.png)

What is this? What is Electron? Let's answer that question several ways: to the end user, to the developer or product owner, under the hood, and at the end of the chapter, from the perspective of JavaScript's history and development.

To the end user, an Electron app is just a regular desktop app. Users can't even tell it's made with Electron. The unboxing flow is exactly the same: the user gets the app from their favorite app store, or downloads `setup.exe` from your website. The daily experience is also the same: the app has an icon on the Start menu or dock, menus where they should be, a `File|Open...` dialog—all the features users expect from a desktop application. You might use Slack on Windows or macOS, for instance, and may be surprised to learn that Slack is made with Electron.

To the developer or product owner, Electron is a great way to make desktop apps. Developers can use the modern and powerful technologies they learned for the web on the desktop now. All your favorite npm modules can come along, too. Product owners like being able to ship version 1.0 simultaneously on Windows, Mac, and Linux with very little additional development or testing required. Business stakeholders like being able to task a single group of web developers across web and desktop projects, instead of having to hire new individual dedicated teams (a separate one per target operating system) experienced in each individual native desktop stack.

Under the hood, Electron is pretty amazing. It's built from parts of both Chromium and Node, getting abilities like page rendering from Chromium, and abilities like buffers, files, and sockets from Node. Both Chromium and Node contain V8, and inside V8 a JavaScript event loop, of course. In an impressive engineering feat, Electron merges these two event loops together, allowing a single JavaScript event to run code that affects both the screen and the system.

Electron is made by GitHub, which also develops the Atom text editor. To make Atom as hackable as the web, GitHub built it using web technologies. Realizing that other software teams might want to construct desktop apps this way, GitHub released their tools first as Atom Shell, and simplified the name to Electron.

现在我们已经有了 Electron，让我们让 Electron 成为我们自己的应用程序。`electron .`命令使 Electron 查看`package.json`以了解它应该做什么。这里，我们把它指向`main.js`：

```
// main.js

const electron = require('electron');
const app = electron.app;
const BrowserWindow = electron.BrowserWindow;

const path = require('path');
const url = require('url');

let mainWindow; // Keep this reference so the window doesn't close

function createWindow() {
  mainWindow = new BrowserWindow({width: 800, height: 800});
  mainWindow.loadURL(url.format({
    pathname: path.join(__dirname, 'index.html'),
    protocol: 'file:',
    slashes: true
  }));
  mainWindow.webContents.openDevTools();
  mainWindow.on('closed', () => {
    mainWindow = null;
  });
}

app.on('ready', createWindow);

app.on('window-all-closed', () => {
  app.quit();
});
```

您可以想象节点正在运行该文件，即使运行该文件的可执行文件实际上是 Electron（当然，里面有 Node 和 V8）。请注意，代码如何需要熟悉的节点模块，如`path`和`url`，以及一些新的节点模块，如`electron`。`main.js`中的代码创建了一个 800 像素宽、800 像素高的特殊电子浏览器窗口，并将其导航到`index.html`：

```
<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>Hello, files</title>
  </head>
  <body>
    <p>
      <input type="button" value="Reload the app after changing the code" onClick="window.location.reload()"/>
    </p>
    <div id="app">
      <p>{{ location }}</p>
      <button @click="up">..</button>
      <listing v-for="file in files" v-bind:key="file.id" v-bind:item="file"></listing>
      <p><img v-bind:src="image"/></p>
    </div>
    <script src="https://unpkg.com/vue"></script>
    <script>
      require('./renderer.js')
    </script>
  </body>
</html>
```

从我们在网络上的预期来看，这也很熟悉。我们将在本章后面讨论 Vue；现在，注意页面顶部的 reload`button`和末尾的`script`标记。

该按钮在开发时很有用。您不必在命令行重新启动 Electron 进程，只需更改此页面或它带来的 JavaScript，然后点击“重新加载”按钮即可查看结果。Electron 不显示 Chromium 的默认浏览器工具栏，其中有“重新加载”按钮，但在 macOS 的菜单栏上有“查看、重新加载”功能，在页面上放置“重新加载”按钮更容易。

要理解最后的`script`标签，最好首先对 Electron 的流程架构有一个基本的了解。

# 电子过程

电子继承了 Chromium（和 Chrome）的每个选项卡架构一个进程，它是由 Chromium 构建的。在 Electron 运行我们的应用程序时，只有一个“选项卡”：屏幕上的窗口，但仍有两个进程。*main*进程表示底层浏览器，您从命令行启动该浏览器，此时它读取`package.json`，然后运行`main.js`。Electron 的主流程可以创建新的`BrowserWindow`对象，并处理影响桌面应用程序整个生命周期（从启动到关闭）的事件。

然而，在 Electron 打开的页面上，另一个进程*呈现程序*进程在那里运行 JavaScript。只有渲染器进程能够执行与 GUI 相关的任务，如操作 DOM。

节点在两个进程中都可用。但是，如果模块希望 DOM 存在，则它可能无法在主进程中工作。例如，jQuery 无法加载到 Electron 的主进程中，但在渲染器进程中可以正常工作，而 Handlebar 在这两个进程中都可以正常工作。

当一个电子流程中的代码需要执行一个动作或从另一个流程中的某个代码获得答案时，解决方案是节点的标准进程间通信工具，稍后在[第 7 章](07.html)中描述，*使用多个进程*。此外，Electron 还方便地将其中一些封装在自己的 API 中。

# 渲染器进程

到目前为止，我们已经看到电子启动、运行`main.js`和打开`index.html`。总之，以下是整个过程的工作原理：

Electron 的*主*流程执行以下操作：

*   读到`package.json`，告诉它
*   运行`main.js`

这会导致 Electron 启动一个*渲染器*进程来执行以下操作：

*   解析`index.html`，然后
*   运行`renderer.js`

让我们看看那里的代码：

```
// renderer.js

const Promise = require("bluebird");
const fs = Promise.promisifyAll(require("fs"));
const path = require("path");

Vue.component('listing', {
  props: ['item'],
  template: '<div @click="clicked(item.name)">{{ item.name }}</div>',
  methods: {
    clicked(n) {
      go(path.format({ dir: app.location, base: n }));
    }
  }
});

var app = new Vue({
  el: '#app',
  data: {
    location: process.cwd(),
    files: [],
    image: null
  },
  methods: {
    up() {
      go(path.dirname(this.location));
    }
  }
});

function go(p) {

  if (p.endsWith(".bmp") || p.endsWith(".png") || p.endsWith(".gif") || p.endsWith(".jpg")) {

    // Image
    app.image = "file://" + p; // Show it

  } else {

    // Non-image
    app.image = null;

    // See if it's a directory or not
    fs.lstatAsync(p).then((stat) => {

      if (stat.isDirectory()) {

        // Directory, list its contents
        app.location = p;
        fs.readdirAsync(app.location).then((files) => {
          var a = [];
          for (var i = 0; i < files.length; i++)
            a.push({ id: i, name: files[i] });
          app.files = a;
        }).catch((e) => {
          console.log(e.stack);
        });
      } else {
        // Non-directory, don't go there at all
      }
    }).catch((e) => {
      console.log(e.stack);
    });
  }
}

go(app.location);
```

首先，此代码引入 bluebird promise 库，将其设置为`Promise`。对`Promise.promisifyAll()`的调用创建了`fs.lstatAsync()`之类的函数，这是`fs.lstat()`的预期版本。

我们的应用程序的核心逻辑被分解成一个名为`go()`的函数，该函数传递给用户希望应用程序查看的绝对文件系统路径。如果路径指向图像，则应用程序会将其显示在页面上。如果路径指向某个目录，应用程序将列出该文件夹的内容。

要执行此逻辑，前面的代码首先简单地查找公共图像文件扩展名。如果不存在，则异步步骤将使用`fs.lstatAsync()`查看磁盘，然后能够调用`stat.isDirectory()`。如果它是一个目录，另一个预期调用`fs.readdirAsync()`将获取目录列表。

下面是我们简单的电子文件浏览器的运行图片：

![](assets/c9740216-ac9e-4e7f-a15a-74a2a6ef710e.png)

# Vue.js

我们的应用程序的用户体验由*Vue.js*提供，这是一个前端 JavaScript 框架，用于构建和轻松更改网页内容。与 React 一样，Vue 允许您对组件进行模板化，将它们放在页面上，并在下面的数据发生更改时对其进行更改。

React 使用 JSX 将 HTML 标记与 JavaScript 代码结合起来。这需要像*Babel*这样的预处理器将 JSX 部分传输到 ES6JavaScript 中。在典型的 React 堆栈中，*webpack*管理一个构建过程，该过程包括 Babel，将您的开发文件转换并组合成您将运行、测试并最终部署的文件。WebpackDev 服务器在您编写站点代码时显示站点，甚至在您更改代码时自动刷新。

然而，Vue 不需要透明步骤。您可以将其与 webpack 一起使用，但也可以将其与一个脚本标记一起使用，就像我们应用程序的`index.html`中的这一个：

```
<script src="https://unpkg.com/vue"></script>
```

这种灵活性使 Vue 易于入门，使 Vue 易于在 Electron 中运行，这也是我们选择它作为示例应用程序的原因。

回到`index.html`页面，看看以下几行：

```
<div id="app">
  <p>{{ location }}</p>
  <button @click="up">..</button>
  <listing v-for="file in files" v-bind:key="file.id" v-bind:item="file"></listing&gt;
  <p><img v-bind:src="image"/></p>
</div>
<script src="https://unpkg.com/vue"></script>
```

另外，在`renderer.js`脚本中，请看这一部分：

```
var app = new Vue({
  el: '#app',
  data: {
    location: process.cwd(),
    files: [],
    image: null
  },
  methods: {
    up() {
      go(path.dirname(this.location));
    }
  }
});
```

在页面中，`<div id="app">`将`div`标识为我们的应用程序，在脚本中，`var app = new Vue({});`创建新的 JavaScript 对象，该对象连接并控制*应用程序*`div`。`app`中的数据对象定义了出现在 div 中的值，从而出现在页面上。例如，`app.location`通过与`this`巧妙的内部链接进入上面的`data`对象，显示在`{{ location }}`出现的页面上。Vue 甚至监视对`data.location`的更改—将其设置为新值，页面将自动更新。有了这个能力，Vue 被认为是*反应性*。

使用我们刚刚构建的文件浏览器浏览您的本地磁盘，想象一下您现在可以使用 Node 和 Electron 创建的所有桌面应用程序。

Earlier, this chapter asked, "What is Electron?" and composed different answers imagining different stakeholders and considering different perspectives.

Electron gets JavaScript one step closer to Kris Kowal's goal for the language, which you may remember from [Chapter 1](01.html), *Understanding the Node Environment*, is no less than "world domination", meaning able to run everywhere and do anything. Also, taking JavaScript's place in the last few decades of computing into consideration, it achieves this with some wry irony.

Brendan Eich created JavaScript to script small tasks within web pages running on browsers on personal computers in the 1990s, which had just recently gained bitmapped displays and graphical operating systems. There, JavaScript was tightly contained within the sandbox of the browser tab. The sandbox enforced strict security requirements, and limited it from, among other things, looking at some files. Close to the user and close to the screen, JavaScript could validate form data, and change CSS on the fly. In this first stage of life, most days, JavaScript animated some text.

Node took JavaScript to the server, distancing it from the graphical screen, but freeing it from the confines of the browser. There, JavaScript became a competent and complete systems language, accessing files and sockets to perform useful and powerful tasks. In this second stage of life, most days, JavaScript migrated a database.

Electron takes JavaScript back to the client. Like a wandering feudal warrior returning to his home village after years of exile, (and, of course, distant and elite training) JavaScript returns with ES6 features and npm modules it developed in the harsh wasteland of the server, being used and developed alongside formidable partners (and oftentimes foes) like C++ and Java. Back on the desktop and armed with Electron, it can use these abilities outside of the restricted confines of the browser. In this third stage of life, JavaScript really can do anything.

# 总结

在本章中，我们看到了 Node 的 API 是如何全面映射到本机文件系统绑定的，它向开发人员提供了一整套功能，同时只需要很少的代码或复杂性。此外，我们还了解了如何将文件轻松包装到`Stream`对象中，以及这种与节点设计其余部分的一致性如何简化不同类型 I/O 之间的交互，例如网络数据和文件之间的交互。使用 Electron，我们构建了一个作为跨平台本机应用程序运行的文件浏览器，为节点开发人员打开了一个全新的世界。

我们还了解了如何使用节点构建服务器，以满足常规客户机的期望，轻松实现文件上传和资源缓存。在介绍了 Node 的关键特性之后，现在是时候将这些技术用于构建能够处理数千个客户端的大型应用程序了。