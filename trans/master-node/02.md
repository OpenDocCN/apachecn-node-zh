Understanding Asynchronous Event-Driven Programming <link rel="stylesheet" href="css/style.css" type="text/css">   .koboSpan { -webkit-text-combine: inherit; }

# 理解异步事件驱动编程

"The best way to predict the future is to invent it." – Alan Kay

通过使用事件驱动的异步 I/O 消除阻塞过程是 Node 的主要组织原则。我们已经了解了这种设计如何帮助开发人员形成信息和增加容量。节点允许您构建和组织轻量级、独立且不共享的进程，这些进程通过回调进行通信，并与可预测的事件循环同步。

随着 Node 的普及，设计良好的事件驱动系统和应用程序的数量也在增长。为了使新技术获得成功，它必须消除现有的问题，和/或以较低的时间、精力或价格向消费者提供更好的解决方案。在其年轻而丰富的生命周期中，节点社区已经合作证明，这种新的开发模式是现有技术的可行替代方案。为企业级应用程序提供动力的基于节点的解决方案的数量和质量进一步证明，这些新想法不仅新颖，而且更受欢迎。

在本章中，我们将深入探讨 Node 如何实现事件驱动编程。首先，我们将对事件驱动语言和环境所衍生的思想和理论进行剖析，并努力消除误解，鼓励掌握。在对事件进行介绍之后，我们将了解事件循环的关键 Node.js 技术。然后，我们将更详细地介绍 Node 如何实现计时器、回调和 I/O 事件，以及作为节点开发人员如何使用它们。我们将进一步讨论使用现代工具（如**Promises**、**Generators**和**async/await**等）管理并发。我们将在构建一些简单但示例性的文件和数据驱动应用程序时实践该理论。这些示例突出了 Node 的优势，并展示了 Node 如何成功地实现其简化网络应用程序设计的目标。

# Node 的独特设计

首先，让我们准确地了解一下，当您的程序要求系统执行不同类型的服务时，总的时间成本。在下面的图表中（摘自*Ryan Dahl*在节点上的原始演示），我们可以看到典型系统任务消耗了多少时钟周期。I/O 操作的相对成本惊人：

| 一级缓存 | 3 个周期 |
| 二级缓存 | 14 个周期 |
| 公羊 | 250 个周期 |
| 圆盘 | 41000000 次循环 |
| 网络 | 240000000 次循环 |

原因很清楚：磁盘是一个物理设备，一个旋转的金属盘——存储和检索数据要比在固态设备（如微处理器和内存芯片）之间移动数据慢得多，甚至比优化的片上 L1/L2 缓存慢得多。类似地，数据不会在网络上瞬间从一点移动到另一点。光本身需要 0.1344 秒来环绕地球！在一个由数十亿人使用的网络中，经常以比光速慢得多的速度进行远距离交互，有很多弯路和很少的直线，这种延迟会逐渐增加。

当我们的软件在办公桌上的个人电脑上运行时，很少或根本没有通过网络进行通信。我们与文字处理器或电子表格交互的延迟或打嗝与磁盘访问时间有关。为提高磁盘访问速度做了大量工作。数据存储和检索变得更快，软件的响应性更强，用户现在希望他们的工具能够响应这种要求。

随着云计算和基于浏览器的软件的出现，您的数据已离开本地磁盘并存在于远程磁盘上，您可以通过 internet 上的网络访问这些数据。数据访问时间再次显著放缓。网络 I/O 速度很慢。然而，越来越多的公司正在将其应用程序的各个部分迁移到云中，一些软件完全基于网络。

节点的设计目的是加快 I/O 速度。它是为这个网络软件的新世界而设计的，在这个新世界中，数据在许多地方，必须快速组装。许多用于构建 web 应用程序的传统框架都是在这样一个时期设计的，即在桌面计算机上工作的单个用户使用浏览器定期向运行关系数据库的单个服务器发出 HTTP 请求。现代软件必须预期数万个同时连接的客户端通过各种网络协议在任意数量的独特设备上同时改变巨大的共享数据池。Node 是专门为帮助构建这种网络软件而设计的。

一旦认识到大多数工作线程将时间花在等待更多指令、完成子任务等方面，节点设计所反映的思维突破就很容易理解。例如，分配给服务命令*格式化我的硬盘*的进程将其分配的所有资源专用于管理工作流，如下所示：

*   向设备驱动程序发送已发出格式请求的信息
*   空闲，等待*未知*时间长度
*   接收完整的信号格式
*   通知客户
*   清理关闭：

![](assets/654909f4-ef43-4a75-9199-e145e067c376.png)

在上图中，我们看到一名昂贵的员工向客户收取每单位时间的固定费用，而不管是否正在做任何有用的工作（客户为活动和空闲支付的费用相同）。换句话说，组成总任务的每个子任务都需要类似的努力或专业知识，这不一定是真的，而且通常不是真的。因此，为如此廉价的劳动力支付高价是浪费。

同情地说，我们还必须认识到，即使这个工人已经准备好并能够处理更多的工作，他也不能做得更好——即使是最有意愿的工人也不能对 I/O 瓶颈做任何事情。这里的工作者是**I/O 绑定**。

相反，想象另一种设计。如果多个客户端可以共享同一个 worker，那么当一个 worker 由于 I/O 瓶颈而宣布可用时，另一个客户端的另一个作业就可以启动了，该怎么办？

Node 通过引入一个系统资源（理想情况下）**从不**空闲的环境，实现了 I/O 的商品化。Node 实现的事件驱动编程反映了通过鼓励共享昂贵的劳动力来降低总体系统成本的简单目标，主要是通过将 I/O 瓶颈数量减少到**零**。我们不再有一大块定价僵化的简单劳动力；我们可以将所有的努力减少到具有精确轮廓形状的离散单元中，从而允许更精确的定价。

在一个环境中，许多客户机作业都是协同调度的，这是什么样的环境？如何处理事件之间的消息传递？此外，并发性、并行性、异步执行、回调和事件对节点开发人员意味着什么？

# 协作

与前面描述的阻塞系统相比，更可取的是协作工作环境，在这种环境中，工人定期被分配新任务，而不是无所事事。为了实现这样一个目标，我们需要的是一个虚拟交换机，在这里服务请求被发送给可用的工作人员，工作人员通知交换机他们的可用性。

实现这一目标的一种方法是拥有一个可用的劳动力库，通过将任务分配给不同的工人来提高效率：

![](assets/57b70667-0b0f-44fa-a901-76806eda58ba.png)

这种方法的一个缺点是需要进行大量的调度和工人监督。dispatcher 必须处理稳定的请求流，同时管理来自工作者的关于其可用性的消息，将请求整齐地分解为可管理的任务并有效地对其进行排序，以使空闲的工作者数量最少

也许最重要的是，当所有员工都被预订满时会发生什么？调度程序是否开始删除来自客户端的请求？调度也是资源密集型的，甚至对调度程序的资源也有限制。如果请求继续到达，并且没有工作人员可以为其提供服务，那么调度员会怎么做？管理队列？现在的情况是，调度员不再做正确的工作（调度），而是负责记账和保存列表，进一步延长了每个任务完成所需的时间。每个任务都需要一定的时间，并且必须按照到达顺序进行处理。此任务执行模型堆叠固定的时间间隔-*滴答声*时间。这是*同步*执行。

# 排队

为了避免压倒任何人，我们可以在客户端和调度器之间添加一个缓冲区。这位新员工负责管理客户关系。客户机不直接与调度器通话，而是与服务管理器通话，传递管理器请求，并在将来的某个时候接到一个电话，告知他们的任务已经完成。工作请求被添加到一个按优先级排序的工作队列中（一堆订单，最重要的一个在上面），该经理等待另一个客户机进门

下图描述了这些情况：

![](assets/bcb39362-b03e-413f-9c99-a8e37f043fc4.png)

dispatcher 试图通过从该队列中提取任务、传回所有工作人员已完成的包，以及通常维护一个正常的工作环境（没有任何内容丢失或丢失），使所有工作人员保持忙碌。多个同时进行的作业在各自的时间线上并行运行，而不是沿着单个时间线逐个执行任务。如果到了所有工作人员都空闲且任务队列为空的时候，办公室可以休息一段时间，直到下一个客户机到达。

这是一个粗略的示意图，展示了节点如何通过*异步工作*而不是*同步工作*来提高速度。现在，让我们深入了解节点的事件循环是如何工作的。

# 了解事件循环

在我们分解事件循环时，以下三点非常重要：

*   事件循环在 JavaScript 代码运行的同一（单）线程中运行。阻塞事件循环意味着阻塞整个线程。
*   不启动和/或停止事件循环。事件循环在流程启动时立即启动，并在不再需要执行回调时结束。因此，事件循环可能永远运行。
*   事件循环将许多 I/O 操作委托给`libuv`，由`libuv`管理这些操作（使用操作系统本身的功能，如线程池），当结果可用时通知事件循环。单线程编程模型简单易懂，多线程处理效率高。

例如，以下`while`循环永远不会终止：

```js
let stop = false;
setTimeout(() => {
  stop = true;
}, 1000);

while (stop === false) {};
```

尽管人们可能期望在大约一秒钟内将布尔值`true`赋值给变量`stop`，从而使`while`条件跳闸并中断其循环；这永远不会发生。为什么？这个`while`循环通过无限地运行、贪婪地检查和重新检查一个从未有机会更改的值来饿死事件循环，因为事件循环从未有机会安排我们的计时器回调执行。这证明了事件循环（管理计时器）并在同一线程上运行。

根据 Node 文档，“事件循环允许 Node.js 执行非阻塞 I/O 操作——尽管 JavaScript 是单线程的——只要有可能就将操作卸载到系统内核。”节点设计者做出的关键设计选择是将事件循环实现为并发管理器。例如，通知基于节点的 HTTP 服务器与本地硬件的网络连接是由操作系统通过`libuv`传递网络接口事件来处理的。

以下是事件驱动编程的描述（摘自：[http://www.princeton.edu/~achaney/tmve/wiki100k/docs/Event-driven_programming.html](http://www.princeton.edu/~achaney/tmve/wiki100k/docs/Event-driven_programming.html)不仅清楚地描述了事件驱动的范例，而且还向我们介绍了如何在节点中处理事件，以及 JavaScript 如何成为这种范例的理想语言。

在计算机编程中，事件驱动编程或基于事件的编程是一种编程范式，其中程序流由事件决定，即传感器输出或用户动作（鼠标点击、按键）或来自其他程序或线程的消息。事件驱动编程也可以定义为一种应用程序体系结构技术，在这种技术中，应用程序有一个主循环，该主循环明确地分为两部分：第一部分是事件选择（或事件检测），第二部分是事件处理[…]。事件驱动程序可以用任何语言编写，尽管在提供高级抽象（如闭包）的语言中任务更容易。访问[https://www.youtube.com/watch?v=QQnz4QHNZKc](https://www.youtube.com/watch?v=QQnz4QHNZKc) 了解更多信息。

Node 通过将许多阻塞操作委托给操作系统子系统来处理，使得单个线程的效率更高，只有当有可用数据时，才会干扰主 V8 线程。主线程（您正在执行的节点程序）通过传递回调表示对某些数据感兴趣（例如通过`fs.readFile`），并在数据可用时收到通知。在数据到达之前，V8 的主 JavaScript 线程不会承受更多的负担。怎样节点将 I/O 工作委托给`libuv`，引用自：[http://nikhilm.github.io/uvbook/basics.html#event-循环](http://nikhilm.github.io/uvbook/basics.html#event-loops)。

在事件驱动编程中，应用程序对某些事件表示兴趣，并在事件发生时作出响应。`libuv`负责从操作系统收集事件或监控其他事件源，用户可以注册事件发生时调用的回调。

*Matteo Collina* has created an interesting module for benchmarking the event loop, which is available at: [https://github.com/mcollina/loopbench](https://github.com/mcollina/loopbench).

考虑下面的代码：

```js
const fs = require('fs');
fs.readFile('foo.js', {encoding:'utf8'}, (err, fileContents) => {
  console.log('Then the contents are available', fileContents);
});
console.log('This happens first');
```

该程序的输出为：

```js
> This happens first
> Then the contents are available, [file contents shown]
```

以下是 Node 在执行此程序时所做的操作：

1.  使用 V8API 创建 C++中的进程对象。然后将 Node.js 运行时导入到这个 V8 进程中。
2.  `fs`模块连接到节点运行时。V8 将 C++暴露为 JavaScript。这提供了对 JavaScript 代码的本机文件系统绑定的访问。

3.  `fs.readFile`方法已传递指令和 JavaScript 回调。通过`fs.binding`通知`libuv`文件读取请求，并将原程序发送的回调的特别准备版本传递给`libuv`。
4.  `libuv`调用读取文件所需的操作系统级函数。
5.  JavaScript 程序继续打印`This happens first`。因为有一个回调未完成，所以事件循环继续旋转，等待回调解析。
6.  当操作系统完全读取文件描述符时，通知`libuv`（通过内部机制），并调用传递给`libuv`的回调，这基本上为重新进入主（V8）线程准备了原始 JavaScript 回调。
7.  最初的 JavaScript 回调被推送到事件循环上，并在不久的将来循环的某一时刻被调用。
8.  文件内容将打印到控制台。
9.  由于航班回调过程中没有进一步的退出。

在这里，我们看到了 Node 实现快速、可管理和可伸缩 I/O 的关键思想。例如，如果在前面的程序中对`foo.js`进行了 10 次读取调用，那么执行时间将保持大致相同。`libuv`将尽可能高效地管理每个调用（例如，通过使用线程并行化调用）。尽管我们用 JavaScript 编写代码，但实际上我们正在部署一个非常高效的多线程执行引擎，同时避免了操作系统异步进程管理的困难。

既然我们知道了文件系统操作是如何工作的，那么让我们深入了解事件循环中如何处理能够生成的每种类型的异步操作节点。

# 事件循环顺序、阶段和优先级

事件循环通过各个阶段进行，每个阶段都有一个要处理的事件队列。从节点文档中：

![](assets/d3cdf6c5-7bf6-4a11-8fc0-fdba8cd39ffb.png)

与开发商相关的阶段如下：

*   **计时器**：延迟到未来某个指定时间的回调，以毫秒为单位，如`setTimeout`和`setInterval`
*   **I/O 回调**：准备好的回调被委托到节点的托管线程池后返回到主线程，如文件系统调用和网络侦听器
*   **轮询/检查**：主要是按照`setImmediate`和`nextTick`的规则在栈上开槽的函数

当数据在套接字或其他流接口上可用时，我们不能简单地立即执行回调。JavaScript 是单线程的，因此结果必须同步。我们不能在事件循环的中间突然改变状态——这将创建一些经典的多线程应用程序的竞赛条件、内存访问冲突等问题。

To learn more about how Node is bound to `libuv` and other core libraries, parse through the `fs` module code at: [https://github.com/nodejs/node/blob/master/lib/fs.js](https://github.com/nodejs/node/blob/master/lib/fs.js). Compare the `fs.read` and the `fs.readSync` methods to observe the difference between how synchronous and asynchronous actions are implemented; note the wrapper callback that is passed to the native `binding.read` method in `fs.read`. To take an even deeper dive into the very heart of Node's design, including the queue implementation, read through the Node source at: [https://github.com/joyent/node/tree/master/src](https://github.com/joyent/node/tree/master/src). Follow `FSEventWrap` within `fs_event_wrap.cc`. Investigate the `req_wrap` class, a wrapper for the V8 engine, deployed in `node_file.cc` and elsewhere and defined in `req_wrap.h`.

进入事件循环后，节点实际上会复制当前指令队列（也称为**堆栈**），清空原始队列，并执行其副本。此指令队列的处理称为**勾选**。如果`libuv`在单主线程（V8）上处理此勾选开始时复制的指令链时异步接收结果，则这些结果（包装为回调）将排队。清空当前队列并完成其最后一条指令后，将再次检查队列中是否有要在下一次勾选时执行的指令。这种检查和执行队列的模式将重复（循环），直到队列被清空，并且不需要进一步的数据事件，此时节点进程将退出。

接下来，让我们看看 Node 的事件接口。

# 倾听事件

由于各种原因，现代网络软件正变得越来越复杂，并在许多方面改变了我们对应用程序开发的看法。大多数新的平台和语言都试图解决这些变化。Node 也不例外，JavaScript 也不例外。

学习 Node 意味着学习事件驱动编程、用模块组合软件、创建和链接数据流、生成和使用事件及其相关数据。基于节点的体系结构通常由许多与事件通信的小流程和/或服务组成——在内部，通过扩展`EventEmitter`接口和使用回调，在外部，通过几个公共传输层（例如 HTTP、TCP）之一，或通过覆盖其中一个传输层的精简消息层（例如，0MQ、Redis PUBSUB 和 Kafka）。

这些过程很可能由几个免费的、开源的、高质量的 npm 模块组成，每个模块都与单元测试和/或示例和/或文档一起分发。

上一章介绍了`EventEmitter`界面。这是我们在一章接一章的过程中将遇到的主要事件接口，因为它为暴露事件接口（如文件和网络流）的许多节点对象提供了原型类。不同模块 API 暴露的各种`close`、`exit`、`data`和其他事件表明`EventEmitter`接口的存在，我们将随着进度了解这些模块和用例。

在本节中，我们的目标是讨论一些鲜为人知的事件源：信号、子进程通信、文件系统更改事件和延迟执行。

# 信号

事件编程类似于硬件中断编程。中断完全按照其名称执行。他们利用自己的能力中断控制器、CPU 或任何其他设备正在执行的任何操作，要求立即为他们的特定需求提供服务。

事实上，节点进程对象公开了标准的**便携式操作系统接口（POSIX）**信号名称，使得节点进程可以订阅这些系统事件。

As [http://en.wikipedia.org/wiki/POSIX_signal](http://en.wikipedia.org/wiki/POSIX_signal) defines, "A signal is a limited form of inter-process communication used in Unix, Unix-like, and other POSIX-compliant operating systems. It is an asynchronous notification sent to a process, or to a specific thread, within the same process in order to notify it of an event that occurred."

这是向操作系统信号事件公开节点进程的一种非常优雅和自然的方式。可以将侦听器配置为捕获指示节点进程重新启动或更新某些配置文件的信号，或者简单地清理并关闭。

例如，当其控制终端检测到*Ctrl*+*C*（或等效）击键时，**SIGINT**信号被发送到进程。此信号告诉进程已请求中断。如果节点进程已将回调绑定到此事件，则该函数可能会在终止之前记录请求，执行一些其他清理工作，甚至忽略该请求：

```js
// sigint.js
console.log("Running...");

// After 16 minutes, do nothing
setInterval(() => {}, 1e6); // Keeps Node running the process

// Subscribe to SIGINT, so some of our code runs when Node gets that signal
process.on("SIGINT", () => {
    console.log("We received the SIGINT signal!");
    process.exit(1);
});
```

以下是`sigint.js`的输出：

```js
$ node sigint.js
Running...
(then press Ctrl+C)
We received the SIGINT signal!
```

本例开始的时间间隔很长，所以节点不会在没有其他事情要做的情况下退出。当您通过控制过程的终端从键盘发送*Ctrl*+*C*时，节点从操作系统获取信号。您的代码已订阅该事件，节点运行您的函数。现在，考虑一个节点进程正在执行一些正在进行的工作的情况，例如解析日志。能够向该进程发送信号（例如更新配置文件或重新启动扫描）可能会很有用。您可能希望从命令行发送此类信号。您可能更愿意让另一个进程这样做—一种称为**进程间通信**（IPC）的实践。

创建一个名为`ipc.js`的文件，输入以下代码：

```js
// ipc.js
setInterval(() => {}, 1e6);
process.on("SIGUSR1", () => {
    console.log("Got a signal!");
});
```

运行以下命令：

```js
$ node ipc.js
```

与之前一样，Node 将在运行空函数之前等待大约 16 分钟，以保持进程处于打开状态，因此您必须*Ctrl*+*C*才能返回提示。注意，即使在这里，我们还没有订阅 SIGINT 信号，这也可以正常工作。

`SIGUSR1`（和`SIGUSR2`）是用户定义的信号，由操作系统不知道的特定动作触发。它们用于定制功能。

您必须在进程中发送一个 ID**和一个进程中的一个 PID】来确定它的地址。如果通过节点运行后分配给`ipc.js`的 PID 为`123`，则我们可以使用`kill`命令向该流程发送`SIGUSR1`信号：**

```js
$ kill –s SIGUSR1 123
```

A simple way to find the PID for a given Node process in UNIX is to search the system process list for the name of the program that says the process is running. If `ipc.js` is currently executing, its PID is found by entering the following command line in the console/terminal:
`ps aux | grep ipc.js`. Try it.

# 子进程

例如，节点设计的一个基本部分是在并行执行或扩展系统时创建或分叉进程，而不是创建线程池。在本书中，我们将以各种方式使用这些子进程。现在，理解孩子之间的沟通过程将是正确的。

要创建子进程，需要节点的`child_process`模块，并调用`fork`方法。传递新进程应执行的程序文件的名称：

```js
let cp = require("child_process");
let child = cp.fork(__dirname + "/lovechild.js");
```

您可以使用此方法保持任意数量的子进程运行。在多核机器上，操作系统将在可用的硬件核心之间分配分叉进程。将节点进程分布到内核，甚至其他机器上，并管理 IPC 是以稳定、可理解和可预测的方式扩展节点应用程序的一种方法。

扩展前面的示例，我们现在可以让分叉进程（`parent`）发送并侦听来自分叉进程（`child`的消息。`parent.js`代码如下：

```js
// parent.js
const cp = require("child_process");
let child = cp.fork(__dirname + "/lovechild.js");

child.on("message", (m) => {
  console.log("Child said: ", m); // Parent got a message up from our child
});
child.send("I love you"); // Send a message down to our child
```

以下是`parent.js`的输出：

```js
$ node parent.js
Parent said:  I love you
Child said:  I love you too
(then Ctrl+C to terminate both processes)
```

在该文件旁边，制作另一个文件并将其命名为`lovechild.js`。此处孩子的代码可以侦听消息并将其发送回：

```js
// lovechild.js
process.on("message", (m) => {
  console.log("Parent said: ", m); // Child got a message down from the parent
  process.send("I love you too"); // Send a message up to our parent
});
```

不要自己跑；`--parent.js`会用叉子帮你做的！运行`parent.js`的

应该分叉一个子进程并向该子进程发送一条消息。儿童应以实物回应：

```js
Parent said:  I love you
Child said:  I love you too
```

在`parent.js`运行时，检查操作系统的任务管理器。将有两个节点进程，而不是像前面的示例那样只有一个。

另一个非常强大的想法是向网络服务器传递一个对象给孩子。这种技术允许多个进程（包括父进程）分担服务连接请求的责任，从而将负载分散到各个核心。

例如，以下程序将启动网络服务器，分叉子进程，并将服务器引用从父进程传递给子进程：

```js
// net-parent.js
const path = require('path');
let child = require("child_process").fork(path.join(__dirname, "net-child.js"));
let server = require("net").createServer();

server.on("connection", (socket) => {
  socket.end("Parent handled connection");
});

server.listen(8080, () => {
  child.send("Parent passing down server", server);
});
```

除了将消息作为要发送的第一个参数传递给子进程外，前面的代码还将服务器句柄作为第二个参数发送给自身。我们的子服务器现在可以帮助家庭服务业务：

```js
// net-child.js
process.on("message", function(message, server) {
  console.log(message);
  server.on("connection", function(socket) {
    socket.end("Child handled connection");
  });
});
```

此子进程应将发送的消息打印到控制台，并开始侦听连接，共享发送的服务器句柄。

在`localhost:8080`重复连接到此服务器将导致显示子处理连接或父处理连接；两个独立的进程正在平衡服务器负载。该技术与前面讨论的简单进程间消息传递协议相结合，展示了*Ryan Dahl 的*创建如何成功地提供了一种构建可伸缩网络程序的简单方法。

我们用几行代码连接了两个节点。

We will discuss Node's new cluster module, which expands and simplifies the previously discussed technique in [Chapter 7](07.html), *Using Multiple Processes*. If you are interested in how server handles are shared, visit the cluster documentation: [https://nodejs.org/dist/latest-v9.x/docs/api/cluster.html](https://nodejs.org/dist/latest-v9.x/docs/api/cluster.html)

# 文件事件

大多数应用程序在某种程度上利用了文件系统，特别是那些作为 web 服务运行的应用程序。此外，专业应用程序可能会记录有关使用情况的信息，缓存预渲染的数据视图，或对文件和目录结构进行其他更改。节点允许开发人员通过`fs.watch`方法注册文件事件通知。`watch`方法在文件和目录上广播更改的事件。

`watch`方法按顺序接受三个参数：

*   正在监视的文件或目录路径。如果该文件不存在，将抛出一个**eNONT（无实体）**错误，因此鼓励在之前有用的点上使用`fs.exists`。
*   可选选项对象，包括：
    *   持久化（布尔值默认值为 true）：只要有*事情要做*，节点就保持进程处于活动状态。将此选项设置为*false*以允许节点关闭进程，即使您的代码仍有文件监视程序在监视。
    *   递归（布尔默认值 false）：是否自动下降到子目录中。注意：这不是跨平台一致实现的。出于这个原因和性能原因，您应该显式地控制正在监视的文件列表，而不是随机监视目录。
    *   编码（字符串默认值`utf8`：传递文件名的字符编码。你可能不需要改变这个。
*   `listener`函数，接收两个参数：

    *   更改事件的名称（重命名或更改之一）
    *   更改的文件名（查看目录时很重要）

此示例将在其自身上设置观察程序，更改其自身的文件名，然后退出：

```js
const fs = require('fs');
fs.watch(__filename, { persistent: false }, (event, filename) => {
  console.log(event);
  console.log(filename);
})

setImmediate(function() {
  fs.rename(__filename, __filename + '.new', () => {});
});
```

两行，`rename`和原始文件的名称应该已经打印到控制台。

每当您想使用以下代码时，请关闭您的观察者频道：

```js
let w = fs.watch('file', () => {});
w.close();
```

需要注意的是，`fs.watch`在很大程度上取决于主机操作系统处理文件事件的方式，节点文档中说：

"The fs.watch API is not 100% consistent across platforms, and is unavailable in some situations."

作者在许多不同的系统中使用该模块都有很好的经验，只注意到在 OSX 实现的回调中 filename 参数为 null。不同的系统也可能以某种方式强制区分大小写。尽管如此，请确保在特定的体系结构上运行测试-信任，但验证。

Alternatively, use a third-party package! If you encounter difficulties with a Node module, check npm for alternatives. Here, as a problem-fixing wrapper on top of `fs.watch`, consider *Paul Miller's* *chokidar*. It is used as the file-watching tool for build systems like gulp, and in many other projects. Refer to: [https://www.npmjs.com/package/chokidar](https://www.npmjs.com/package/chokidar).

# 延期执行

有时需要推迟函数的执行。传统的 JavaScript 为此目的使用计时器，并具有众所周知的`setTimeout`和`setInterval`函数。Node 引入了关于延迟的另一个透视图，主要是作为控制回调相对于 I/O 事件的执行顺序以及正确的计时器事件的方法。

如前所述，管理计时器是节点事件循环的主要任务之一。两种类型的延迟事件源使开发人员能够在处理排队 I/O 事件之前或之后安排回调执行，它们是`process.nextTick`和`setImmediate`。现在让我们看看这些。

# process.nextTick

本机节点处理模块`process.nextTick`的一种方法类似于熟悉的`setTimeout`方法，它将回调函数的执行延迟到将来的某个时间点。然而，这种比较并不准确；所有请求的`nextTick`回调的列表都放在事件队列的头部，并在 I/O 或计时器事件之前和当前脚本执行之后（在 V8 线程上同步执行的 JavaScript 代码）按顺序进行处理。

`nextTick`在函数中的主要用途是推迟向当前执行堆栈上的侦听器广播结果事件，直到调用方有机会注册事件侦听器，从而使当前执行的程序有机会将回调绑定到`EventEmitter.emit`事件。

可以将此视为一种模式，可以在您希望创建自己的异步行为的任何地方使用。例如，设想一个查找系统，它可以从缓存中提取数据，也可以从数据存储中提取新数据。缓存速度快，不需要回调，而数据 I/O 调用则需要回调。

第二种情况下需要回调，因此需要模拟回调行为，第一种情况下为`nextTick`。这允许一个一致的 API，提高了实现的清晰性，而不会使开发人员承担决定是否使用回调的责任。

下面的代码似乎设置了一个简单的事务；当`EventEmitter`实例发出启动事件时，将`Started`记录到控制台：

```js
const events = require('events');
function getEmitter() {
  let emitter = new events.EventEmitter();
  emitter.emit('start');
  return emitter;
}

let myEmitter = getEmitter();

myEmitter.on("start", () => {
  console.log("Started");
});
```

但是，您可能期望的结果不会发生！在`getEmitter`中实例化的事件发射器在返回之前发出`start`，错误地执行侦听器的后续分配，该侦听器延迟了一步，丢失了事件通知。

为了解决这个竞态条件，我们可以使用`process.nextTick`：

```js
const events = require('events');
function getEmitter() {
  let emitter = new events.EventEmitter();
  process.nextTick(() => {
    emitter.emit('start');
  });
  return emitter;
}

let myEmitter = getEmitter();
myEmitter.on('start', () => {
  console.log('Started');
});
```

此代码在节点给出`start`事件之前附加`on("start")`处理程序，并正常工作。

错误代码可以递归调用`nextTick`，导致代码无休止循环运行。请注意，与在事件循环的单圈内递归调用函数不同，这样做不会导致堆栈溢出。相反，它将耗尽事件循环，搅乱微处理器上的进程，并可能阻止程序发现节点已完成的 I/O。

# 立竿见影

`setImmediate`在技术上与`setInterval`和`setTimeout`属于计时器类别。但是，它没有时间感——没有等待参数发送的*毫秒数*。

此方法实际上更像是`process.nextTick`的同级，在一个非常重要的方面有所不同：`nextTick`排队的回调将在 I/O 和计时器事件之前执行，而`setImmediate`排队的回调将在 I/O 事件之后调用。

The naming of these two methods is confusing: Node will actually run the function you give to `nextTick` before the one you pass to `setImmediate`.

此方法确实反映了计时器的标准行为，因为其调用将返回一个可传递给`clearImmediate`的对象，以`clearTimeout`取消使用`setTimeout`设置的计时器的方式取消您稍后运行函数的请求。

# 计时器

计时器用于安排未来的事件。当一个人试图延迟某个代码块的执行直到指定的毫秒数过去时，可以使用它们来安排特定函数的周期性执行，等等。

JavaScript 提供了两个异步计时器：`setInterval()`和`setTimeout()`。假设读者完全知道如何设置（和取消）这些计时器，因此讨论语法的时间很少。相反，我们将更多地关注 gotchas，以及关于超时和间隔的不太为人所知的细节。

关键在于：在使用计时器时，不应假设在为该计时器注册的回调触发之前实际过期的时间量，也不应假设回调的顺序。节点计时器不是中断。计时器只是承诺尽可能接近指定的时间执行（尽管以前从未如此），与其他所有事件源一样，受制于事件循环调度。

At least one thing you may not know about timers-we are all familiar with the standard arguments to `setTimeout`: a callback function and timeout interval. Did you know that many additional arguments are passed to the `callback` function? `setTimeout(callback, time, [passArg1, passArg2…])`

# 设置超时

超时可用于将函数的执行延迟到将来的毫秒数。

考虑下面的代码：

```js
setTimeout(a, 1000);
setTimeout(b, 1001);
```

人们会期望函数`b`在函数`a`之后执行。但是，这不能保证-`a`可能跟在`b`后面，或者反过来。现在，考虑下面代码片段中存在的细微差别：

```js
setTimeout(a, 1000);
setTimeout(b, 1000);
```

在这种情况下，`a`和`b`的执行顺序是可预测的。Node 本质上维护一个对象映射分组回调，具有相同的超时长度。*Isaac Schlueter*是 Node 项目的前领导者，现在是 npm Inc.的首席执行官，他这样说：

As we can find on [https://groups.google.com/forum/#!msg/nodejs-dev/kiowz4iht4Q/T0RuSwAeJV0J](https://groups.google.com/forum/#!msg/nodejs-dev/kiowz4iht4Q/T0RuSwAeJV0J), "[N]ode uses a single low level timer object for each timeout value. If you attach multiple callbacks for a single timeout value, they'll occur in order, because they're sitting in a queue. However, if they're on different timeout values, then they'll be using timers in different threads, and are thus subject to the vagaries of the [CPU] scheduler."

在相同的执行范围内注册的计时器回调的顺序并不能预测所有情况下的最终执行顺序。此外，超时的最小等待时间为 1 毫秒。传递零值、-1 或非数字将转换为该最小值。

要取消超时，请使用`clearTimeout(timerReference)`。

# 设定间隔

我们可以想到许多情况下，能够定期执行函数会很有用。每隔几秒钟轮询一次数据源并推送更新是常见的模式。每隔几毫秒运行动画中的下一步是另一个用例，收集垃圾也是如此。对于这些情况，`setInterval`是一个很好的工具：

```js
let intervalId = setInterval(() => { ... }, 100);
```

发送的回调函数每 100 毫秒执行一次，该过程可通过`clearInterval(intervalReference)`取消。

不幸的是，与`setTimeout`一样，这种行为并不总是可靠的。重要的是，如果一个系统延迟（例如一些写得不好的阻塞`while`循环）占用事件循环一段时间，那么在该时间段之前设置并在该时间段内完成的间隔将使其结果在堆栈上排队。当事件循环解除阻塞并展开时，所有的间隔回调都将按顺序启动，基本上是立即启动的，从而丢失它们预期的任何类型的时间延迟。

幸运的是，与基于浏览器的 JavaScript 不同，节点中的间隔更加可靠，通常能够在正常使用场景中保持预期的周期性。

# unref 和 ref

如果没有理由，节点程序不会保持活动状态。只要仍有回调等待处理，进程就会一直运行。一旦清除了这些，节点进程就没有什么可做的了，它将退出。

例如，以下愚蠢的代码片段将使节点进程永远运行：

```js
let intervalId = setInterval(() => {}, 1000);
```

即使 set 回调函数没有做任何有用或有趣的事情，它仍然会被调用。这是正确的行为，因为间隔应该一直运行，直到使用`clearInterval`停止。

在某些情况下，使用计时器对外部 I/O、某些数据结构或网络接口执行一些有趣的操作，一旦这些外部事件源停止发生或消失，计时器本身就变得不必要了。通常，人们会在程序中的其他地方捕获计时器的不相关状态，然后从那里取消计时器。这可能会变得困难甚至笨拙，因为现在有必要对关注点进行不必要的纠缠，增加复杂性。

该`unref`方法允许开发人员断言以下指令：当该计时器是事件循环要处理的唯一剩余事件源时，继续并终止该过程。

让我们用上一个愚蠢的例子来测试这个功能，这将导致进程终止而不是永远运行：

```js
let intervalId = setInterval(() => {}, 1000);
intervalId.unref();
```

注意，`unref`是启动计时器时返回的不透明值的方法，计时器是一个对象。

现在，让我们添加一个外部事件源，一个计时器。一旦清除了外部源（大约 100 毫秒），进程将终止。我们向控制台发送信息以记录发生的情况：

```js
setTimeout(() => {
  console.log("now stop");
}, 100);

let intervalId = setInterval(() => {
  console.log("running")
}, 1);

intervalId.unref();
```

您可以使用`ref`将计时器返回到其正常行为，这将撤消`unref`方法：

```js
let intervalId = setInterval(() => {}, 1000);
intervalId.unref();
intervalId.ref();
```

所列出的过程将无限期地继续下去，就像我们最初愚蠢的例子一样。

小测验！运行以下代码后，所记录消息的预期顺序是什么？

```js
const fs = require('fs');
const EventEmitter = require('events').EventEmitter;
let pos = 0;
let messenger = new EventEmitter();

// Listener for EventEmitter
messenger.on("message", (msg) => {
  console.log(++pos + " MESSAGE: " + msg);
});

// (A) FIRST
console.log(++pos + " FIRST");

//  (B) NEXT
process.nextTick(() => {
  console.log(++pos + " NEXT")
})

// (C) QUICK TIMER
setTimeout(() => {
  console.log(++pos + " QUICK TIMER")
}, 0)

// (D) LONG TIMER
setTimeout(() => {
  console.log(++pos + " LONG TIMER")
}, 10)

// (E) IMMEDIATE
setImmediate(() => {
  console.log(++pos + " IMMEDIATE")
})

// (F) MESSAGE HELLO!
messenger.emit("message", "Hello!");

// (G) FIRST STAT
fs.stat(__filename, () => {
  console.log(++pos + " FIRST STAT");
});

// (H) LAST STAT
fs.stat(__filename, () => {
  console.log(++pos + " LAST STAT");
});

// (I) LAST
console.log(++pos + " LAST");
```

该程序的输出为：

```js
FIRST (A).
MESSAGE: Hello! (F).
LAST (I).
NEXT (B).
QUICK TIMER (C).
FIRST STAT (G).
LAST STAT (H).
IMMEDIATE (E).
LONG TIMER (D).
```

我们来分解前面的代码：

A、F 和 I 在主程序流中执行，因此它们在主线程中具有第一优先级。这是显而易见的；JavaScript 按照指令的写入顺序执行指令，包括同步执行 emit 回调。

随着主调用堆栈耗尽，事件循环现在几乎正在读取以处理 I/O 操作。此时，`nextTick`请求得到满足，在事件队列的最前面插入。此时显示 B。

订单的其余部分应该清楚。接下来将处理计时器和 I/O 操作，（C、G、H），然后是`setImmediate`回调（E）的结果，总是在执行任何 I/O 和计时器响应后到达。

最后，长超时（D）到达，这是一个相对遥远的未来事件。

请注意，对该程序中的表达式重新排序不会改变 STAT 结果可能重新排序之外的输出顺序，这只意味着它们已从线程池以不同的顺序返回，并作为一个组以与事件队列相关的正确顺序保留。

# 并发性和错误

节点社区的成员每天开发新的包和项目。由于节点的事件性质，回调渗透到这些代码库中。我们考虑了通过使用回调对事件进行排队、调度和处理的几种关键方法。让我们花一点时间概括一下最佳实践，特别是关于设计回调和处理错误的约定，并讨论在设计复杂的事件链和回调时一些有用的模式。特别是，让我们看一下本书中介绍的新 Promise、Generator 和 async/await 模式，以及其他现代节点代码示例。

# 管理并发性

从项目一开始，简化控制流就一直是节点社区关注的问题。事实上，这一潜在的批评是*Ryan Dahl*最先想到的批评之一，他在向 JavaScript 开发人员社区介绍 Node 的演讲中详细讨论了这一点。

由于延迟代码执行通常需要在回调中嵌套回调，因此节点程序有时会开始类似于一个侧面金字塔，也称为*厄运金字塔*。您已经看到了它：深度嵌套的代码，4、5 级甚至更多级别的深度，到处都是花括号。除了语法上的麻烦，您还可以想象，如果第三级的回调抛出，那么在这样的调用堆栈中跟踪错误可能很困难，谁负责处理该错误？第二层？即使级别 2 正在读取文件，级别 3 正在查询数据库？这有意义吗？异步程序流可能很难理解。

# 回调

幸运的是，节点创建者就如何尽早构造回调达成了一致。遵循这一传统很重要。偏差会导致意外，有时是非常糟糕的意外，一般来说，这样做会使 API 变得笨拙，这是其他开发人员很快就会厌倦的特征。

一种是通过执行`callback`返回函数结果，处理`callback`接收的参数，或者在 API 中为`callback`设计签名。无论审议哪种情况，都应遵守与该案件有关的公约。

The first argument returned to a `callback` function is any error message, preferably in the form of an error object. If no error is to be reported, this slot should contain a null value.

将`callback`传递给函数时，应为其分配函数签名的最后一个插槽。API 应始终以这种方式设计。

错误和`callback`插槽之间可能存在任意数量的参数。

To create an error object: `new Error("Argument must be a String!")`

# 承诺

像一些政客一样，节点核心在支持他们之前就反对承诺。*Mikeal Rogers*在讨论为何从原始节点核心中删除承诺时，对为何将功能开发留给社区导致更强大的核心产品提出了强有力的论点。您可以在以下网址查看此讨论：[https://web.archive.org/posts/broken-promises.html](https://web.archive.org/posts/broken-promises.html)

从那时起，Promises 获得了大量的追随者，节点核心也随之发生了变化。承诺本质上是对节点中随处可见的标准回调模式的替代。有一次，您可能会这样写：

```js
API.getUser(loginInfo, function(err, user) {
    API.getProfile(user, function(err, profile) {
        // ...and so on
    }
});
```

如果 API 改为“Promisified”（回想上一章中的`util.promisify`），则您对前面异步控制流的描述将使用承诺链进行描述：

```js
let promiseProfile = API.getUser(loginInfo)
.then(user => API.getProfile(user))
.then(profile => {
    // do something with #profile
})
.catch(err => console.log(err))
```

这至少是一个更紧凑的语法，读起来更容易，操作链更长；然而，这里还有更多有价值的东西。

`promiseProfile`引用承诺对象。承诺只执行一次，达到错误状态（未实现）或已实现状态，在此状态下，您可以通过`then`提取最后一个不可变的值，就像我们之前对概要文件所做的那样。当然，承诺可以分配给变量，并且该变量可以传递给任意多的消费者，甚至在解析之前。由于`then`仅在存在可用值时调用，因此无论何时，承诺都被恰当地命名为未来状态的承诺

也许最重要的是，与回调不同，承诺能够跨许多异步操作管理错误。如果回过头来看本节开头的示例回调代码，您将在每个回调中看到 err 参数，反映节点的核心 error-first 回调样式。这些错误对象中的每一个都必须单独处理，因此前面的代码实际上看起来更像这样：

```js
API.getUser(loginInfo, function(err, user) {
  if(err) {
    throw err;
  }
  API.getProfile(user, function(err, profile) {
    if(err) {
      throw err;
    }
    // ...and so on
  }
});
```

观察每个错误情况必须如何单独处理。在实践中，开发人员希望负责“手动滚动”围绕此代码的包装器，例如`try...catch`块，它将以某种方式捕获此逻辑单元中的所有错误，并以集中的方式对其进行管理。

有了承诺，你就可以免费得到。任何`catch`语句都将捕获链中任何`then`之前抛出的任何错误。这使得创建一个常见的错误处理程序成为一个简单的过程。更重要的是，承诺允许执行链在错误之后继续运行。您可以将以下内容添加到上一个承诺链：

```js
.catch(err => console.log(err))
.then(() => // this happens no matter what happened previously)
```

通过这种方式，Promissions 允许您在更少的空间中以有限的缩进组成相当复杂、异步的逻辑流，在缩进中，错误处理更容易处理，并且值是不可变和可交换的。

Promise 对象的另一个非常有用的特性是，这些未来的解析状态可以作为块进行管理。例如，假设要完成对用户配置文件的查询，需要进行三次数据库调用。您可以使用`Promise.all`来链接这些始终连续运行的调用，而不是按顺序一次链接一个调用：

```js
const db = {
  getFullName: Promise.resolve('Jack Spratt'),
  getAddress: Promise.resolve('10 Clean Street'),
  getFavorites: Promise.resolve('Lean'),
};

Promise.all([
  db.getFullName() 
  db.getAddress() 
  db.getFavorites() 
])
.then(results => {
  // results = ['Jack Spratt', '10 Clean Stree', 'Lean']
})
.catch(err => {...})
```

在这里，所有这三个承诺将同时触发*并将*并行运行*。当然，并行运行调用比串行运行调用效率更高。此外，`Promise.all`还保证最终的 thennable 接收一个结果数组，该数组被命令将结果位置与调用者位置同步。*

 *熟悉 full Promise API 对您有好处，您可以在 MDN:[上阅读该 APIhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)

尽管 Promises 现在是本地的，但仍然有一个“用户地带”模块 bluebird，它继续提供一个引人注目的替代 Promises 实现，具有附加功能，通常执行速度更快。你可以在这里阅读更多关于蓝鸟的信息：[http://bluebirdjs.com/docs/api-reference.html](http://bluebirdjs.com/docs/api-reference.html) 。

# 异步/等待

与其像 Promise 一样将实现包装在一个专门的数据结构中，包含如此多的函数块、括号和特殊上下文，为什么不简单地将其制作成异步表达式也可以吃蛋糕吃蛋糕呢？这些表达式不会阻止进程（异步执行），但它们仍然会停止程序的进一步执行（同步），直到问题得到解决

`await`操作符用于等待承诺。它只在`async`函数中执行。`async/await`并发建模语法从 Node 8.x 开始就可用。这里演示了如何使用`async/await`复制前面的`Promise.all`示例：

```js
const db = {
  getFullName: Promise.resolve('Jack Spratt'),
  getAddress: Promise.resolve('10 Clean Street'),
  getFavorites: Promise.resolve('Lean'),
}

async function profile() {
  let fullName = await db.getFullName() // Jack Spratt
  let address = await db.getAddress() // 10 Clean Street
  let favorites = await db.getFavorites() // Lean

  return {fullName, address, favorites};
}

profile().then(res => console.log(res) // results = ['Jack Spratt', '10 Clean Street', 'Lean'
```

很好，对吗？你会注意到`profile()`回复了一个承诺。一个`async`函数*总是*返回一个承诺，尽管我们在这里看到，函数本身可以返回它想要的任何东西。

承诺和`async`/`await`像老朋友一样一起工作。下面是一个递归目录遍历器，它演示了这种协作：

```js
const {join} = require('path');
const {promisify} = require('util');
const fs = require('fs');
const readdir = promisify(fs.readdir);
const stat = promisify(fs.stat);

async function $readDir (dir, acc = []) {
  await Promise.all((await readdir(dir)).map(async file => {
    file = join(dir, file);
    return (await stat(file)).isDirectory() && acc.push(file) && $readDir(file, acc);
  }));
  return acc;
}

$readDir(`./dummy_filesystem`).then(dirInfo => console.log(dirInfo));

// [ 'dummy_filesystem/folderA',
// 'dummy_filesystem/folderB',
// 'dummy_filesystem/folderA/folderA-C' ]
```

这证明了这个递归目录遍历器的代码是多么简洁，它只比上面的设置代码略长。由于`await`需要`Promise.all`将返回的承诺，因此运行`readDir`承诺返回的每个文件，并将每个文件映射到另一个等待的承诺，该承诺将处理任何递归下降到子目录的操作，并在适当时更新累加器。像这样读，`Promise.all((await readdir(dir)).map`构造与基本循环构造没有什么不同，在基本循环构造中，深度异步递归是以一种简单且易于遵循的过程同步方式建模的。

假设与`async`/`await`版本具有相同的依赖关系，则纯承诺替换版本可能如下所示：

```js
function $readDir(dir, acc=[]) {
  return readdir(dir).then(files => Promise.all(files.map(file => {
    file = join(dir, file);
    return stat(file).then(fobj => {
      if (fobj.isDirectory()) {
        acc.push(file);
        return $readDir(file, acc);
      }
    });
  }))).then(() => acc);
};
```

这两个版本都比回调更干净。`async/await`版本充分利用了这两个方面的优点，创建了一个类似于同步代码的简洁表示，使其更易于理解和推理。

使用`async/await`处理错误也很简单，因为它不需要特殊的新语法。使用 Promises 和`catch`时，同步代码错误有一个小问题。承诺捕获`then`块中发生的错误。例如，如果您的代码调用的第三方库抛出，则该代码不受承诺的包装，并且错误*不会被`catch`*捕获。

通过`async/await`，您可以使用熟悉的`try...catch`语句：

```js
async function makeError() {
    try {
        console.log(await thisDoesntExist());
    } catch (error) {
        console.error(error);
    }
}

makeError();
```

这避免了特殊错误捕获构造的所有问题。这种原生的、坚如磐石的方法将捕获`try`块中任何地方抛出的任何内容，无论执行是否同步

# 生成器和迭代器

生成器是可以暂停和恢复的函数执行上下文。当你调用一个普通函数时，它很可能是一个值；函数完全执行，然后终止。生成器函数将生成一个值，然后停止，但不会处理生成器的函数上下文（与正常函数一样）。您可以在稍后的时间点重新输入生成器并获取进一步的结果。

举个例子可能会有所帮助：

```js
function* threeThings() {
    yield 'one';
    yield 'two';
    yield 'three';
}

let tt = threeThings();

console.log(tt); // {} 
console.log(tt.next()); // { value: 'one', done: false }
console.log(tt.next()); // { value: 'two', done: false }
console.log(tt.next()); // { value: 'three', done: false }
console.log(tt.next()); // { value: undefined, done: true }
```

生成器是通过用星号（`*`标记来声明的。在第一次调用`threeThings`时，我们得到的不是结果，而是生成器对象。

生成器符合新的 JavaScript 迭代协议（[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#iterator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#iterator) ），就我们的目的而言，这意味着生成器对象公开了一个`next`方法，该方法用于从生成器中提取尽可能多的值。这种能力来自于生成器实现 JavaScript 迭代协议的事实。那么，什么是迭代器？

As [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators) says, 
"An object is an iterator when it knows how to access items from a collection one at a time, while keeping track of its current position within that sequence. In JavaScript an iterator is an object that provides a next() method which returns the next item in the sequence. This method returns an object with two properties: done and value."

我们可以仅使用迭代器复制生成器示例：

```js
function demoIterator(array) {
  let idx = 0;
  return {
    next: () => {
      return idx < array.length ? {
        value: array[idx++],
        done: false
      } : { done: true };
    }
  };
}
let it = demoIterator(['one', 'two', 'three']);
console.log(it); // { next: [Function: next] }
console.log(it.next()); // { value: 'one', done: false }
console.log(it.next()); // { value: 'two', done: false }
console.log(it.next()); // { value: 'three', done: false }
console.log(it.next()); // { done: true }
```

您将注意到，结果与生成器示例几乎相同，我们可以在第一个结果中看到一个重要的区别：迭代器只是一个具有下一个方法的对象。它必须完成所有维护自身内部状态的工作（在上一个示例中跟踪`idx`。生成器是迭代器的工厂；此外，他们做的所有工作都是维持和屈服于自己的状态。

生成器是迭代器的后代，它生成具有两个属性的对象：

*   **完成**：布尔值。如果为 true，则生成器指示它没有任何剩余内容可供`yield`使用。如果您将生成器视为流（不是一个糟糕的并行），那么您可以将此模式与`Readable.read()`在流结束时返回 null 的模式进行比较（或者如果您愿意，在结束时`Readable`将推送 null 的方式）。
*   **值**：最后一个`yield`的值。如果`done`为真，则应忽略。

生成器是为迭代上下文而设计的，与循环不同，它提供了函数执行上下文的强大优势。您可能写过这样的内容：

```js
function getArraySomehow() {
  // slice into a copy; don't send original
  return ['one','two','buckle','my','shoe'].slice(0); 
}

let state = getArraySomehow();
for(let x=0; x < state.length; x++) {
    console.log(state[x].toUpperCase());
}
```

这很好，但也有缺点，例如需要创建对外部数据提供程序的本地引用，并在该块或函数终止时维护该引用。我们是否要打造一个全球品牌？它应该是不变的吗？如果基础数据发生变化，例如，数组中添加了一个新元素，我们如何确保`state`被更新，与应用程序的真实状态断开连接？如果某个内容意外覆盖了`state`怎么办？存在数据观察和绑定库，存在设计理论，存在适当封装数据源并将不可变版本注入执行上下文的框架；但是如果有更好的方法呢？

生成器可以包含和管理自己的数据和`yield`正确答案，即使是通过更改。我们可以使用生成器实现前面的代码：

```js
function* liveData(state) {
    let state = ['one','two','buckle','my','shoe'];
    let current;

    while(current = state.shift()) {
        yield current;
    }
}

let list = liveData([]);
let item;
while (item = list.next()) {
    if(!item.value) {
        break;
    }
    console.log('generated:', item.value);
}
```

生成器方法处理所有发回值的“样板文件”，并自然地封装状态。但这里似乎没有什么明显的优势。这是因为我们使用生成器来执行按顺序立即运行的迭代。生成器确实适用于承诺一系列值的情况，而单个值仅在请求时随时间生成。我们真正想要创建的不是一次按顺序处理一个数组，而是一个连续的通信过程链，每个过程“勾选”计算一个结果，并查看以前的过程结果。

考虑以下事项：

```js
function* range(start=1, end=2) {
    do {
        yield start;
    } while(++start <= end)
}

for (let num of range(1, 3)) {
    console.log(num);
}
// 1
// 2
// 3
```

您可以将参数传递给生成器。我们通过传递范围边界来创建一个`range`状态机，对该状态机的进一步调用将导致内部状态更改，并将当前状态表示形式提供给调用方。出于演示目的，我们使用遍历迭代器（以及生成器）的`for...of`方法，这种顺序处理（在完成之前阻塞主线程）可以*异步*。

生成器的 run/halt（而不是 run/stop）设计意味着我们可以将迭代看作不是在列表中运行，而是在一段时间内捕获一组转换事件。这一理念是**反应式编程**（[理念的核心 https://en.wikipedia.org/wiki/Reactive_programming](https://en.wikipedia.org/wiki/Reactive_programming) ），例如。让我们思考另一个例子，在这个例子中可以显示发电机的这一特殊优势。

使用这些类型的数据结构，您还可以做许多其他事情。这样想可能会有帮助：生成器是对一系列未来价值的承诺，就像承诺是对单个未来价值的承诺一样。承诺和生成器都可以在生成时传递（即使某些最终值仍在解析中，或尚未排队等待解析），其中一个通过`next()`接口获取值，另一个通过`then()`接口获取值

# 错误和例外

通常在编程中，术语*错误*和*异常*经常互换使用。在节点环境中，这两个概念并不相同。错误和异常是不同的。此外，节点中错误和异常的定义不一定与其他语言和开发环境中的类似定义一致。

传统上，节点程序中的**错误**条件是一种非致命条件，应该捕获并处理，在典型节点回调模式显示的*错误作为第一个参数*约定中最为明确。**异常**是一种严重错误（系统错误），理智的环境不应忽视或试图处理该错误。

其中一个在节点中遇到四种常见的错误上下文，并且应该以可预测的方式响应：

*   **同步上下文**：这通常发生在函数的上下文中，其中检测到错误的调用签名或其他非致命错误。函数应该只返回一个错误对象；【或某个其他指标调用失败】。
*   **异步上下文**：当期望通过触发`callback`函数进行响应时，执行上下文应传递一个带有适当消息的`Error`对象，作为该`callback`的第一个参数。
*   **事件上下文**：引用节点文档：*“当`EventEmitter`实例发生错误时，典型动作是发出错误事件。错误事件在节点中被视为特例。如果没有侦听器，则默认动作是打印堆栈跟踪并退出程序。”*在预期事件的位置使用事件。
*   **承诺上下文**：承诺抛出或以其他方式被拒绝，此错误被捕获在`.catch`块中。重要提示：你应该*始终*拒绝带有真实`Error`对象的承诺。流行的 B*luebird*承诺实现的作者 Petka Antonov 讨论了为什么：[https://github.com/petkaantonov/bluebird/blob/master/docs/docs/warning-explanations.md](https://github.com/petkaantonov/bluebird/blob/master/docs/docs/warning-explanations.md)

显然，在这种情况下，在错误破坏整个应用程序的稳定性之前，会以可控的方式捕获错误。在不过分陷入防御性编码的情况下，应该努力检查输入和其他来源的错误，并适当地排除它们。

始终返回正确的`Error`对象的另一个好处是访问该对象的堆栈属性。错误堆栈显示错误的来源、函数链中的每个链接，并调用导致错误的函数。典型的`Error.stack`轨迹如下所示：

```js
> console.log(new Error("My Error Message").stack);
 Error: My Error Message
     at Object.<anonymous> (/js/errorstack.js:1:75)
     at Module._compile (module.js:449:26)
     at Object.Module._extensions..js (module.js:467:10)
     ...

```

同样，堆栈始终通过`console.trace`方法可用：

```js
> console.trace("The Stack Head")
 Trace: The Stack Head
     at Object.<anonymous> (/js/stackhead.js:1:71)
     at Module._compile (module.js:449:26)
     at Object.Module._extensions..js (module.js:467:10)
     ...
```

应该清楚这些信息如何帮助调试，帮助确保应用程序的逻辑流是合理的。

A normal stack trace truncates after a dozen or so levels. If longer stack traces are useful to you, try *Matt Insler's* **longjohn**: [https://github.com/mattinsler/longjohn](https://github.com/mattinsler/longjohn)

As well, run and examine the `js/stacktrace.js` file in your bundle for some ideas on how stack information might be used when reporting errors, or even test results.

异常处理是不同的。异常是导致应用程序不稳定的意外或致命错误。应小心处理这些问题；处于异常状态的系统是不稳定的，未来状态不确定，应该正常关闭并重新启动。这是明智的做法。

通常，异常被捕获在`try`/`catch`块中：

```js
try {
  something.that = wontWork;
} catch (thrownError) {
  // do something with the exception we just caught
} 
```

在代码库中添加`try`/`catch`块并试图预测所有错误可能会变得难以管理和笨拙。此外，如果发生了您没有预料到的异常，即未捕获的异常，该怎么办？你是如何从你离开的地方恢复过来的？

节点没有标准的内置方式来处理未捕获的关键异常。这是该平台的一个弱点。一个未捕获的异常将继续在执行堆栈中冒泡，直到它到达事件循环，就像机器齿轮中的扳手一样，它将中断整个过程。我们最好将`uncaughtException`处理程序附加到流程本身：

```js
process.on('uncaughtException', (err) => {
  console.log('Caught exception: ' + err);
 });

setTimeout(() => {
  console.log("The exception was caught and this can run.");
}, 1000);

throwAnUncaughtException();

// > Caught exception: ReferenceError: throwAnUncaughtException is not defined
// > The exception was caught and this can run.
```

虽然我们的异常代码后面不会执行任何内容，但超时仍然会触发，因为进程设法捕获异常并保存自身。然而，这是一种非常笨拙的异常处理方法。`domain`模块旨在修复节点设计中的这个漏洞，但后来被弃用。正确处理和报告错误仍然是 Node 平台的一个真正弱点。核心团队继续努力解决此问题：[https://nodejs.org/en/docs/guides/domain-postmortem/](https://nodejs.org/en/docs/guides/domain-postmortem/)

最近，引入了一种类似的机制来捕获失控的承诺，当您没有将捕获处理程序附加到承诺链时，会发生这种情况：

```js
process.on('unhandledRejection', (reason, Prom) => {
  console.log(`Unhandled Rejection: ${p} reason: ${reason}`);
});
```

每当承诺被拒绝，并且在事件循环的一圈内没有错误处理程序附加到该承诺时，`unhandledRejection`处理程序就会被激发。

# 考虑

任何开发人员都会定期做出具有深远影响的决策。很难预测新代码或新设计理论可能产生的所有后果。因此，保持代码的形状简单，并强制自己始终遵循其他节点开发人员的常规做法可能会很有用。以下是一些您可能会觉得有用的指导原则：

*   一般来说，尽量针对浅层代码。这种类型的重构在非事件环境中并不常见。通过定期重新评估入口和出口点以及共享功能来提醒自己。
*   考虑使用不同的、可合成的微服务来构建系统，我们将在《专利 T0》第 9 章中讨论。
*   在可能的情况下，为`callback`返回提供一个通用上下文。闭包在 JavaScript 中是非常强大的工具，并且扩展到 Node，只要所包含回调的上下文帧长度不太长。
*   命名你的函数。除了在深度递归构造中很有用之外，当堆栈跟踪包含不同的函数名时，调试代码要比匿名代码容易得多。
*   认真考虑优先事项。给定结果到达或执行`callback`的顺序是否真正重要？更重要的是，它与 I/O 操作有关吗？如果是这样的话，请考虑 Enter T1 和 T2 T2。
*   考虑使用有限状态机来管理事件。状态机在 JavaScript 代码库中的表示令人惊讶地不足。当`callback`重新进入程序流时，它可能已经改变了应用程序的状态，而异步调用本身的发出很可能是状态即将改变的指示器。

# 使用文件事件构建 Twitter 提要

让我们应用我们所学的知识。目标是创建一个服务器，客户端可以连接到该服务器并从 Twitter 接收更新。我们将首先创建一个进程来查询 Twitter 上任何带有标签`#nodejs`的消息，并将找到的任何消息以 140 字节的块写入`tweets.txt`文件。然后，我们将创建一个网络服务器，将这些消息广播到单个客户端。这些广播将由`tweets.txt`文件上的写入事件触发。每当发生写操作时，就会从最后一个已知的客户端读取指针异步读取 140 字节的块。这将一直发生，直到我们到达文件的末尾，边走边广播。最后，我们将创建一个简单的`client.html`页面，用于请求、接收和显示这些消息。

虽然这个例子肯定是人为的，但它表明：

*   侦听文件系统的更改，并响应这些事件
*   使用数据流事件读取和写入文件
*   响应网络事件
*   对轮询状态使用超时
*   将节点服务器本身用作网络事件广播器

为了处理服务器广播，我们将使用**服务器发送事件**（**SSE**）协议，这是一种新的协议，作为 HTML5 的一部分被标准化。

我们首先要创建一个节点服务器，用于侦听文件的更改并向客户端广播任何新内容。打开编辑器并创建文件`server.js`：

```js
let fs = require("fs");
let http = require('http');

let theUser = null;
let userPos = 0;
let tweetFile = "tweets.txt";
```

我们将接受单用户连接，其指针将为`theUser`。`userPos`将在`tweetFile`中存储此客户端读取的最后一个位置：

```js
http.createServer((request, response) => {
  response.writeHead(200, {
    'Content-Type': 'text/event-stream',
    'Cache-Control': 'no-cache',
    'Access-Control-Allow-Origin': '*'
  });

  theUser = response;

  response.write(':' + Array(2049).join(' ') + '\n');
  response.write('retry: 2000\n');

  response.socket.on('close', () => {
    theUser = null;
  });
}).listen(8080);
```

创建一个 HTTP 服务器，监听端口`8080`，该端口将监听并处理单个连接，存储`response`参数，表示将服务器连接到客户端的管道。`response`参数实现了可写流接口，允许我们向客户端写入消息：

```js
let sendNext = function(fd) {
  let buffer = Buffer.alloc(140);
  fs.read(fd, buffer, 0, 140, userPos * 140, (err, num) => {
    if (!err && num > 0 && theUser) {
      ++userPos;
      theUser.write(`data: ${buffer.toString('utf-8', 0, num)}\n\n`);
      return process.nextTick(() => {
        sendNext(fd);
      });
    }
  });
};
```

我们创建一个函数来发送客户端消息。我们将从绑定到`tweets.txt`文件的可读流中提取 140 字节的缓冲区，每次读取时将文件位置计数器增加一个。我们将这个缓冲区写入将服务器绑定到客户端的可写流。完成后，我们使用`nextTick,`repeating 将同一函数的重复调用排队，直到出现错误、未收到数据或客户端断开连接：

```js
function start() {
  fs.open(tweetFile, 'r', (err, fd) => {
    if (err) {
      return setTimeout(start, 1000);
    }
    fs.watch(tweetFile, (event, filename) => {
      if (event === "change") {
        sendNext(fd);
      }
    });
  });
};

start();
```

最后，我们打开`tweets.txt`文件，观察是否有任何更改，并在编写新 tweet 时调用`sendNext`。当我们启动服务器时，可能还不存在可读取的文件，因此我们使用`setTimeout`进行轮询，直到有一个文件存在。

现在我们有了一个服务器来查找要广播的文件更改，我们需要生成数据。我们首先通过**npm 为 Node 安装**TWiT**Twitter 包。**

然后我们创建一个进程，其唯一任务是将新数据写入文件：

```js
const fs = require("fs");
const Twit = require('twit');

let twit = new Twit({
  consumer_key: 'your key',
  consumer_secret: 'your secret',
  access_token: 'your token',
  access_token_secret: 'your secret token'
});
```

To use this example, you will need a Twitter Developer account. Alternatively, there is also the option of changing the relevant code to simply write random 140-byte strings to `tweets.txt: require("crypto").randomBytes(70).toString('hex'):`

```js
let tweetFile = "tweets.txt";
let writeStream = fs.createWriteStream(tweetFile, {
  flags: "a" // indicate that we want to (a)ppend to the file
});
```

这将建立一个指向服务器将监视的同一文件的流指针。
我们将写入此文件：

```js
let cleanBuffer = function(len) {
  let buf = Buffer.alloc(len);
  buf.fill('\0');
  return buf;
};
```

因为 Twitter 消息的长度永远不会超过 140 字节，所以我们可以通过始终写入 140 字节的块来简化读/写操作，即使其中一些空间是空的。一旦我们收到更新，我们将创建一个缓冲区，其宽度为*消息数*x140 字节，并将这些 140 字节的块写入该缓冲区：

```js
let check = function() {
  twit.get('search/tweets', {
    q: '#nodejs since:2013-01-01'
  }, (err, reply) => {
    let buffer = cleanBuffer(reply.statuses.length * 140);
    reply.statuses.forEach((obj, idx) => {
      buffer.write(obj.text, idx*140, 140);
    });
    writeStream.write(buffer);
  })
  setTimeout(check, 10000);
};

check();
```

我们现在创建了一个函数，每 10 秒会要求该函数检查包含标签`#nodejs`的消息。Twitter 返回消息对象数组。我们感兴趣的一个对象属性是消息的`#text`。计算表示这些新消息所需的字节数（140 x 消息计数），获取一个干净的缓冲区，并用 140 字节块填充它，直到写入所有消息。最后，这些数据被写入我们的`tweets.txt`文件，导致发生一个变更事件，并通知我们的服务器。

最后一块是客户端页面本身。这是一个相当简单的页面，读者应该熟悉它的操作方式。唯一需要注意的是使用 SSE 侦听本地主机上的端口`8080`。应该清楚的是，在收到来自服务器的新 tweet 时，如何将列表元素添加到无序列表容器`#list`：

```js
<!DOCTYPE html>
<html>
<head>
    <title></title>
</head>

<script>

window.onload = () => {
  let list = document.getElementById("list");
  let evtSource = new EventSource("http://localhost:8080/events");

  evtSource.onmessage = (e) => {
    let newElement = document.createElement("li");
    newElement.innerHTML = e.data;
    list.appendChild(newElement);
  }
}

</script>
<body>

<ul id="list"></ul>

</body>
</html>
```

To read more about SSE, refer to [Chapter 6](06.html), *Creating Real-time Applications*,
or you can visit: [https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events).

# 总结

用事件编程并不总是容易的。定义范例的控制和上下文切换经常混淆事件系统的新成员。这种看似鲁莽的失控和由此产生的复杂性使许多开发人员远离这些想法。编程入门课程的学生通常会形成一种思维模式，在这种思维模式下，程序流可以听写，如果程序的执行流不是从 a 到 B 顺序进行的，则会影响理解。

通过研究体系结构问题的演变，Node 目前正试图解决网络应用中的可伸缩性和代码组织、数据量和复杂度、状态感知以及定义良好的数据和流程边界等方面的问题。我们了解了如何智能地管理这些事件队列。我们看到了不同的事件源是如何可预测地堆叠起来以供事件循环处理的，以及未来事件可以使用闭包和智能回调顺序进入和重新进入上下文的距离。我们还了解了新的 Promise、Generator 和 async/await 结构，这些结构旨在帮助管理并发性。

我们现在对节点的设计和特性有了基本的领域理解，特别是如何使用它进行事件编程。现在，让我们继续讨论这一知识的更大、更高级的应用。*