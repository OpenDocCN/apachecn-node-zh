# 与 Socket.IO 和 ExpressJS 的实时通信

在本章中，我们将介绍以下配方：

*   理解 NodeJS 事件
*   理解 Socket.IO 事件
*   使用 Socket.IO 名称空间
*   定义并连接到 Socket.IO 文件室
*   为 Socket.IO 编写中间件
*   将 Socket.IO 与 ExpressJS 集成
*   在 Socket.IO 中使用 ExpressJS 中间件

# 技术要求

您需要具有 IDE、Visual Studio 代码、Node.js 和 MongoDB。您还需要安装 Git，以便使用本书的 Git 存储库。

本章代码文件可在 GitHub 上找到：
[https://github.com/PacktPublishing/MERN-Quick-Start-Guide/tree/master/Chapter04](https://github.com/PacktPublishing/MERN-Quick-Start-Guide/tree/master/Chapter04)

查看以下视频以查看代码的运行：
[https://goo.gl/xfyDBn](https://goo.gl/xfyDBn)

# 介绍

现代 web 应用程序通常需要实时通信，其中数据不断地从客户端流向服务器，反之亦然，几乎没有延迟。

HTML5WebSocket 协议就是为了满足这一需求而创建的。WebSocket 使用单个 TCP 连接，即使服务器或客户端不发送任何数据，该连接也保持打开状态。这意味着，当客户端和服务器之间存在连接时，可以随时发送数据，而无需打开到服务器的新连接。

实时通信有几个应用程序，从构建聊天应用程序到多用户游戏，其中响应时间非常重要。

在本章中，我们将重点学习如何使用 Socket.IO（[构建实时 web 应用程序 https://socket.io](https://socket.io) 并理解 Node.js 事件驱动架构。

IO 是实现实时通信最常用的库之一。Socket.IO 尽可能使用 WebSocket，但在特定 web 浏览器上不支持 WebSocket 时，会使用其他方法。因为您可能希望让您的应用程序可以从任何 web 浏览器访问，所以直接使用 WebSocket 似乎不是一个好主意。

# 理解 Node.js 事件

Node.js 具有事件驱动的体系结构。【js.T0】的大部分节点都是围绕着【js.T0】构建的。这是一个 Node.js 模块，允许`listeners`订阅某些命名事件，这些事件稍后可由**发射器**触发。

您只需包含 events Node.js 模块并创建一个新的`EventEmitter`实例，就可以轻松定义自己的事件发射器：

```js
const EventEmitter = require('events') 
const emitter = new EventEmitter() 
emitter.on('welcome', () => { 
    console.log('Welcome!') 
}) 
```

然后，您可以使用`emit`方法触发`welcome`事件：

```js
emitter.emit('welcome') 
```

其实很简单。其中一个优点是，您可以为同一事件订阅多个侦听器，当使用`emit`方法时会触发这些侦听器：

```js
emitter.on('welcome', () => { 
    console.log('Welcome') 
}) 
emitter.on('welcome', () => { 
    console.log('There!') 
}) 
emitter.emit('welcome') 
```

`EventEmitter`API 提供了几种有用的方法，使您能够更好地控制事件的处理。查看 Node.js 官方文档以查看有关 API 的所有信息：[https://nodejs.org/api/events.html](https://nodejs.org/api/events.html) 。

# 准备

在这个配方中，您将创建一个扩展`EventEmitter`的类，该类将包含自己的实例方法，以触发附加到特定事件的侦听器。首先，通过打开终端并运行以下行来创建新项目：

```js
npm init
```

# 怎么做。。。

创建一个扩展`EventEmitter`的类，并定义两个名为`start`和`stop`的实例方法。当调用`start`方法时，它将触发连接到`start`事件的所有侦听器。它将使用`process.hrtime`保持启动时间。然后，当调用`stop`方法时，它将触发连接到`stop`事件的所有侦听器，作为参数传递自调用`start`方法以来的时间差：

1.  创建一个名为`timer.js`的新文件
2.  包括事件节点 JS 模块：

```js
      const EventEmitter = require('events') 
```

3.  定义两个常量，我们将使用它们将返回的`process.hrtime`值从秒转换为纳秒，然后再转换为毫秒：

```js
      const NS_PER_SEC = 1e9 
      const NS_PER_MS = 1e6 
```

4.  使用两个实例方法定义一个名为`Timer`的类：

```js
      class Timer extends EventEmitter { 
          start() { 
              this.startTime = process.hrtime() 
              this.emit('start') 
          } 
          stop() { 
              const diff = process.hrtime(this.startTime) 
              this.emit( 
                  'stop', 
                  (diff[0] * NS_PER_SEC + diff[1]) / NS_PER_MS, 
              ) 
          } 
      } 
```

5.  创建以前定义的类的新实例：

```js
      const tasks = new Timer() 
```

6.  将事件侦听器附加到将有一个执行乘法的循环的`start`事件。然后调用`stop`方法：

```js
      tasks.on('start', () => { 
          let res = 1 
          for (let i = 1; i < 100000; i++) { 
              res *= i 
          } 
          tasks.stop() 
      }) 
```

7.  将事件侦听器附加到`stop`事件，该事件将打印事件`start`执行其所有附加侦听器所用的时间：

```js
      tasks.on('stop', (time) => { 
          console.log(`Task completed in ${time}ms`) 
      }) 
```

8.  调用`start`方法触发所有`start`事件侦听器：

```js
      tasks.start() 
```

9.  保存文件
10.  打开新终端并运行：

```js
 node timer.js
```

# 它是如何工作的。。。

当执行`start`方法时，它使用`process.hrtime`保持开始时间，返回两个项目数组中的当前高分辨率实时时间，其中第一个项目是表示秒的数字，而第二个项目是表示纳秒的另一个数字。然后，它触发连接到`start`事件的所有事件侦听器。

另一方面，当执行`stop`方法时，它使用先前调用`process.hrtime`的结果作为同一函数的参数，该函数返回时间差。直到调用方法时【从 T2 到 T3】才有用。

# 还有更多。。。

一个常见的错误是假设事件是异步调用的。的确，可以随时调用已定义的事件。但是，它们仍然是同步执行的。以以下为例：

```js
const EventEmitter = require('events') 
const events = new EventEmitter() 
events.on('print', () => console.log('1')) 
events.on('print', () => console.log('2')) 
events.on('print', () => console.log('3')) 
events.emit('print') 
```

上述代码的输出如下所示：

```js
1 
2 
3 
```

如果有一个循环在某个事件中运行，则在前一个事件完成执行之前，不会调用下一个事件。

只需添加一个`async`函数作为事件监听器，事件就可以变得异步。这样，从定义的第一个`listener`到最后一个，每个函数仍将按顺序调用。但是，发射器不会等待第一个`listener`完成其执行来调用下一个侦听器。这意味着您不能保证输出始终处于相同的顺序，例如：

```js
events.on('print', () => console.log('1')) 
events.on('print', async () => console.log( 
    await Promise.resolve('2')) 
) 
events.on('print', () => console.log('3')) 
events.emit('print')  
```

上述代码的输出如下所示：

```js
1 
3 
2 
```

异步函数允许我们编写非阻塞应用程序。如果实现正确，您将不会遇到上述问题。

`EventEmitter`实例有一个名为`listeners`的方法，该方法在执行时，提供事件名称作为参数，返回该特定事件的附加侦听器数组。我们可以使用这种方法来允许`async`函数按其附加的顺序执行，例如：

```js
const EventEmitter = require('events') 
class MyEvents extends EventEmitter { 
    start() { 
        return this.listeners('logme').reduce( 
            (promise, nextEvt) => promise.then(nextEvt), 
            Promise.resolve(), 
        ) 
    } 
} 
const event = new MyEvents() 
event.on('logme', () => console.log(1)) 
event.on('logme', async () => console.log( 
    await Promise.resolve(2) 
)) 
event.on('logme', () => console.log(3)) 
event.start() 
```

这将按其连接顺序执行和显示输出：

```js
1 
2 
3 
```

# 理解 Socket.IO 事件

IO 是一个事件驱动的模块或库，正如您可能猜到的，它基于`EventEmitter`。Socket.IO 中的所有内容都与事件一起工作。当与 Socket.IO 服务器建立新连接时，会触发一个事件，并且会发出一个事件以向客户端发送数据。

Socket.IO 服务器 API 与 Socket.IO 客户端 API 不同。但是，两者都使用事件将数据从客户端发送到服务器，反之亦然。

# Socket.IO 服务器事件

Socket.IO 使用单个 TCP 连接到单个路径。这意味着，默认情况下，连接到 URL`http[s]://host:port/socket.io`。但是，在 Socket.IO 中，它允许您定义**名称空间**。这意味着，不同的端点，但连接仍将保持单个 URL。

By default, Socket.IO Server uses the `"/"` or root namespace

当然，您可以定义多个实例并侦听不同的 URL。但是，我们将假定，出于本配方的目的，只创建了一个连接。

Socket.IO 命名空间具有应用程序可以订阅的以下事件：

*   `connect`或`connection`：建立新连接时，触发此事件。它向侦听器提供一个**套接字对象**，作为表示与客户端的新连接的第一个参数

```js
      io.on('connection', (socket) => { 
          console.log('A new client is connected') 
      }) 
      // Which is the same as:
       io.of('/').on('connection', (socket) => { 
          console.log('A new client is connected') 
      }) 
```

Socket.IO 套接字对象具有以下事件：

*   `disconnecting`：客户端与服务器断开连接时会发出此事件。它向侦听器提供一个参数，指定断开连接的原因

```js
      socket.on('disconnecting', (reason) => { 
          console.log('Disconnecting because', reason) 
      }) 
```

*   `disconnected`：与断开事件类似。但是，在客户端与服务器断开连接后会触发此事件：

```js
      socket.on('disconnect', (reason) => { 
          console.log('Disconnected because', reason) 
      }) 
```

*   `error`：当事件中发生错误时，会发出此事件

```js
      socket.on('error', (error) => { 
          console.log('Oh no!', error.message) 
      }) 
```

*   `[eventName]`：一个用户定义的事件，当客户端发出同名事件时将被触发。客户端可以发出一个事件，在参数中提供数据。在服务器上，将触发事件，并接收客户端发送的数据

# Socket.IO 客户端事件

客户端不一定是 web 浏览器。我们还可以编写 Node.js Socket.IO 客户端应用程序。

Socket.IO 客户端事件非常广泛，可以对应用程序进行大量控制：

*   `connect`：成功连接到服务器时触发此事件

```js
      clientSocket.on('connect', () => { 
          console.log('Successfully connected to server') 
      }) 
```

*   `connect_error`：当尝试连接或重新连接到服务器时出错时，会发出此事件

```js
      clientSocket.on('connect_error', (error) => { 
          console.log('Connection error:', error) 
      }) 
```

*   `connect_timeout:`默认情况下，在发出`connect_error`和`connect_timeout`之前设置的超时为 20 秒。在此之后，Socket.IO 客户端可能会再次尝试重新连接到服务器：

```js
      clientSocket.on('connect_timeout', (timeout) => { 
          console.log('Connect attempt timed out after', timeout) 
      }) 
```

*   `disconnect`：客户端与服务器断开连接时触发此事件。提供了一个参数，指定断开连接的原因：

```js
      clientSocket.on('disconnect', (reason) => { 
          console.log('Disconnected because', reason) 
      }) 
```

*   `reconnect`：在成功的重新连接尝试后触发。提供了一个参数，指定在连接成功之前进行了多少次尝试：

```js
      clientSocket.on('reconnect', (n) => { 
          console.log('Reconnected after', n, 'attempt(s)') 
      }) 
```

*   `reconnect_attempt`或`reconnecting`：尝试重新连接服务器时会发出此事件。提供了一个参数，指定当前尝试连接到服务器的次数：

```js
      clientSocket.on('reconnect_attempt', (n) => { 
          console.log('Trying to reconnect again', n, 'time(s)') 
      })  
```

*   `reconnect_error`：与`connect_error`事件类似。但是，只有在尝试重新连接到服务器时出现错误时，才会触发：

```js
      clientSocket.on('reconnect_error', (error) => { 
          console.log('Oh no, couldn't reconnect!', error) 
      })  
```

*   `reconnect_failed:`默认情况下，最大尝试次数设置为`Infinity`。这意味着，该事件不太可能被触发。但是，我们可以指定一个选项来限制连接尝试的最大次数。我们稍后再看：

```js
      clientSocket.on('reconnect_failed', (n) => { 
    console.log('Couldn'nt reconnected after', n, 'times') 
      }) 
```

*   `ping`：简而言之，触发此事件是为了检查与服务器的连接是否仍处于活动状态：

```js
      clientSocket.on('ping', () => { 
          console.log('Checking if server is alive') 
      }) 
```

*   `pong`：在触发事件`ping`后收到服务器响应时触发。提供了一个参数，指定延迟或响应时间：

```js
      clientSocket.on('pong', (latency) => { 
          console.log('Server responded after', latency, 'ms') 
      }) 
```

*   `error`：当事件中发生错误时触发此事件：

```js
      clientSocket.on('error', (error) => { 
          console.log('Oh no!', error.message) 
      }) 
```

*   `[eventName]`：在服务器中发出事件时触发的用户定义事件。客户端将接收服务器提供的参数。

# 准备

在本配方中，您将使用刚刚了解的事件构建一个 Socket.IO 服务器和一个 Socket.IO 客户端。开始之前，创建一个新的`package.json`文件，包含以下内容：

```js
{ 
  "dependencies": { 
    "socket.io": "2.1.0" 
  } 
} 
```

然后，通过打开终端并运行以下命令来安装依赖项：

```js
npm install 
```

# 怎么做。。。

将构建一个 Socket.IO 服务器来响应名为`time`的单个事件。当事件被触发时，它将获取服务器的当前时间并发出另一个名为`"got time?"`的事件，该事件提供两个参数，即当前的`time`和一个`counter`，用于指定发出请求的次数。

1.  创建一个名为`simple-io-server.js`的新文件

2.  包括 Socket.IO 模块并初始化新服务器：

```js
      const io = require('socket.io')() 
```

3.  定义要建立连接的 URL 路径：

```js
      io.path('/socket.io') 
```

4.  使用根或`"/"`命名空间：

```js
      const root = io.of('/') 
```

5.  建立新连接时，将`counter`变量初始化为`0`。然后，在`time`事件中添加一个新的侦听器，每当有新请求时，该侦听器将`counter`增加一个，并发出`"got time?"`事件，该事件将稍后在客户端定义：

```js
      root.on('connection', socket => { 
          let counter = 0 
          socket.on('time', () => { 
              const currentTime = new Date().toTimeString() 
              counter += 1 
              socket.emit('got time?', currentTime, counter) 
          }) 
      }) 
```

6.  在端口`1337`上侦听新连接：

```js
      io.listen(1337) 
```

7.  保存文件

接下来，构建一个 Socket.IO 客户端，该客户端将连接到我们的服务器：

1.  创建一个名为`simple-io-client.js`的新文件
2.  包括 Socket.IO 客户端模块：

```js
      const io = require('socket.io-client') 
```

3.  初始化一个新的 Socket.IO 客户端，该客户端提供服务器 URL 和一个选项对象，我们将在其中定义 URL 中使用的路径，并在其中建立连接：

```js
      const clientSocket = io('http://localhost:1337', { 
          path: '/socket.io', 
      }) 
```

4.  将事件侦听器添加到`connect`事件。然后，当建立连接时，使用`for`循环发出`time`事件 5 次：

```js
      clientSocket.on('connect', () => { 
          for (let i = 1; i <= 5; i++) { 
              clientSocket.emit('time') 
          } 
      }) 
```

5.  在`"got time?"`事件中添加一个事件监听器，该监听器将接收两个参数时间和一个计数器，指定向服务器发出了多少请求，然后在控制台上打印：

```js
      clientSocket.on('got time?', (time, counter) => { 
          console.log(counter, time) 
      }) 
```

6.  保存文件
7.  打开终端并首先运行 Socket.IO 服务器：

```js
    node simple-io-server.js
```

8.  打开另一个终端并运行 Socket.IO 客户端：

```js
    node simple-io-client.js
```

# 它是如何工作的。。。

一切都与事件有关。IO 允许在服务器端定义客户端可以发出的事件。另一方面，它还允许在客户端定义服务器可以发出的事件。

当服务器端发出用户定义的事件时，数据将发送到客户端。IO 客户端首先检查是否存在该事件的侦听器。然后，如果有侦听器，它将被触发。当客户端发出用户定义的事件时，同样的情况也会发生：

1.  在 Socket.IO 服务器的**Socket 对象**中添加了一个事件监听器`time`，可以由客户端发出
2.  我们的 Socket.IO 客户端增加了一个事件监听器`"got time?"`，可以由服务器端发出

3.  连接时，客户端首先发出`time`事件
4.  之后，在服务器端触发`time`事件，该事件将发出`"got time?"`事件，提供两个参数，当前服务器的`time`和一个`counter`，用于指定发出请求的次数
5.  然后，在客户端触发`"got time?"`事件，接收服务器提供的两个参数`time`和`counter`

# 使用 Socket.IO 名称空间

名称空间是一种分离应用程序的业务逻辑的方法，同时重用相同的 TCP 连接或最小化创建新 TCP 连接的需要，以实现服务器和客户端之间的实时通信。

名称空间看起来非常类似于 ExpressJS 的路由路径：

```js
/home 
/users 
/users/profile 
```

然而，正如前面提到的，这些与 URL 无关。默认情况下，在此 URL`http[s]://host:port/socket.io`处创建一个 TCP 连接

在使用名称空间时，重用相同的事件名称是一种很好的做法。例如，假设我们有一个 Socket.IO 服务器，当客户端发出`getWelcomeMsg`事件时，我们使用它来发出`setWelcomeMsg`事件：

```js
io.of('/en').on('connection', (socket) => { 
    socket.on('getWelcomeMsg', () => { 
        socket.emit('setWelcomeMsg', 'Hello World!') 
    }) 
}) 
io.of('/es').on('connection', (socket) => { 
    socket.on('getWelcomeMsg', () => { 
        socket.emit('setWelcomeMsg', 'Hola Mundo!') 
    }) 
}) 
```

如您所见，我们在两个不同的名称空间中定义了事件`getWelcomeMsg`的侦听器：

*   如果客户端连接到英语或`/en`名称空间，则当触发`setWelcomeMsg`事件时，客户端将收到`"Hello World!"`
*   另一方面，如果客户端连接到西班牙语或`/es`名称空间，当触发`setWelcomeMsg`事件时，客户端将收到`"Hola Mundo!"`

# 准备

在此配方中，您将看到如何使用包含相同事件名称的两个不同名称空间。开始之前，创建一个新的`package.json`文件，包含以下内容：

```js
{ 
  "dependencies": { 
    "socket.io": "2.1.0" 
  } 
} 
```

然后，通过打开终端并运行以下命令来安装依赖项：

```js
npm install
```

# 怎么做。。。

构建一个 Socket.IO 服务器，该服务器将触发`data`事件并发送一个包含两个属性`title`和`msg`的对象，该属性将用于以所选语言填充 HTML 内容。根据客户端选择的语言（英语或西班牙语），使用名称空间分隔和发送不同的数据。

1.  创建一个名为`nsp-server.js`的新文件
2.  包括 Socket.IO npm 模块和创建 HTTP 服务器所需的模块：

```js
      const http = require('http') 
      const fs = require('fs') 
      const path = require('path') 
      const io = require('socket.io')() 
```

3.  使用`http`模块创建一个新的 HTTP 服务器，该服务器将提供一个 HTML 文件，您稍后将创建一个 Socket.IO 客户端：

```js
     const app = http.createServer((req, res) => { 
      if (req.url === '/') { 
               fs.readFile( 
               path.resolve(__dirname, 'nsp-client.html'), 
              (err, data) => { 
                  if (err) { 
                    res.writeHead(500) 
                    return void res.end() 
                   } 
                    res.writeHead(200) 
                    res.end(data) 
                } 
              ) 
          } else { 
              res.writeHead(403) 
             res.end() 
         } 
    }) 
```

4.  指定新连接将连接到的路径：

```js
      io.path('/socket.io') 
```

5.  对于`"/en"`名称空间，添加一个新的事件监听器`getData`，该监听器在被激发时将在客户端发出一个`data`事件，并发送一个包含`title`和`msg`属性的对象（英语）：

```js
     io.of('/en').on('connection', (socket) => { 
        socket.on('getData', () => { 
            socket.emit('data', { 
               title: 'English Page', 
               msg: 'Welcome to my Website', 
           }) 
        }) 
   }) 
```

6.  对于`"/es"`名称空间，执行相同的操作。但是，发送给客户端的对象将包括西班牙语的`title`和`msg`属性：

```js
      io.of('/es').on('connection', (socket) => { 
          socket.on('getData', () => { 
              socket.emit('data', { 
                  title: 'Página en Español', 
                  msg: 'Bienvenido a mi sitio Web', 
              }) 
          }) 
      }) 
```

7.  在端口`1337`上侦听新连接，并将 Socket.IO 连接到底层 HTTP 服务器：

```js
      io.attach(app.listen(1337, () => { 
          console.log( 
              'HTTP Server and Socket.IO running on port 1337' 
          ) 
      })) 
```

8.  保存文件。

然后，创建一个 Socket.IO 客户端，该客户端将连接到我们的服务器，并根据从服务器接收的数据填充 HTML 内容。

1.  创建一个名为`nsp-client.html`的新文件
2.  首先，将文档类型指定为 HTML5。在它旁边，添加一个`html`标记，并将语言设置为英语。在`html`标签内，还包括`head`和`body`标签：

```js
      <!DOCTYPE html> 
      <html lang="en"> 
      <head> 
          <meta charset="UTF-8"> 
          <title>Socket.IO Client</title> 
      </head> 
      <body> 
          <!-- code here --> 
      </body> 
      </html> 
```

3.  在`body`标记中，添加前三个元素：包含内容标题的标题（`h1`），包含来自服务器消息的`p`标记，以及用于切换到不同名称空间的`button`。此外，还包括 Socket.IO 客户端库。Socket.IO 服务器将使库文件在以下 URL 处可用：http[s]：//host:port/Socket.IO/Socket.IO.js。然后，还包括`babel`独立库，该库将在接下来的步骤中将代码转换为可以在所有浏览器中运行的 JavaScript 代码：

```js
      <h1 id="title"></h1> 
      <section id="msg"></section> 
      <button id="toggleLang">Get Content in Spanish</button> 
       <script src="http://localhost:1337/socket.io/socket.io.js">  
       </script> 
        <script src="https://unpkg.com/@babel/standalone/babel.min.js">
      </script> 
```

4.  在`body`内，在最后一个`script`标签后，再添加一个`script`标签，并将其类型设置为`"text/babel"`：

```js
      <script type="text/babel"> 
          // code here! 
      </script> 
```

5.  之后，在`script`标记内添加以下 JavaScript 代码
6.  定义三个常量，其中包含对我们在`body`中创建的元素的引用：

```js
      const title = document.getElementById('title') 
      const msg = document.getElementById('msg') 
      const btn = document.getElementById('toggleLang') 
```

7.  定义 Socket.IO 客户端管理器。它将帮助我们使用提供的配置创建套接字：

```js
      const manager = new io.Manager( 
          'http://localhost:1337', 
          { path: '/socket.io' }, 
      ) 
```

8.  创建一个连接到`"/en"`命名空间的新套接字。我们将假定这是默认连接：

```js
      const socket = manager.socket('/en') 
```

9.  为名称空间`"/en"`和`"/es"`保留两个连接。保留连接将允许我们切换到不同的命名空间，而无需创建新的 TCP 连接：

```js
      manager.socket('/en') 
      manager.socket('/es') 
```

10.  添加一个事件侦听器，一旦连接套接字，该侦听器将发出一个`getData`事件，从服务器请求数据：

```js
      socket.on('connect', () => { 
          socket.emit('getData') 
      }) 
```

11.  为`data`事件添加一个事件侦听器，该事件将在客户端从服务器接收数据时触发：

```js
      socket.on('data', (data) => { 
          title.textContent = data.title 
          msg.textContent = data.msg 
      }) 
```

12.  为`button`添加事件侦听器。单击时，切换到其他命名空间：

```js
      btn.addEventListener('click', (event) => { 
          socket.nsp = socket.nsp === '/en' 
              ? '/es' 
              : '/en' 
          btn.textContent = socket.nsp === '/en' 
              ? 'Get Content in Spanish' 
              : 'Get Content in English' 
          socket.close() 
          socket.open() 
      }) 
```

13.  保存文件
14.  打开新终端并运行：

```js
 node nsp-server.js
```

15.  在 web 浏览器中，导航到：

```js
 http://localhost:1337/
```

# 让我们测试一下。。。

要查看您以前的工作，请执行以下步骤：

1.  在 web 浏览器中导航到`http://localhost:1337/`后，单击`"Get Content in Spanish"`按钮切换到西班牙语名称空间
2.  点击`"Get Content in English"`按钮切换回英文名称空间

# 它是如何工作的。。。

这就是服务器端发生的情况：

1.  我们定义了两个名称空间`"/en"`和`"/es"`，然后向**套接字对象添加了一个新的事件侦听器`getData`。**
2.  当`getData`事件在两个已定义名称空间中的任何一个中激发时，它将发出一个数据事件并向客户端发送一个包含标题和消息属性的对象

在客户端，在 HTML 文档中的脚本标记内：

1.  最初，为名称空间`"/en"`创建一个新套接字：

```js
      const socket = manager.socket('/en')
```

2.  同时，我们为名称空间`"/en"`和`"/es"`创建了两个新的**套接字**。它们将充当保留连接：

```js
      manager.socket('/en')
      manager.socket('/es')
```

3.  之后，添加了一个事件侦听器连接，它在连接时向服务器发送请求
4.  然后，添加了另一个事件侦听器数据，该数据在从服务器接收数据时触发
5.  在为按钮处理 onclick 事件的事件侦听器中，我们更改 nsp 属性以切换到不同的命名空间。然而，为了实现这一点，我们必须首先断开**套接字**，然后调用 open 方法，使用新名称空间再次建立新连接

让我们看看关于保留连接的一个令人困惑的部分。在同一命名空间中创建一个或多个**套接字**时，将重用第一个连接，例如：

```js
const first = manager.socket('/home')
const second = manager.socket('/home') // <- reuses first connection
```

在客户端，如果没有保留连接，则切换到以前未使用的命名空间将导致创建新连接。
如果您感到好奇，请从`nsp-client.html`文件中删除以下两行：

```js
manager.socket('/en')
manager.socket('/es')
```

然后，重新启动或运行 Socket.IO 服务器。您会注意到，当切换到不同的名称空间时，响应很慢，因为会创建一个新连接，而不是重复使用。

有另一种方法可以实现同样的目标。我们可以创建两个套接字，指向两个不同的名称空间，`"/en"`和`"/es"`。然后，我们可以在每个套接字中添加两个事件侦听器 connect 和 data。但是，由于第一个和第二个套接字将包含相同的事件名称，并从服务器接收相同格式的数据，因此我们将得到重复的代码。想象一下，如果我们必须对五个具有相同事件名称并接收相同格式数据的不同名称空间执行相同的操作，那么会有太多重复的代码行。这就是切换名称空间和重用同一套接字对象很有帮助的地方。但是，可能存在两个或多个不同名称空间对于不同类型的事件具有不同的事件名称的情况，在这种情况下，最好分别为每个名称空间添加事件侦听器。例如：

```js
const englishNamespace = manager.socket('/en')
const spanishNamespace = manager.socket('/es')
// They listen to different events
englishNamespace.on('showMessage', (data) => {})
spanishNamespace.on('mostrarMensaje', (data) => {})
```

# 还有更多。。。

在客户端，您可能已经注意到一件我们以前没有使用过的东西，`io.Manager`。

# 首席执行官

这允许我们预定义或配置如何创建新连接。`Manager`中定义的选项作为 URL，将在启动时传递给套接字。

在我们的 HTML 文件中，在一个`script`标记内，我们创建了一个`io.Manager`的新实例，并传递了两个参数；服务器 URL 和一个选项对象，包括一个`path`属性，该属性指示将在何处建立新连接：

```js
const manager = new io.Manager( 
    'http://localhost:1337', 
    { path: '/socket.io' }, 
) 
```

要了解更多关于`io.Manager`API 的信息，请访问官方文档网站 offer for Socket.IO[https://socket.io/docs/client-api/#manager](https://socket.io/docs/client-api/#manager) 。

稍后，我们使用`socket`方法为提供的名称空间初始化并创建一个新套接字：

```js
const socket = manager.socket('/en') 
```

通过这种方式，同时使用多个名称空间更容易，而不必使用相同的选项配置每个名称空间。

# 定义和连接 Socket.IO 文件室

在名称空间中，您可以定义套接字可以加入和离开的房间或通道。

默认情况下，为连接的**插座**创建一个随机的不可猜测 ID 的房间：

```js
io.on('connection', (socket) => { 
    console.log(socket.id) // Outputs socket ID 
}) 
```

在连接上，当发出事件时，例如：

```js
io.on('connection', (socket) => { 
    socket.emit('say', 'hello') 
}) 
```

下面发生的情况与此类似：

```js
io.on('connection', (socket) => { 
    socket.join(socket.id, (err) => { 
        if (err) { 
            return socket.emit('error', err) 
        } 
        io.to(socket.id).emit('say', 'hello') 
    }) 
}) 
```

`join`方法用于将插座包括在房间内。在本例中，套接字 ID 是 joint room，连接到该 room 的唯一客户端是套接字本身。

因为套接字 ID 表示与客户机的唯一连接，默认情况下，会创建具有相同 ID 的房间；服务器发送到该房间的所有数据将仅由该客户端接收。但是，如果多个客户端或套接字 ID 以相同的名称加入一个文件室，并且服务器发送数据；所有的客户都能收到。

# 准备

在这个食谱中，您将看到如何加入一个房间，并向连接到该特定房间的所有客户端广播一条消息。开始之前，创建一个新的`package.json`文件，包含以下内容：

```js
{ 
  "dependencies": { 
    "socket.io": "2.1.0" 
  } 
} 
```

然后，通过打开终端并运行以下命令来安装依赖项：

```js
npm install
```

# 怎么做。。。

构建一个 Socket.IO 服务器，当连接一个新套接字时，该服务器将通知所有连接到`"commonRoom"`房间的客户端。

1.  创建一个名为`rooms-server.js`的新文件
2.  包括 Socket.IO NPM 模块并初始化新的 HTTP 服务器：

```js
      const http = require('http') 
      const fs = require('fs') 
      const path = require('path') 
      const io = require('socket.io')() 
      const app = http.createServer((req, res) => { 
          if (req.url === '/') { 
              fs.readFile( 
                  path.resolve(__dirname, 'rooms-client.html'), 
                  (err, data) => { 
                     if (err) { 
                          res.writeHead(500) 
                          return void res.end() 
                      } 
                      res.writeHead(200) 
                      res.end(data) 
                  } 
              ) 
          } else { 
              res.writeHead(403) 
              res.end() 
          } 
      }) 
```

3.  指定创建新连接的路径：

```js
      io.path('/socket.io') 
```

4.  使用根命名空间侦听事件：

```js
      const root = io.of('/') 
```

5.  定义一个方法，该方法将用于向连接到`"commonRoom"`的所有套接字客户端发出`updateClientCount`事件，并提供连接客户端的数量作为参数：

```js
      const notifyClients = () => { 
          root.clients((error, clients) => { 
              if (error) throw error 
              root.to('commonRoom').emit( 
                  'updateClientCount', 
                  clients.length, 
              ) 
          }) 
      } 
```

6.  连接时，所有新连接的套接字客户端将加入`commonRoom`。然后，服务器将发出一个`welcome`事件。在此之后，通知所有已连接的套接字更新已连接客户端的数量，并在客户端断开连接后执行相同的操作：

```js
      root.on('connection', socket => { 
          socket.join('commonRoom') 
          socket.emit('welcome', `Welcome client: ${socket.id}`) 
          socket.on('disconnect', notifyClients) 
          notifyClients() 
      }) 
```

7.  在端口`1337`上侦听新连接并将 Socket.IO 连接到 HTTP 服务器：

```js
      io.attach(app.listen(1337, () => { 
          console.log( 
              'HTTP Server and Socket.IO running on port 1337' 
          ) 
      })) 
```

8.  保存文件。

在此之后，构建一个 Socket.IO 客户端，该客户端将连接到 Socket.IO 服务器，并用接收到的数据填充 HTML 内容：

1.  创建一个名为`rooms-client.html`的新文件
2.  添加以下代码：

```js
      <!DOCTYPE html> 
      <html lang="en"> 
      <head> 
          <meta charset="UTF-8"> 
          <title>Socket.IO Client</title> 
      </head> 
      <body> 
          <h1 id="title"> 
              Connected clients: 
              <span id="n"></span> 
          </h1> 
          <p id="welcome"></p> 
          <script src="http://localhost:1337/socket.io/socket.io.js">
          </script> 
          <script 
          src="https://unpkg.com/@babel/standalone/babel.min.js">
          </script> 
          <script type="text/babel"> 
      // Code here 
          </script> 
      </body> 
      </html> 
```

3.  在脚本标记内，从步骤 4 开始，按以下步骤添加代码
4.  定义两个常量，用于引用两个 HTML 元素，我们将根据 Socket.IO 服务器发送的数据更新它们：

```js
      const welcome = document.getElementById('welcome') 
      const n = document.getElementById('n') 
```

5.  定义 Socket.IO 客户端管理器：

```js
      const manager = new io.Manager( 
          'http://localhost:1337', 
          { path: '/socket.io' }, 
      ) 
```

6.  使用 Socket.IO 服务器中使用的根命名空间：

```js
      const socket = manager.socket('/') 
```

7.  为`welcome`事件添加一个事件侦听器，该事件需要一个包含服务器发送的欢迎消息的参数：

```js
      socket.on('welcome', msg => { 
          welcome.textContent = msg 
      }) 
```

8.  为`updateClientCount`事件添加一个事件侦听器，该事件需要一个包含连接客户端数量的参数：

```js
      socket.on('updateClientCount', clientsCount => { 
          n.textContent = clientsCount 
      }) 
```

9.  保存文件
10.  打开新终端并运行：

```js
 node rooms-server.js
```

11.  在 web 浏览器上，导航到：

```js
http://localhost:1337/
```

12.  在不关闭上一个选项卡或窗口的情况下，在 web 浏览器上再次导航到：

```js
http://localhost:1337/
```

13.  选项卡或窗口中连接的客户端数量应增加到`2`

# 还有更多。。。

向多个客户端发送相同的消息或数据称为广播。我们看到的方法向所有客户机广播消息，包括生成请求的客户机。

广播消息还有其他几种方法。例如：

```js
socket.to('commonRoom').emit('updateClientCount', data) 
```

它将向`commonRoom`中除发送方或发起请求的套接字之外的所有客户端发出`updateClientCount`事件。

有关完整列表，请查看 Socket.IO 发布备忘单的官方文档：[https://socket.io/docs/emit-cheatsheet/](https://socket.io/docs/emit-cheatsheet/)

# 为 Socket.IO 编写中间件

Socket.IO 允许我们在服务器端定义两种中间件功能：

*   **名称空间中间件**：注册一个函数，该函数为每个新连接的套接字执行，并具有以下签名：

```js
      namespace.use((socket, next) => { ... }) 
```

*   **套接字中间件**：注册一个为每个传入数据包执行的函数，并具有以下签名：

```js
      socket.use((packet, next) => { ... }) 
```

它的工作原理与 ExpressJS 中间件功能类似。我们可以向`socket`或`packet`对象添加新属性。然后，我们可以调用`next`将控制传递给链中的下一个中间件。如果没有调用`next`，则`socket`将无法连接，或者`packet`已收到。

# 准备

在此配方中，您将构建一个 Socket.IO 服务器应用程序，在其中定义中间件函数以限制对特定命名空间的访问，以及基于某些条件限制对特定套接字的访问。开始之前，创建一个新的`package.json`文件，包含以下内容：

```js
{ 
  "dependencies": { 
    "socket.io": "2.1.0" 
  } 
} 
```

然后，通过打开终端并运行以下命令来安装依赖项：

```js
    npm install
```

# 怎么做。。。

Socket.IO 服务器应用程序希望用户登录，以便能够连接到`/home`命名空间。使用套接字中间件，我们还将限制某个用户访问`/home`命名空间：

1.  创建一个名为`middleware-server.js`的新文件
2.  包括 Socket.IO 库并初始化新的 HTTP 服务器：

```js
      const http = require('http') 
      const fs = require('fs') 
      const path = require('path') 
      const io = require('socket.io')() 
      const app = http.createServer((req, res) => { 
          if (req.url === '/') { 
              fs.readFile( 
                  path.resolve(__dirname, 'middleware-cli.html'), 
                  (err, data) => { 
                      if (err) { 
                          res.writeHead(500) 
                          return void res.end() 
                      } 
                      res.writeHead(200) 
                      res.end(data) 
                  } 
              ) 
          } else { 
              res.writeHead(403) 
              res.end() 
          } 
      }) 
```

2.  指定创建新连接的路径：

```js
      io.path('/socket.io') 
```

3.  定义将用作内存中数据库的用户数组：

```js
      const users = [ 
          { username: 'huangjx', password: 'cfgybhji' }, 
          { username: 'johnstm', password: 'mkonjiuh' }, 
          { username: 'jackson', password: 'qscwdvb' }, 
      ] 
```

4.  定义一种方法以验证用户数组中是否存在提供的用户名和密码：

```js
      const userMatch = (username, password) => ( 
          users.find(user => ( 
              user.username === username && 
              user.password === password 
          )) 
      ) 
```

5.  定义一个命名空间中间件函数，该函数将检查用户是否已登录。如果客户端未登录，则无法使用此中间件连接到特定命名空间：

```js
      const isUserLoggedIn = (socket, next) => { 
          const { session } = socket.request 
          if (session && session.isLogged) { 
              next() 
          } 
      } 
```

6.  定义两个名称空间，一个用于`/login`，另一个用于`/home`。`/home`名称空间将使用我们之前定义的中间件功能检查用户是否登录：

```js
      const namespace = { 
          home: io.of('/home').use(isUserLoggedIn), 
          login: io.of('/login'), 
      } 
```

7.  当一个新的套接字连接到`/login`名称空间时，首先我们将定义一个套接字中间件函数，用于检查所有传入的包，并禁止访问`johntm`用户名。然后，我们将为 enter 事件添加一个事件侦听器，该事件将接收一个包含用户名和密码的普通对象，如果它们存在于 users 数组中，那么我们将设置一个 session 对象，该对象将告诉用户是否登录。否则，我们将向客户端发送一个带有错误消息的`loginError`事件：

```js
      namespace.login.on('connection', socket => { 
          socket.use((packet, next) => { 
              const [evtName, data] = packet 
              const user = data 
              if (evtName === 'tryLogin' 
                  && user.username === 'johnstm') { 
                  socket.emit('loginError', { 
                      message: 'Banned user!', 
                  }) 
              } else { 
                  next() 
              } 
          }) 
          socket.on('tryLogin', userData => { 
              const { username, password } = userData 
              const request = socket.request 
              if (userMatch(username, password)) { 
                  request.session = { 
                      isLogged: true, 
                      username, 
                  } 
                  socket.emit('loginSuccess') 
              } else { 
                  socket.emit('loginError', { 
                      message: 'invalid credentials', 
                  }) 
              } 
          }) 
      }) 
```

8.  在端口 1337 上侦听新连接并将 Socket.IO 连接到 HTTP 服务器：

```js
      io.attach(app.listen(1337, () => { 
          console.log( 
              'HTTP Server and Socket.IO running on port 1337' 
          ) 
      })) 
```

9.  保存文件

在此之后，构建一个 Socket.IO 客户端应用程序，该应用程序将连接到我们的 Socket.IO 服务器，并允许我们尝试登录和测试：

1.  创建一个名为`middleware-cli.html`的新文件
2.  添加以下代码：

```js
      <!DOCTYPE html> 
      <html lang="en"> 
      <head> 
          <meta charset="UTF-8"> 
          <title>Socket.IO Client</title> 
          <script src="http://localhost:1337/socket.io/socket.io.js">
          </script> 
          <script 
          src="https://unpkg.com/@babel/standalone/babel.min.js">
          </script> 
      </head> 
      <body> 
          <h1 id="title"></h1> 
          <form id="loginFrm" disabled> 
            <input type="text" name="username" placeholder="username"/> 
              <input type="password" name="password" 
                placeholder="password" /> 
              <input type="submit" value="LogIn" /> 
              <output name="logs"></output> 
          </form> 
          <script type="text/babel"> 
              // Code here 
          </script> 
      </body> 
      </html> 
```

3.  在脚本标记内，从步骤 4 开始，按以下步骤添加代码
4.  定义三个常量，用于引用我们将用于获取输入或显示输出的 HTML 元素：

```js
      const title = document.getElementById('home') 
      const error = document.getElementsByName('logErrors')[0] 
      const loginForm = document.getElementById('loginForm') 
```

5.  定义 Socket.IO 管理器：

```js
      const manager = new io.Manager( 
          'http://localhost:1337', 
          { path: '/socket.io' }, 
      ) 
```

6.  让我们定义一个名称空间常量，该常量将包含一个包含 Socket.IO 名称空间`/home`和`/login`的对象：

```js
      const namespace = { 
          home: manager.socket('/home'), 
          login: manager.socket('/login'), 
      } 
```

7.  将 connect 事件的事件侦听器添加到`/home`命名空间。只有当`/home`命名空间成功连接到服务器时才会触发：

```js
      namespace.home.on('connect', () => { 
          title.textContent = 'Great! you are connected to /home' 
          error.textContent = '' 
      }) 
```

8.  将`loginSuccess`事件的事件侦听器添加到`/login`命名空间。它将要求`/home`名称空间再次连接到服务器。如果用户已登录，则服务器将允许此连接：

```js
      namespace.login.on('loginSuccess', () => { 
          namespace.home.connect() 
      }) 
```

9.  将`loginError`事件的事件侦听器添加到`/login`命名空间。它将显示服务器发送的错误消息：

```js
      namespace.login.on('loginError', (err) => { 
          logs.textContent = err.message 
      }) 
```

10.  为登录表单的提交事件添加事件侦听器。它将发出 enter 事件，提供一个包含表单中填写的用户名和密码的对象：

```js
      form.addEventListener('submit', (event) => { 
          const body = new FormData(form) 
          namespace.login.emit('tryLogin', { 
              username: body.get('username'), 
              password: body.get('password'), 
          }) 
          event.preventDefault() 
      }) 
```

11.  保存文件

# 让我们测试一下。。。

要查看我们以前的工作，请执行以下操作：

1.  首先运行 Socket.IO 服务器。打开新终端并运行：

```js
 node middleware-server.js
```

2.  在 web 浏览器上，导航到：

```js
 http://localhost:1337
```

3.  您将看到一个带有两个字段的登录表单，`username`和`password`
4.  尝试使用随机无效凭据登录。将显示以下错误：

```js
      invalid credentials 
```

5.  接下来，尝试使用`johntm`作为`username`和任何`password`登录。将显示以下错误：

```js
      Banned user! 
```

6.  之后，使用其他两个有效凭据中的任意一个登录。例如，使用`jingxuan`作为用户名，使用`qscwdvb`作为密码。将显示以下标题：

```js
      Connected to /home 
```

# 将 Socket.IO 与 ExpressJS 集成

Socket.IO 与 ExpressJS 配合使用效果良好。事实上，可以使用相同的端口或 HTTP 服务器运行 ExpressJS 应用程序和 Socket.IO 服务器。

# 准备

在这个配方中，我们将看到如何将 Socket.IO 与 ExpressJS 集成。您将构建一个 ExpressJS 应用程序，该应用程序将提供一个包含 Socket.IO 客户端应用程序的 HTML 文件。开始之前，创建一个新的`package.json`文件，包含以下内容：

```js
{ 
  "dependencies": { 
    "express": "4.16.3", 
    "socket.io": "2.1.0" 
  } 
} 
```

然后，通过打开终端并运行以下命令来安装依赖项：

```js
npm install
```

# 怎么做。。。

创建一个 Socket.IO 客户端应用程序，该应用程序将连接到 Socket.IO 服务器，然后构建该服务器，并显示服务器发送的欢迎消息。

1.  创建一个名为`io-express-view.html`的新文件
2.  添加以下代码：

```js
      <!DOCTYPE html> 
      <html lang="en"> 
      <head> 
          <meta charset="UTF-8"> 
          <title>Socket.IO Client</title> 
          <script src="http://localhost:1337/socket.io/socket.io.js">
          </script> 
          <script 
           src="https://unpkg.com/@babel/standalone/babel.min.js">
          </script> 
      </head> 
      <body> 
          <h1 id="welcome"></h1> 
          <script type="text/babel"> 
              const welcome = document.getElementById('welcome') 
              const manager = new io.Manager( 
                  'http://localhost:1337', 
                  { path: '/socket.io' }, 
              ) 
              const root = manager.socket('/') 
              root.on('welcome', (msg) => { 
                  welcome.textContent = msg 
              }) 
          </script> 
      </body> 
      </html> 
```

3.  保存文件

接下来，构建一个 ExpressJS 应用程序和一个 Socket.IO 服务器。ExpressJS 应用程序将在根路径`"/"`上提供先前创建的 HTML 文件：

1.  创建一个名为`io-express-server.js`的新文件
2.  初始化新的 Socket.IO 服务器应用程序和 ExpressJS 应用程序：

```js
      const path = require('path') 
      const express = require('express') 
      const io = require('socket.io')() 
      const app = express() 
```

3.  定义与 Socket.IO 服务器建立新连接的 URL 路径：

```js
      io.path('/socket.io') 
```

4.  定义一个路由方法，为包含 Socket.IO 客户端应用程序的 HTML 文件提供服务：

```js
      app.get('/', (req, res) => { 
          res.sendFile(path.resolve( 
              __dirname, 
              'io-express-view.html', 
          )) 
      }) 
```

5.  定义名称空间`"/"`并发出带有欢迎消息的`welcome`事件：

```js
      io.of('/').on('connection', (socket) => { 
          socket.emit('welcome', 'Hello from Server!') 
      }) 
```

6.  将 Socket.IO 连接到 ExpressJS 服务器：

```js
      io.attach(app.listen(1337, () => { 
          console.log( 
              'HTTP Server and Socket.IO running on port 1337' 
          ) 
      })) 
```

7.  保存文件
8.  打开终端并运行：

```js
 node io-express-server.js
```

9.  在浏览器中，访问：

```js
http://localhost:1337/
```

# 它是如何工作的。。。

IO 的`attach`方法希望接收 HTTP 服务器作为参数，以便将 Socket.IO 服务器应用程序附加到它。我们可以将 Socket.IO 附加到 ExpressJS 服务器应用程序的原因是，`listen`方法返回 ExpressJS 所连接的底层 HTTP 服务器。

总之，`listen`方法返回底层 HTTP 服务器。然后，它作为参数传递给`attach`方法。这样，我们就可以与 ExpressJS 共享相同的连接。

# 还有更多。。。

到目前为止，我们已经看到，我们可以在 ExpressJS 和 Socket.IO 之间共享相同的底层 HTTP 服务器。然而，这还不是全部。

定义 Socket.IO 路径的原因在使用 ExpressJS 时非常有用。以以下为例：

```js
const express = require('express') 
const io = require('socket.io')() 
const app = express() 
io.path('/socket.io')
 app.get('/socket.io', (req, res) => { 
    res.status(200).send('Hey there!') 
}) 
io.of('/').on('connection', socket => { 
    socket.emit('someEvent', 'Data from Server!') 
}) 
io.attach(app.listen(1337)) 
```

如您所见，我们对 Socket.IO 和 ExpressJS 使用相同的 URL 路径。我们在`/socket.io`路径上接受到 Socket.IO 服务器的新连接，但我们也使用 GET route 方法发送`/socket.io`的内容。

即使前面的示例实际上不会破坏您的应用程序，但请确保永远不要使用相同的 URL 路径来提供来自 ExpressJS 的内容，并同时接受 Socket.IO 的新连接。例如，将以前的代码更改为：

```js
io.path('/socket.io')
 app.get('/socket.io/:msg', (req, res) => { 
    res.status(200).send(req.params.msg) 
}) 
```

虽然您可能希望您的浏览器在访问`http://localhost:1337/socket.io/message`时显示`message`，但情况并非如此，您将看到以下内容：

```js
{"code":0,"message":"Transport unknown"} 
```

这是因为 Socket.IO 将首先解释传入的数据，而它不会理解您刚才发送的数据。此外，您的路由处理程序将永远不会执行。

此外，默认情况下，Socket.IO 服务器还在定义的 URL 路径下为自己的 Socket.IO 客户端提供服务。例如，尝试访问[http://localhost:1337/socket.io/socket.io.js](http://localhost:1337/socket.io/socket.io.js) 您将能够看到 Socket.IO 客户端的最小化 JavaScript 代码。

如果您希望为自己版本的 Socket.IO 客户端提供服务器，或者如果它包含在应用程序包中，则可以使用`serveClient`方法禁用 Socket.IO 服务器应用程序中的默认行为：

```js
io.serveClient(false) 
```

# 另见

*   [第 2 章](2.html)*用 ExpressJS*构建 Web 服务器*节使用 Express.js 内置的中间件功能服务静态资产*

# 在 Socket.IO 中使用 ExpressJS 中间件

IO 命名空间中间件的工作原理与 ExpressJS 中间件非常相似。事实上，套接字对象还包含一个`request`和一个`response`对象，我们可以使用它们来存储其他属性，就像我们使用 ExpressJS 中间件函数一样：

```js
namespace.use((socket, next) => { 
    const req = socket.request 
    const res = socket.request.res 
    next() 
}) 
```

因为 ExpressJS 中间件函数具有以下签名：

```js
const expressMiddleware = (request, response, next) => { 
    next() 
} 
```

我们可以在 Socket.IO 命名空间中间件中通过必要的参数安全地执行相同的函数：

```js
root.use((socket, next) => { 
    const req = socket.request 
    const res = socket.request.res 
    expressMiddleware(req, res, next) 
}) 
```

然而，这并不意味着所有的 ExpressJS 中间件功能都可以开箱即用。例如，如果 ExpressJS 中间件函数使用仅在 ExpressJS 中可用的方法，则它可能会失败或出现意外行为。

# 准备

在这个配方中，我们将看到如何集成 ExpressJS`express-session`中间件，以便在 Socket.IO 和 ExpressJS 之间共享会话对象。开始之前，创建一个新的`package.json`文件，包含以下内容：

```js
{ 
  "dependencies": { 
    "express": "4.16.3", 
    "express-session": "1.15.6", 
    "socket.io": "2.1.0" 
  } 
} 
```

然后，通过打开终端并运行以下命令来安装依赖项：

```js
npm install
```

# 怎么做。。。

构建一个 Socket.IO 客户端应用程序，该应用程序将连接到下一步要构建的 Socket.IO 服务器。包括一个表单，用户可以在其中键入用户名和密码以尝试登录。Socket.IO 客户端只有在用户登录后才能连接到`/home`命名空间：

1.  创建一个名为`io-express-cli.html`的新文件
2.  添加以下 HTML 内容：

```js
      <!DOCTYPE html> 
      <html lang="en"> 
      <head> 
          <meta charset="UTF-8"> 
          <title>Socket.IO Client</title> 
          <script src="http://localhost:1337/socket.io/socket.io.js">  
          </script> 
          <script 
           src="https://unpkg.com/@babel/standalone/babel.min.js">
          </script> 
      </head> 
      <body> 
          <h1 id="title"></h1> 
          <form id="loginForm"> 
            <input type="text" name="username" placeholder="username"/> 
              <input type="password" name="password" 
                placeholder="password" /> 
              <input type="submit" value="LogIn" /> 
              <output name="logErrors"></output> 
          </form> 
          <script type="text/babel"> 
              // Code here 
          </script> 
      </body> 
      </html> 
```

3.  在脚本标记中，从步骤 4 开始，在接下来的步骤中添加代码
4.  定义引用我们将使用的 HTML 元素的常量：

```js
      const title = document.getElementById('title') 
      const error = document.getElementsByName('logErrors')[0] 
      const loginForm = document.getElementById('loginForm') 
```

5.  定义 Socket.IO 管理器：

```js
      const manager = new io.Manager( 
          'http://localhost:1337', 
          { path: '/socket.io' }, 
      ) 
```

6.  定义两个名称空间，一个用于`/login`，另一个用于`/home`：

```js
      const namespace = { 
          home: manager.socket('/home'), 
          login: manager.socket('/login'), 
      } 
```

7.  为`welcome`事件添加事件侦听器，一旦允许连接到`/home`命名空间，服务器端将触发该事件：

```js
      namespace.home.on('welcome', (msg) => { 
          title.textContent = msg 
          error.textContent = '' 
      }) 
```

8.  为`loginSuccess`事件添加一个事件侦听器，该事件在触发时将请求`/home`命名空间尝试并重新连接到 Socket.IO 服务器：

```js
      namespace.login.on('loginSuccess', () => { 
          namespace.home.connect() 
      }) 
```

9.  为`loginError`事件添加一个事件侦听器，该事件在提供无效凭据时将显示错误：

```js
      namespace.login.on('loginError', err => { 
          error.textContent = err.message 
      }) 
```

10.  为提交表单时将触发的`submit`事件添加事件侦听器。它将发出一个`enter`事件，其数据包含提供的`username`和`password`：

```js
      loginForm.addEventListener('submit', event => { 
          const body = new FormData(loginForm) 
          namespace.login.emit('enter', { 
              username: body.get('username'), 
              password: body.get('password'), 
          }) 
          event.preventDefault() 
      }) 
```

11.  保存文件。

在此之后，构建一个 ExpressJS 应用程序，该应用程序将在根路径`"/"`上为 Socket.IO 客户端提供服务，并构建一个 Socket.IO 服务器，该服务器将包含用于记录用户的逻辑：

1.  创建一个名为`io-express-srv.js`的新文件
2.  初始化新的 ExpressJS 应用程序和 Socket.IO 服务器应用程序。此外，包括`express-session`NPM 模块：

```js
      const path = require('path') 
      const express = require('express') 
      const io = require('socket.io')() 
      const expressSession = require('express-session') 
      const app = express() 
```

3.  定义与 Socket.IO 服务器建立新连接的路径：

```js
      io.path('/socket.io') 
```

4.  使用给定选项定义 ExpressJS 会话中间件函数：

```js
      const session = expressSession({ 
          secret: 'MERN Cookbook Secret', 
          resave: true, 
          saveUninitialized: true, 
      }) 
```

5.  定义 Socket.IO 命名空间中间件，该中间件将使用先前创建的会话中间件生成会话对象：

```js
      const ioSession = (socket, next) => { 
          const req = socket.request 
          const res = socket.request.res 
          session(req, res, (err) => { 
              next(err) 
              req.session.save() 
          }) 
      } 
```

6.  定义两个名称空间，一个用于`/home`，另一个用于`/login`：

```js
      const home = io.of('/home') 
      const login = io.of('/login') 
```

7.  定义一个内存中的数据库或对象数组，其中包含`username`和`password`属性。这些定义允许哪些用户登录：

```js
      const users = [ 
          { username: 'huangjx', password: 'cfgybhji' }, 
          { username: 'johnstm', password: 'mkonjiuh' }, 
          { username: 'jackson', password: 'qscwdvb' }, 
      ] 
```

8.  在 ExpressJS 中包括会话中间件：

```js
      app.use(session) 
```

9.  为`/home`路径添加路由方法，该路径将服务于我们先前创建的包含 Socket.IO 客户端的 HTML 文档：

```js
      app.get('/home', (req, res) => { 
          res.sendFile(path.resolve( 
              __dirname, 
              'io-express-cli.html', 
          )) 
      }) 
```

10.  使用`/home`Socket.IO 命名空间中的会话中间件。然后，如果用户已登录，请检查每个新套接字。如果不是，则禁止用户连接到此命名空间：

```js
      home.use(ioSession) 
      home.use((socket, next) => { 
          const { session } = socket.request 
          if (session.isLogged) { 
              next() 
          } 
      }) 
```

11.  一旦连接到`/home`名称空间，意味着用户可以登录，就会发出`welcome`事件，并向用户显示欢迎消息：

```js
      home.on('connection', (socket) => { 
          const { username } = socket.request.session 
          socket.emit( 
              'welcome', 
              `Welcome ${username}!, you are logged in!`, 
          ) 
      }) 
```

12.  使用`/login`Socket.IO 命名空间中的会话中间件。然后，当客户端使用提供的用户名和密码发出一个`enter`事件时，它会验证`users`数组中是否存在配置文件。如果用户存在，将`isLogged`属性设置为`true`，将`username`属性设置为当前登录用户：

```js
      login.use(ioSession) 
      login.on('connection', (socket) => { 
          socket.on('enter', (data) => { 
              const { username, password } = data 
              const { session } = socket.request 
              const found = users.find((user) => ( 
                  user.username === username && 
                  user.password === password 
              )) 
              if (found) { 
                  session.isLogged = true 
                  session.username = username 
                  socket.emit('loginSuccess') 
              } else { 
                  socket.emit('loginError', { 
                      message: 'Invalid Credentials', 
                  }) 
              } 
          }) 
      }) 
```

13.  在端口`1337`上侦听新连接，并将 Socket.IO 服务器连接到该端口：

```js
      io.attach(app.listen(1337, () => { 
          console.log( 
              'HTTP Server and Socket.IO running on port 1337' 
          ) 
      })) 
```

14.  保存文件
15.  打开新终端并运行：

```js
 node io-express-srv.js  
```

16.  在浏览器中，访问：

```js
 http://localhost:1337/home
```

17.  使用有效凭据登录。例如：

```js
      * Username: johntm
      * Password: mkonjiuh
```

18.  如果您成功登录，刷新页面后，您的 Socket.IO 客户端应用程序仍将能够连接到`/home`，并且您每次都会看到欢迎消息

# 它是如何工作的。。。

在 ExpressJS 内部使用会话中间件时，修改会话对象后，在响应结束时自动调用`save`方法。但是，在 Socket.IO 名称空间中使用会话中间件时，情况并非如此，这就是为什么我们手动调用`save`方法将会话保存回存储。在我们的例子中，存储是会话在服务器停止之前一直保存的内存。

借助 Socket.IO 命名空间中间件，基于特定条件禁止访问某些命名空间是可能的。如果控件未传递给`next`处理程序，则不进行连接。这就是为什么登录成功后，我们要求`/home`名称空间再次尝试连接。

# 另见

*   [第 2 章](2.html)*用 ExpressJS*构建 Web 服务器*节编写中间件功能*