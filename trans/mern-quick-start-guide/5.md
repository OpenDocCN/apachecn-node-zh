# 使用 Redux 管理状态

在本章中，我们将介绍以下配方：

*   定义动作和动作创建者
*   定义减速器函数
*   创建 Redux 存储
*   将操作创建者绑定到分派方法
*   分解和组合减速器
*   编写 Redux 存储增强器
*   时间旅行与 Redux
*   理解 Redux 中间件
*   处理异步数据流

# 技术要求

您需要具有 IDE、Visual Studio 代码、Node.js 和 MongoDB。您还需要安装 Git，以便使用本书的 Git 存储库。

本章代码文件可在 GitHub 上找到：
[https://github.com/PacktPublishing/MERN-Quick-Start-Guide/tree/master/Chapter05](https://github.com/PacktPublishing/MERN-Quick-Start-Guide/tree/master/Chapter05)

查看以下视频以查看代码的运行：
[https://goo.gl/mU9AjR](https://goo.gl/mU9AjR)

# 介绍

Redux 是 JavaScript 应用程序的可预测状态容器。它允许开发人员轻松地管理其应用程序的状态。对于 Redux，状态是不可变的。因此，可以来回切换到应用程序的下一个或上一个状态。Redux 必须遵守三项核心原则：

*   **单一真相来源**：应用程序的所有状态必须存储在单个存储区内的单个对象树中
*   **状态为只读**：不能对状态树进行变异。只有通过分派操作，状态树才能更改
*   **使用纯函数**进行更改：这些被称为还原器，是接受先前状态和动作并计算新状态的函数。还原程序决不能改变以前的状态，而是总是返回一个新的状态

减速器的工作方式与`Array.prototype.reduce`函数的工作方式非常相似。`reduce`方法针对累加器对数组中的每个项执行一个函数，以将其减少为单个值。例如：

```
const a = 5 
const b = 10 
const c = [a, b].reduce((accumulator, value) => { 
    return accumulator + value 
}, 0) 
```

将`a`和`b`与`accumulator`相减时，变量`c`中的结果值为`15`，初始值为`0`。这里的减速器功能是：

```
(accumulator, value) => { 
    return accumulator + value 
} 
```

Redux 减缩器也是以类似的方式编写的，它们是 Redux 最重要的概念。例如：

```
const reducer = (prevState, action) => newState 
```

在本章中，我们将重点学习如何使用 Redux 管理简单和复杂的状态树。您还将学习如何处理异步数据流。

# 定义动作和动作创建者

还原程序接受一个`action`对象，该对象描述将要执行的操作，并决定如何基于该`action`对象转换状态。

动作只是普通对象，它们只有一个必需的属性，即动作类型。例如：

```
const action = { 
    type: 'INCREMENT_COUNTER', 
} 
```

我们还可以提供其他属性。例如：

```
const action = { 
    type: 'INCREMENT_COUNTER', 
    incrementBy: 2, 
} 
```

动作创建者只是返回动作的函数，例如：

```
const increment = (incrementBy) => ({ 
    type: 'INCREMENT_COUNTER', 
    incrementBy, 
}) 
```

# 准备

在这个配方中，您将看到如何将这些简单的 Redux 概念与`Array.prototype.reduce`一起应用，以决定应如何累积或减少数据。

为此，我们还不需要 Redux 库。

# 怎么做。。。

构建一个小型 JavaScript 应用程序，根据提供的操作增加或减少计数器。

1.  创建一个名为`counter.js`的新文件
2.  将操作类型定义为常量：

```
      const INCREMENT_COUNTER = 'INCREMENT_COUNTER' 
      const DECREMENT_COUNTER = 'DECREMENT_COUNTER' 
```

3.  定义两个动作创建者，生成两种动作到`increment`和`decrement`计数器：

```
      const increment = (by) => ({ 
          type: INCREMENT_COUNTER, 
          by, 
      }) 
      const decrement = (by) => ({ 
          type: DECREMENT_COUNTER, 
          by, 
      }) 
```

4.  将初始累加器初始化为`0`，然后通过多个操作将其减少。减速器功能将根据动作类型决定执行哪种动作：

```
      const reduced = [ 
          increment(10), 
          decrement(5), 
          increment(3), 
      ].reduce((accumulator, action) => { 
          switch (action.type) { 
              case INCREMENT_COUNTER: 
            return accumulator + action.by 
              case DECREMENT_COUNTER: 
                  return accumulator - action.by 
              default: 
                  return accumulator 
          } 
      }, 0) 
```

5.  记录结果值：

```
      console.log(reduced) 
```

6.  保存文件
7.  打开终端并运行：

```
       node counter.js

```

7.  输出：`8`

# 它是如何工作的。。。

1.  减速器遇到的第一个动作类型是`increment(10)`，它将使蓄能器增加`10`。由于累加器的初始值为`0`，因此下一个电流值将为`10`
2.  第二种动作类型告诉减速器功能将蓄能器减小量`5`。因此，累加器的值将为`5`。
3.  最后一个动作类型告诉减速器功能将蓄能器增加`3`。因此，累加器的值将为`8`。

# 定义减速器函数

Redux 减缩器是纯函数。也就是说，它们没有副作用。给定相同的参数，减速器必须始终生成相同的状态形状。以以下减速器功能为例：

```
const reducer = (prevState, action) => { 
    if (action.type === 'INC') { 
        return { counter: prevState.counter + 1 } 
    } 
    return prevState 
} 
```

如果执行此函数时提供相同的参数，结果将始终相同：

```
const a = reducer( 
   { counter: 0 }, 
   { type: 'INC' }, 
) // Value is { counter: 1 }  
const b = reducer( 
   { counter: 0 }, 
   { type: 'INC' }, 
) // Value is { counter: 1 } 
```

However, take into account that even though the returned values have the same shape, these are two different objects. For instance, comparing the above:
`console.log(a === b)` returns false.

不纯还原函数会阻止应用程序状态的可预测性，并使复制相同状态变得困难。例如：

```
const impureReducer = (prevState = {}, action) => { 
    if (action.type === 'SET_TIME') { 
        return { time: new Date().toString() } 
    } 
    return prevState 
} 
```

如果我们执行此功能：

```
const a = impureReducer({}, { type: 'SET_TIME' }) 
setTimeout(() => { 
    const b = impureReducer({}, { type: 'SET_TIME' }) 
    console.log( 
        a, // Output may be: {time: "22:10:15 GMT+0000"} 
        b, // Output may be: {time: "22:10:17 GMT+0000"} 
    ) 
}, 2000) 
```

如您所见，在 2 秒后执行函数第二次后，我们得到了不同的结果。为了使它纯净，你可以考虑改写以前不纯的还原剂：

```
const timeReducer = (prevState = {}, action) => { 
    if (action.type === 'SET_TIME') { 
        return { time: action.time } 
    } 
    return prevState 
} 
```

然后，您可以在操作中安全地传递时间属性以设置时间：

```
const currentTime = new Date().toTimeString() 
const a = timeReducer( 
   { time: null }, 
   { type: 'SET_TIME', time: currentTime }, 
) 
const b = timeReducer( 
   { time: null }, 
   { type: 'SET_TIME', time: currentTime }, 
) 
console.log(a.time === b.time) // true 
```

这种方法使您的状态可预测，并且状态易于重现。例如，如果您在上午或下午的任何时间传递`time`属性，您可以重新创建应用程序将如何运行的场景。

# 准备

现在您已经了解了减速机如何工作的概念，在此配方中，您将构建一个小型应用程序，该应用程序将根据状态变化采取不同的操作。

为此，您还不需要安装或使用 Redux 库。

# 怎么做。。。

构建一个应用程序，根据当地时间提醒您应该吃什么样的饭菜。在单个对象树中管理应用程序的所有状态。还提供一种方法来模拟应用程序在`00:00a.m`或`12:00p.m`时将显示什么：

1.  创建一个名为`meal-time.html`的新文件。
2.  添加以下代码：

```
      <!DOCTYPE html> 
      <html lang="en"> 
      <head> 
          <meta charset="UTF-8"> 
          <title>Breakfast Time</title> 
          <script 
         src="https://unpkg.com/@babel/standalone/babel.min.js">  
        </script> 
      </head> 
      <body> 
          <h1>What you need to do:</h1> 
          <p> 
              <b>Current time:</b> 
              <span id="display-time"></span> 
          </p> 
                <p id="display-meal"></p> 
                <button id="emulate-night"> 
              Let's pretend is 00:00:00 
          </button> 
          <button id="emulate-noon"> 
              Let's pretend is 12:00:00 
          </button> 
          <script type="text/babel"> 
              // Add JavaScript code here 
          </script> 
      </body> 
      </html> 
```

3.  从步骤 4 开始，在脚本标记中添加在下一步中定义的代码。
4.  定义一个变量`state`，该变量将包含所有状态树，然后是下一个状态：

```
      let state = { 
          kindOfMeal: null, 
          time: null, 
      } 
```

5.  创建对 HTML 元素的引用，用于显示数据或添加事件侦听器：

```
      const meal = document.getElementById('display-meal') 
      const time = document.getElementById('display-time') 
      const btnNight = document.getElementById('emulate-night') 
      const btnNoon = document.getElementById('emulate-noon') 
```

6.  定义两种操作类型：

```
      const SET_MEAL = 'SET_MEAL' 
      const SET_TIME = 'SET_TIME' 
```

7.  定义一个动作创建者，用于设置用户应拥有的膳食类型：

```
      const setMeal = (kindOfMeal) => ({ 
          type: SET_MEAL, 
          kindOfMeal, 
      }) 
```

8.  定义用于设置时间的操作创建者：

```
      const setTime = (time) => ({ 
          type: SET_TIME, 
          time, 
      }) 
```

9.  定义一个 reducer 函数，该函数将在调度操作时计算新状态：

```
      const reducer = (prevState = state, action) => { 
          switch (action.type) { 
              case SET_MEAL: 
                  return Object.assign({}, prevState, { 
                      kindOfMeal: action.kindOfMeal, 
                  }) 
              case SET_TIME: 
                  return Object.assign({}, prevState, { 
                      time: action.time, 
                  }) 
              default: 
                  return prevState 
          } 
      } 
```

10.  添加一个在状态更改时调用的函数，以便更新视图：

```
      const onStateChange = (nextState) => { 
          const comparison = [ 
              { time: '23:00:00', info: 'Too late for dinner!' }, 
              { time: '18:00:00', info: 'Dinner time!' }, 
              { time: '16:00:00', info: 'Snacks time!' }, 
              { time: '12:00:00', info: 'Lunch time!' }, 
              { time: '10:00:00', info: 'Branch time!' }, 
              { time: '05:00:00', info: 'Breakfast time!' }, 
              { time: '00:00:00', info: 'Too early for breakfast!' }, 
          ] 
          time.textContent = nextState.time 
          meal.textContent = comparison.find((condition) => ( 
              nextState.time >= condition.time 
          )).info 
      } 
```

11.  定义一个调度函数，通过将当前状态和操作传递给 reducer 来生成一个新的状态树。然后，它将调用`onChangeState`函数通知您的应用程序状态已更改：

```
      const dispatch = (action) => { 
          state = reducer(state, action) 
          onStateChange(state) 
      } 
```

12.  为将模拟时间为`00:00a.m`的按钮添加事件侦听器：

```
      btnNight.addEventListener('click', () => { 
          const time = new Date('1/1/1 00:00:00') 
          dispatch(setTime(time.toTimeString())) 
      }) 
```

13.  为将模拟时间为`12:00p.m`的按钮添加事件侦听器：

```
      btnNoon.addEventListener('click', () => { 
          const time = new Date('1/1/1 12:00:00') 
          dispatch(setTime(time.toTimeString())) 
      }) 
```

14.  脚本运行后，使用视图更新的当前时间调度操作：

```
      dispatch(setTime(new Date().toTimeString())) 
```

15.  保存文件。

# 让我们测试一下。。。

要查看您以前的工作，请执行以下操作：

1.  在 web 浏览器中打开`meal-time.html`文件。您可以双击该文件，或右键单击该文件并选择“打开方式…”。。。。
2.  你应该能够看到你当前的当地时间和一条信息，说明你应该吃什么样的饭。例如，如果您的本地时间是`20:42:35 GMT+0800 (CST)`，您应该看到`Dinner time!`
3.  单击按钮`"Let's pretend is 00:00:00"`查看如果时间为`00:00a.m`，应用程序将显示什么。
4.  同样，单击按钮`"Let's pretend is 12:00:00"`，查看如果时间为`12:00p.m`，应用程序将显示什么。

# 它是如何工作的。。。

我们可以对应用程序进行如下总结，以了解其工作原理：

1.  定义了动作类型`SET_MEAL`和`SET_TIME`。
2.  定义了两个动作创建者：
    1.  `setMeal`生成具有`SET_MEAL`动作类型的动作和具有提供参数的`kindOfMeal`属性
    2.  `setTime`生成具有`SET_TIME`动作类型的动作和具有提供参数的`time`属性

3.  定义了减速器功能：
    1.  对于动作类型`SET_MEAL`，使用新的`kindOfMeal`属性计算新状态
    2.  对于动作类型`SET_TIME`，使用新的`time`属性计算新状态

4.  我们定义了一个函数，当状态树更改时将调用该函数。在函数内部，我们根据新状态更新了视图。
5.  定义了一个`dispatch`函数，该函数调用提供先前状态的 reducer 函数和生成新状态的 action 对象。

# 创建 Redux 存储

在前面的菜谱中，我们已经看到了如何定义减速机和操作。我们还看到了如何创建一个分派函数来分派还原程序的操作以更新状态。存储是一个对象，它提供了一个小 API 来将所有这些放在一起。

redux 模块公开了我们可以用来创建存储的`createStore`方法。其签名如下：

```
createStore(reducer, preloadedState, enhancer) 
```

最后两个参数是可选的。例如，使用单个减速机创建存储可能如下所示：

```
const TYPE = { 
    INC_COUNTER: 'INC_COUNTER', 
    DEC_COUNTER: 'DEC_COUNTER', 
} 
const initialState = { 
    counter: 0, 
} 
const reducer = (state = initialState, action) => { 
    switch (action.type) { 
        case TYPE.INC_COUNTER:  
            return { counter: state.counter + 1 } 
        case TYPE.DEC_COUNTER:  
            return { counter: state.counter - 1 } 
        default:  
            return state 
    } 
} 
const store = createStore(reducer) 
```

调用`createStore`将公开四种方法：

*   `store.dispatch(action)`：其中 action 是至少包含一个名为`type`的属性的对象，该属性指定了 action 类型
*   `store.getState()`：返回整个状态树
*   `store.subscribe(listener)`：其中 listener 是一个回调函数，在状态树发生变化时会被触发。可以订阅多个侦听器
*   `store.replaceReducer(reducer)`：用新的减速机功能替换当前的减速机功能

# 准备

在此配方中，您将重新构建在上一配方中构建的应用程序。但是，这次您将使用 Redux。开始之前，创建一个新的`package.json`文件，包含以下内容：

```
{ 
    "dependencies": { 
        "express": "4.16.3", 
        "redux": "4.0.0" 
    } 
} 
```

然后，通过打开终端并运行以下命令来安装依赖项：

```
npm install

```

# 怎么做。。。

首先，构建一个小型 ExpressJS 服务器应用程序，其唯一目的是为 HTML 文件和 Redux 模块提供服务：

1.  创建一个名为`meal-time-server.js`的新文件
2.  包括 ExpressJS 和`path`模块，并初始化新的 ExpressJS 应用程序：

```
      const express = require('express') 
      const path = require('path') 
      const app = express() 
```

3.  为`/lib`路径上的 Redux 库提供服务。确保路径指向`node_modules`文件夹：

```
      app.use('/lib', express.static( 
          path.join(__dirname, 'node_modules', 'redux', 'dist') 
      )) 
```

4.  在根路径`/`上为客户端应用程序提供服务：

```
      app.get('/', (req, res) => { 
          res.sendFile(path.join( 
              __dirname, 
              'meal-time-client.html', 
          )) 
      }) 
```

5.  侦听端口`1337`上的新连接：

```
      app.listen( 
          1337, 
          () => console.log('Web Server running on port 1337'), 
      ) 
```

6.  保存文件

现在，按照以下步骤使用 Redux 构建客户端应用程序：

1.  创建一个名为`meal-time-client.html`的新文件。
2.  添加以下代码：

```
      <!DOCTYPE html> 
      <html lang="en"> 
      <head> 
          <meta charset="UTF-8"> 
          <title>Meal Time with Redux</title> 
          <script 
          src="https://unpkg.com/@babel/standalone/babel.min.js">
         </script> 
          <script src="/lib/redux.js"></script> 
      </head> 
      <body> 
          <h1>What you need to do:</h1> 
          <p> 
              <b>Current time:</b> 
              <span id="display-time"></span> 
          </p> 
          <p id="display-meal"></p> 
          <button id="emulate-night"> 
              Let's pretend is 00:00:00 
          </button> 
          <button id="emulate-noon"> 
              Let's pretend is 12:00:00 
          </button> 
          <script type="text/babel"> 
              // Add JavaScript code here 
          </script> 
      </body> 
      </html> 
```

3.  在 script 标记中，添加从步骤 4 开始的后续步骤的代码。
4.  从 Redux 库中提取`createStore`方法：

```
      const { createStore } = Redux 
```

5.  定义应用程序的初始状态：

```
      const initialState = { 
          kindOfMeal: null, 
          time: null, 
      } 
```

6.  保留用于显示状态或与应用程序交互的 HTML DOM 元素的引用：

```
      const meal = document.getElementById('display-meal') 
      const time = document.getElementById('display-time') 
      const btnNight = document.getElementById('emulate-night') 
      const btnNoon = document.getElementById('emulate-noon') 
```

7.  定义两种操作类型：

```
      const SET_MEAL = 'SET_MEAL' 
      const SET_TIME = 'SET_TIME' 
```

8.  定义两个动作创建者：

```
      const setMeal = (kindOfMeal) => ({ 
          type: SET_MEAL, 
          kindOfMeal, 
      }) 
      const setTime = (time) => ({ 
          type: SET_TIME, 
          time, 
      }) 
```

9.  定义在调度`SET_TIME`和/或`SET_TIME`动作类型时将转换状态的减速器：

```
      const reducer = (prevState = initialState, action) => { 
          switch (action.type) { 
              case SET_MEAL: 
                  return {...prevState, 
                      kindOfMeal: action.kindOfMeal, 
                  } 
              case SET_TIME: 
                  return {...prevState, 
                      time: action.time, 
                  } 
              default: 
                  return prevState 
          } 
      } 
```

10.  创建新的 Redux 存储：

```
      const store = createStore(reducer) 
```

11.  订阅一个回调函数来更改存储。每当存储更改时，将触发此回调，并根据存储中的更改更新视图：

```
      store.subscribe(() => { 
          const nextState = store.getState() 
          const comparison = [ 
              { time: '23:00:00', info: 'Too late for dinner!' }, 
              { time: '18:00:00', info: 'Dinner time!' }, 
              { time: '16:00:00', info: 'Snacks time!' }, 
              { time: '12:00:00', info: 'Lunch time!' }, 
              { time: '10:00:00', info: 'Brunch time!' }, 
              { time: '05:00:00', info: 'Breakfast time!' }, 
              { time: '00:00:00', info: 'Too early for breakfast!' }, 
          ] 
          time.textContent = nextState.time 
          meal.textContent = comparison.find((condition) => ( 
              nextState.time >= condition.time 
          )).info 
      }) 
```

12.  为我们按钮的`click`事件添加一个事件监听器，该监听器将调度`SET_TIME`动作类型以将时间设置为`00:00:00`：

```
      btnNight.addEventListener('click', () => { 
          const time = new Date('1/1/1 00:00:00') 
          store.dispatch(setTime(time.toTimeString())) 
      }) 
```

13.  为我们按钮的`click`事件添加一个事件监听器，该监听器将调度`SET_TIME`动作类型以将时间设置为`12:00:00`：

```
      btnNoon.addEventListener('click', () => { 
          const time = new Date('1/1/1 12:00:00') 
          store.dispatch(setTime(time.toTimeString())) 
      }) 
```

14.  首次启动应用程序时，调度操作以将时间设置为当前本地时间：

```
      store.dispatch(setTime(new Date().toTimeString())) 
```

15.  保存文件

# 让我们测试一下。。。

要查看以前的工作，请执行以下操作：

1.  打开新终端并运行：

```
 node meal-time-server.js
```

2.  在 web 浏览器中，访问：

```

       http://localhost:1337/
```

3.  你应该能够看到你当前的当地时间和一条信息，说明你应该吃什么样的饭。例如，如果您的本地时间是`20:42:35 GMT+0800 (CST)`，您应该看到`Dinner time!`
4.  单击按钮`"Let's pretend is 00:00:00"`查看如果时间为`00:00a.m`，应用程序将显示什么。
5.  同样，单击`"Let's pretend is 12:00:00"`按钮，查看如果时间为`12:00p.m`，应用程序将显示什么。

# 还有更多

您可以使用 ES6 spread 运算符而不是`Object.assign`来合并上一个状态与下一个状态，例如，我们重新编写了上一个配方的 reducer 函数：

```
const reducer = (prevState = initialState, action) => { 
    switch (action.type) { 
        case SET_MEAL: 
            return Object.assign({}, prevState, { 
                kindOfMeal: action.kindOfMeal, 
            }) 
        case SET_TIME: 
            return Object.assign({}, prevState, { 
                time: action.time, 
            }) 
        default: 
            return prevState 
    } 
} 
```

我们将其改写如下：

```
const reducer = (prevState = initialState, action) => { 
    switch (action.type) { 
        case SET_MEAL: 
            return {...prevState, 
                kindOfMeal: action.kindOfMeal, 
            } 
        case SET_TIME: 
            return {...prevState, 
                time: action.time, 
            } 
        default: 
            return prevState 
    } 
} 
```

这可以使代码更具可读性。

# 将操作创建者绑定到分派方法

Actions Creator 只是生成 action 对象的函数，以后可以使用`dispatch`方法来调度 action。以以下代码为例：

```
const TYPES = { 
    ADD_ITEM: 'ADD_ITEM', 
    REMOVE_ITEM: 'REMOVE_ITEM', 
} 
const actions = { 
    addItem: (name, description) => ({ 
        type: TYPES.ADD_ITEM, 
        payload: { name, description }, 
    }), 
    removeItem: (id) => ({ 
        type: TYPES.REMOVE_ITEM, 
        payload: { id }, 
    }) 
} 
module.exports = actions 
```

稍后，在应用程序的某个地方，您可以使用`dispatch`方法分派这些操作：

```
dispatch(actions.addItem('Little Box', 'Cats')) 
dispatch(actions.removeItem(123)) 
```

但是，正如您所看到的，每次调用`dispatch`方法似乎都是重复的、不必要的步骤。您可以简单地将动作创建者包装在`dispatch`函数本身周围，如下所示：

```
const actions = { 
    addItem: (name, description) => dispatch({ 
        type: TYPES.ADD_ITEM, 
        payload: { name, description }, 
    }), 
    removeItem: (id) => dispatch({ 
        type: TYPES.REMOVE_ITEM, 
        payload: { id }, 
    }) 
} 
module.exports = actions 
```

尽管这似乎是一个很好的解决方案，但也存在一个问题。这意味着，您需要首先创建存储，然后定义将它们绑定到`dispatch`方法的动作创建者。此外，很难在单独的文件中维护动作创建者，因为它们依赖于`dispatch`方法。Redux 模块提供了一个解决方案，一个名为`bindActionCreators`的助手方法，它接受两个参数。第一个参数是一个对象，其中包含键（表示动作创建者的名称）和值（表示返回动作的函数）。第二个参数应该是`dispatch`函数：

```
bindActionCreators(actionCreators, dispatchMethod) 
```

此助手方法将所有动作创建者映射到分派方法。例如，我们可以将前面的示例改写为：

```
const store = createStore(reducer) 
const originalActions = require('./actions') 
const actions = bindActionCreators( 
    originalActions, 
    store.dispatch, 
) 
```

然后，稍后在应用程序的某个地方，您可以调用这些方法，而无需将它们包装在`dispatch`方法中：

```
actions.addItem('Little Box', 'Cats') 
actions.removeItem(123) 
```

我们的创造者现在可以看到更多的常规功能。事实上，通过分解`actions`对象，您只能使用所需的方法。例如：

```
const { 
    addItem, 
    removeItem, 
} = bindActionCreators( 
    originalActions,  
    store.dispatch, 
) 
```

然后，你可以这样称呼他们：

```
addItem('Little Box', 'Cats') 
removeItem(123) 
```

# 准备

在这个配方中，您将构建一个简单的应用程序，并将使用刚才学习的关于绑定动作创建者的概念。首先，创建一个包含以下内容的新`package.json`文件：

```
{ 
    "dependencies": { 
        "express": "4.16.3", 
        "redux": "4.0.0" 
    } 
} 
```

然后，通过打开终端并运行以下命令来安装依赖项：

```
npm install
```

# 怎么做。。。

要定义此方法，请使用`dispatch`来创建您的应用程序。

首先，构建一个小型 ExpressJS 应用程序，该应用程序将为 HTML 文件提供服务，该文件包含我们将在以下步骤后构建的待办事项客户端应用程序：

1.  创建一个名为`bind-server.js`的新文件
2.  添加以下代码：

```
      const express = require('express') 
      const path = require('path') 
      const app = express() 
      app.use('/lib', express.static( 
          path.join(__dirname, 'node_modules', 'redux', 'dist') 
      )) 
      app.get('/', (req, res) => { 
          res.sendFile(path.join( 
              __dirname, 
              'bind-index.html', 
          )) 
      }) 
      app.listen( 
          1337, 
          () => console.log('Web Server running on port 1337'), 
      ) 
```

3.  保存文件

接下来，在 HTML 文件中构建待办事项应用程序：

1.  创建一个名为`bind-index.html`的新文件。
2.  添加以下代码：

```
      <!DOCTYPE html> 
      <html lang="en"> 
      <head> 
          <meta charset="UTF-8"> 
          <title>Binding action creators</title> 
          <script 
           src="https://unpkg.com/@babel/standalone/babel.min.js">
          </script> 
          <script src="/lib/redux.js"></script> 
      </head> 
      <body> 
          <h1>List:</h1> 
          <form id="item-form"> 
              <input id="item-input" name="item" /> 
          </form> 
          <ul id="list"></ul> 
          <script type="text/babel"> 
              // Add code here 
          </script> 
      </body> 
      </html> 
```

3.  在脚本标记内，从步骤 4 开始，按以下步骤添加代码。
4.  保留对将在应用程序中使用的 HTML DOM 元素的引用：

```
      const form = document.querySelector('#item-form') 
      const input = document.querySelector('#item-input') 
      const list = document.querySelector('#list') 
```

5.  定义应用程序的初始状态：

```
      const initialState = { 
          items: [], 
      } 
```

6.  定义操作类型：

```
      const TYPE = { 
          ADD_ITEM: 'ADD_ITEM', 
      } 
```

7.  定义操作创建者：

```
      const actions = { 
          addItem: (text) => ({ 
              type: TYPE.ADD_ITEM, 
              text, 
          }) 
      } 
```

8.  定义一个 reducer 函数，每当调度`ADD_ITEM`操作类型时，该函数将向列表中添加一个新项。国家只保留 5 项：

```
      const reducer = (state = initialState, action) => { 
          switch (action.type) { 
              case TYPE.ADD_ITEM: return { 
                  items: [...state.items, action.text].splice(-5) 
              } 
              default: return state 
          } 
      } 
```

9.  创建存储并将`dispatch`函数绑定到动作创建者：

```
      const { createStore, bindActionCreators } = Redux 
      const store = createStore(reducer) 
      const { addItem } = bindActionCreators( 
          actions,  
          store.dispatch, 
      ) 
```

10.  订阅存储，并在状态更改时向列表中添加新项目。如果已定义项，我们将重新使用它，而不是创建新项：

```
      store.subscribe(() => { 
          const { items } = store.getState() 
          items.forEach((itemText, index) => { 
              const li = ( 
                  list.children.item(index) || 
                  document.createElement('li') 
              ) 
              li.textContent = itemText 
              list.insertBefore(li, list.children.item(0)) 
          }) 
      }) 
```

11.  将事件侦听器添加到`submit`事件的表单中。这样，我们可以获得输入值并分派操作：

```
      form.addEventListener('submit', (event) => { 
          event.preventDefault() 
          addItem(input.value) 
      }) 
```

12.  保存文件。

# 让我们测试一下。。。

要查看以前的工作，请执行以下操作：

1.  打开新终端并运行：

```
 node bind-server.js
```

2.  在浏览器中，访问：

```
     http://localhost:1337/
```

3.  在输入框中键入内容，然后按 Enter 键。新项目应出现在列表中。
4.  尝试向列表中添加五个以上的项目。最后一个显示的项目将被删除，视图上只保留五个项目。

# 分解和组合减速器

随着应用程序的增长，您可能不想在一个简单的 reducer 函数中编写应用程序状态转换的所有逻辑。您可能希望编写更小的简化程序，专门管理州的独立部分。

以以下减速器功能为例：

```
const initialState = { 
    todoList: [], 
    chatMsg: [], 
} 
const reducer = (state = initialState, action) => { 
    switch (action.type) { 
        case 'ADD_TODO': return { 
            ...state, 
            todoList: [ 
                ...state.todoList, 
                { 
                    title: action.title, 
                    completed: action.completed, 
                }, 
            ], 
        } 
        case 'ADD_CHAT_MSG': return { 
            ...state, 
            chatMsg: [ 
                ...state.chatMsg, 
                { 
                    from: action.id, 
                    message: action.message, 
                }, 
            ], 
        } 
        default: 
            return state 
    } 
} 
```

您有两个属性来管理应用程序两个不同部分的状态。一个管理待办事项列表的状态，另一个管理聊天信息。您可以将此 reducer 拆分为两个 reducer 函数，其中每个函数管理一个状态片，例如：

```
const initialState = { 
    todoList: [], 
    chatMsg: [], 
} 
const todoListReducer = (state = initialState.todoList, action) => { 
    switch (action.type) { 
        case 'ADD_TODO': return state.concat([ 
            { 
                title: action.title, 
                completed: action.completed, 
            }, 
        ]) 
        default: return state 
    } 
} 
const chatMsgReducer = (state = initialState.chatMsg, action) => { 
    switch (action.type) { 
        case 'ADD_CHAT_MSG': return state.concat([ 
            { 
                from: action.id, 
                message: action.message, 
            }, 
        ]) 
        default: return state 
    } 
} 
```

但是，由于`createStore`方法只接受一个减速器作为第一个参数，因此需要将它们组合成一个减速器：

```
const reducer = (state = initialState, action) => { 
    return { 
        todoList: todoListReducer(state.todoList, action), 
        chatMsg: chatMsgReducer(state.chatMsg, action), 
    } 
} 
```

通过这种方式，我们可以将我们的减缩器拆分成更小的减缩器，专门管理状态的一个部分，然后将它们组合成一个减缩器函数。

Redux 提供了一个名为`combineReducers`的助手方法，允许您以类似于我们刚才所做的方式组合减缩器，但无需重复大量代码；例如，我们可以重写前面的组合减缩器的方法，如下所示：

```
const reducer = combineReducers({ 
    todoList: todoListReducer, 
    chatMsg: chatMsgReducer, 
}) 
```

`combineReducers`方法是*高阶减速机*功能。它接受一个对象映射，指定一个特定的`reducer`函数管理的状态的某个部分的键，并返回一个新的 reducer 函数。例如，如果运行以下代码：

```
console.log(JSON.stringify( 
    reducer(initialState, { type: null }), 
    null, 2, 
)) 
```

您将看到生成的状态形状如下所示：

```
{ 
    "todoList": [], 
    "chatMsg": [], 
} 
```

如果我们的组合减速器只工作并管理分配给它们的部分状态，我们也可以尝试。例如：

```
console.log(JSON.stringify( 
    reducer( 
        initialState, 
        { 
            type: 'ADD_TODO', 
            title: 'This is an example', 
            completed: false, 
        }, 
    ), 
    null, 2, 
)) 
```

输出应显示生成的状态，如下所示：

```
{ 
    "todoList": [ 
        { 
            "title": "This is an example", 
            "completed": false, 
        }, 
    ], 
    "chatMsg": [], 
} 
```

这表明每个 reducer 只管理分配给它们的状态片。

# 准备

在这个配方中，您将重新创建 To do 应用程序，就像之前的配方一样。但是，您将添加其他功能，例如删除和切换待办事项。您将定义应用程序的其他状态，这些状态将由单独的 reducer 函数管理。首先，创建一个包含以下内容的新`package.json`文件：

```
{ 
    "dependencies": { 
        "express": "4.16.3", 
        "redux": "4.0.0" 
    } 
} 
```

然后，通过打开终端并运行以下命令来安装依赖项：

```
npm install
```

# 怎么做。。。

首先，构建一个小型 ExpressJS 服务器应用程序，该应用程序将服务于客户端应用程序和安装在`node_modules`中的 Redux 库：

1.  创建一个名为`todo-time.js`的新文件
2.  添加以下代码：

```
      const express = require('express') 
      const path = require('path') 
      const app = express() 
      app.use('/lib', express.static( 
          path.join(__dirname, 'node_modules', 'redux', 'dist') 
      )) 
      app.get('/', (req, res) => { 
          res.sendFile(path.join( 
              __dirname, 
              'todo-time.html', 
          )) 
      }) 
      app.listen( 
          1337, 
          () => console.log('Web Server running on port 1337'), 
      ) 
```

3.  保存文件

接下来，构建待办客户机应用程序。还包括一个单独的减速机，用于管理当前本地时间的状态，以及一个随机幸运数生成器：

1.  创建一个名为`todo-time.html`的新文件
2.  添加以下 HTML 代码：

```
      <!DOCTYPE html> 
      <html lang="en"> 
      <head> 
         <meta charset="UTF-8"> 
          <title>Lucky Todo</title> 
          <script 
           src="https://unpkg.com/@babel/standalone/babel.min.js">
          </script> 
          <script src="/lib/redux.js"></script> 
      </head> 
      <body> 
          <h1>List:</h1> 
          <form id="item-form"> 
              <input id="item-input" name="item" /> 
          </form> 
          <ul id="list"></ul> 
          <script type="text/babel"> 
              // Add code here 
          </script> 
      </body> 
      </html> 
```

3.  在 script 标记中，从步骤 4 开始，按照下面的步骤添加 JavaScript 代码
4.  保留用于显示数据或与应用程序交互的 HTML 元素的引用：

```
      const timeElem = document.querySelector('#current-time') 
      const formElem = document.querySelector('#todo-form') 
      const listElem = document.querySelector('#todo-list') 
      const inputElem = document.querySelector('#todo-input') 
      const luckyElem = document.querySelector('#lucky-number') 
```

5.  从 Redux 库中获取`createStore`方法和助手方法：

```
      const { 
          createStore, 
          combineReducers, 
          bindActionCreators, 
      } = Redux 
```

6.  设置操作类型：

```
      const TYPE = { 
          SET_TIME: 'SET_TIME', 
          SET_LUCKY_NUMBER: 'SET_LUCKY_NUMBER', 
          ADD_TODO: 'ADD_TODO', 
          REMOVE_TODO: 'REMOVE_TODO', 
          TOGGLE_COMPLETED_TODO: 'TOGGLE_COMPLETED_TODO', 
      } 
```

7.  定义动作创建者：

```
      const actions = { 
          setTime: (time) => ({ 
              type: TYPE.SET_TIME, 
              time, 
          }), 
          setLuckyNumber: (number) => ({ 
              type: TYPE.SET_LUCKY_NUMBER, 
              number, 
          }), 
          addTodo: (id, title) => ({ 
              type: TYPE.ADD_TODO, 
              title, 
              id, 
          }), 
          removeTodo: (id) => ({ 
              type: TYPE.REMOVE_TODO, 
              id, 
          }), 
          toggleTodo: (id) => ({ 
              type: TYPE.TOGGLE_COMPLETED_TODO, 
              id, 
          }), 
      } 
```

8.  定义一个 reducer 函数来管理保持时间的状态片：

```
      const currentTime = (state = null, action) => { 
          switch (action.type) { 
              case TYPE.SET_TIME: return action.time 
              default: return state 
          } 
      } 
```

9.  定义一个 reducer 函数来管理状态片，该状态片保留一个幸运数字，该数字将在用户每次加载应用程序时生成：

```
      const luckyNumber = (state = null, action) => { 
          switch (action.type) { 
              case TYPE.SET_LUCKY_NUMBER: return action.number 
              default: return state 
          } 
      } 
```

10.  定义一个 reducer 函数来管理保留待办事项数组的状态片：

```
      const todoList = (state = [], action) => { 
          switch (action.type) { 
              case TYPE.ADD_TODO: return state.concat([ 
                  { 
                      id: String(action.id), 
                      title: action.title, 
                      completed: false, 
                  } 
              ]) 
              case TYPE.REMOVE_TODO: return state.filter( 
                  todo => todo.id !== action.id 
              ) 
              case TYPE.TOGGLE_COMPLETED_TODO: return state.map( 
                  todo => ( 
                      todo.id === action.id 
                          ? { 
                              ...todo, 
                              completed: !todo.completed, 
                          } 
                          : todo 
                  ) 
              ) 
              default: return state 
          } 
      } 
```

11.  将所有减速器合并为一个减速器：

```
      const reducer = combineReducers({ 
          currentTime, 
          luckyNumber, 
          todoList, 
      }) 
```

12.  创建存储：

```
      const store = createStore(reducer) 
```

13.  将所有动作创建者绑定到商店的`dispatch`方法：

```
      const { 
          setTime, 
          setLuckyNumber, 
          addTodo, 
          removeTodo, 
          toggleTodo, 
      } = bindActionCreators(actions, store.dispatch) 
```

14.  将侦听器订阅到将更新 HTML 元素的存储区，该存储区将在状态更改时保留时间：

```
      store.subscribe(() => { 
          const { currentTime } = store.getState() 
          timeElem.textContent = currentTime 
      }) 
```

15.  将侦听器订阅到将更新 HTML 元素的存储，每当状态发生变化时，该存储将显示一个幸运数字：

```
      store.subscribe(() => { 
          const { luckyNumber } = store.getState() 
          luckyElem.textContent = `Your lucky number is: ${luckyNumber}` 
      }) 
```

16.  订阅一个监听器到存储区，该存储区将在状态发生变化时更新 HTML 元素，该元素将显示待办事项列表。为`li`HTML 元素设置属性`draggable`，以允许用户在视图上拖放项目：

```
      store.subscribe(() => { 
          const { todoList } = store.getState() 
          listElem.innerHTML = '' 
          todoList.forEach(todo => { 
              const li = document.createElement('li') 
              li.textContent = todo.title 
              li.dataset.id = todo.id 
              li.setAttribute('draggable', true) 
              if (todo.completed) { 
                  li.style = 'text-decoration: line-through' 
              } 
              listElem.appendChild(li) 
          }) 
      }) 
```

17.  为列表 HTML 元素上的`click`事件添加一个事件侦听器，每当单击该项时，该事件将切换待办事项的`completed`属性：

```
      listElem.addEventListener('click', (event) => { 
    toggleTodo(event.target.dataset.id) 
      }) 
```

18.  为列表 HTML 元素上的`drag`事件添加一个事件侦听器，当该事件拖到列表之外时，该事件将删除待办事项：

```
      listElem.addEventListener('drag', (event) => { 
          removeTodo(event.target.dataset.id) 
      }) 
```

19.  在包含输入 HTML 元素的表单上为`submit`事件添加事件侦听器，该元素将发送新操作以添加新的待办事项：

```
      let id = 0 
      formElem.addEventListener('submit', (event) => { 
          event.preventDefault() 
          addTodo(++id, inputElem.value) 
          inputElem.value = '' 
      }) 
```

20.  当页面第一次加载时，调度一个操作以设置幸运数字，并定义一个每秒触发一次的函数，以更新应用程序状态下的当前时间：

```
      setLuckyNumber(Math.ceil(Math.random() * 1024)) 
      setInterval(() => { 
          setTime(new Date().toTimeString()) 
      }, 1000) 
```

21.  保存文件

# 让我们测试一下。。。

要查看以前的工作，请执行以下操作：

1.  打开新终端并运行：

```
 node todo-time.js
```

2.  在浏览器中，访问：

```
      http://localhost:1337/
```

3.  在输入框中输入内容，然后按 enter 键。新项目应出现在列表中。
4.  单击已添加的项目之一，将其标记为已完成。
5.  再次单击标记为已完成的项目之一，将其标记为未完成。
6.  单击并拖动列表外的一个项目，将其从待办事项列表中删除。

# 它是如何工作的。。。

1.  定义了三个 reducer 函数来独立管理具有以下形状的状态的每个片段：

```
      { 
          currentTime: String, 
          luckyNumber: Number, 
          todoList: Array.of({ 
              id: Number, 
              title: String, 
              completed: Boolean, 
          }), 
      } 
```

2.  我们使用 Redux 库中的`combineReducers`helper 方法将这三个减速器组合成一个减速器
3.  然后，创建了一个提供组合减速器功能的存储
4.  为了方便起见，我们订阅了三个侦听器函数，每当状态发生变化时就会触发这些函数，以更新用于显示状态数据的 HTML 元素
5.  我们还定义了三个事件侦听器：一个用于检测用户何时提交包含输入 HTML 元素的表单以添加新的待办事项，另一个用于检测用户何时单击屏幕上显示的待办事项以将其状态从“未完成”切换到“已完成”，反之亦然，最后是一个事件监听器，用于检测用户何时从列表中拖动一个元素以分派一个操作以将其从待办事项列表中删除

# 编写 Redux 存储增强器

Redux store enhancer 是一个高阶函数，它接受 store creator 函数并返回一个新的增强 store creator 函数。`createStore`方法是具有以下签名的店铺创建者：

```
createStore = (reducer, preloadedState, enhancer) => Store 
```

而存储增强函数具有以下特征：

```
enhancer = (...optionalArguments) => ( 
createStore => (reducer, preloadedState, enhancer) => Store 
) 
```

现在看起来可能有点难以理解，但如果一开始没有得到它，您不必担心，因为您可能永远都不需要编写商店增强器。这个食谱的目的只是帮助你以一种非常简单的方式理解它们的用途。

# 准备

在此配方中，您将创建一个存储增强器，通过允许在`Map`JavaScript 本机对象中定义 reducer 函数来扩展 Redux 的功能。首先，创建一个包含以下内容的新`package.json`文件：

```
{ 
    "dependencies": { 
        "redux": "4.0.0" 
    } 
} 
```

然后，通过打开终端并运行以下命令来安装依赖项：

```
 npm install
```

# 怎么做。。。

请记住，`createStore`接受单个 reducer 函数作为第一个参数。我们编写了一个存储增强器，允许`createStore`方法接受一个包含键值对的`Map`对象，其中 key 是要管理的属性或状态片，value 是一个`reducer`函数。然后，使用`Map`对象定义两个 reducer 函数来处理两个状态片，一个用于计数器，另一个用于设置当前时间：

1.  创建一个名为`map-store.js`的新文件。
2.  包括 Redux 库：

```
      const { 
          createStore, 
          combineReducers, 
          bindActionCreators, 
      } = require('redux') 
```

3.  定义一个存储增强器函数，该函数将允许`createStore`方法接受`Map`对象作为参数。它将遍历`Map`的每个键值对，并将其添加到一个对象中，然后该对象将用于使用`combineReducers`方法组合减速器：

```
      const acceptMap = () => createStore => ( 
          (reducerMap, ...rest) => { 
              const reducerList = {} 
              for (const [key, val] of reducerMap) { 
                  reducerList[key] = val 
              } 
              return createStore( 
                  combineReducers(reducerList), 
                  ...rest, 
              ) 
          } 
      ) 
```

4.  定义操作类型：

```
      const TYPE = { 
          INC_COUNTER: 'INC_COUNTER', 
          DEC_COUNTER: 'DEC_COUNTER', 
          SET_TIME: 'SET_TIME', 
      } 
```

5.  定义操作创建者：

```
      const actions = { 
          incrementCounter: (incBy) => ({ 
              type: TYPE.INC_COUNTER, 
              incBy, 
          }), 
          decrementCounter: (decBy) => ({ 
              type: TYPE.DEC_COUNTER, 
              decBy, 
          }), 
          setTime: (time) => ({ 
              type: TYPE.SET_TIME, 
              time, 
          }), 
      } 
```

6.  定义一个包含`Map`实例的`map`常量：

```
      const map = new Map() 
```

7.  使用`counter`键向`map`对象添加新的减速器功能：

```
      map.set('counter', (state = 0, action) => { 
          switch (action.type) { 
              case TYPE.INC_COUNTER: return state + action.incBy 
              case TYPE.DEC_COUNTER: return state - action.decBy 
              default: return state 
          } 
      }) 
```

8.  使用`time`键为`map`对象添加另一个减速器功能：

```
      map.set('time', (state = null, action) => { 
          switch (action.type) { 
              case TYPE.SET_TIME: return action.time 
              default: return state 
          } 
      }) 
```

9.  创建一个新的存储区，提供`map`作为第一个参数，**存储区增强器**作为第二个参数，以扩展`createStore`方法的功能：

```
      const store = createStore(map, acceptMap()) 
```

10.  将先前定义的动作创建者绑定到存储的`dispatch`方法：

```
      const { 
          incrementCounter, 
          decrementCounter, 
          setTime, 
      } = bindActionCreators(actions, store.dispatch) 
```

11.  要在 NodeJS 中测试代码，请使用`setInterval`全局方法每秒重复调用一个函数。它将首先调度一个操作来设置当前时间，然后根据条件决定是递增还是递减计数器。之后，在终端中打印存储的当前值：

```
      setInterval(function() { 
          setTime(new Date().toTimeString()) 
          if (this.shouldIncrement) { 
              incrementCounter((Math.random() * 5) + 1 | 0) 
          } else { 
              decrementCounter((Math.random() * 5) + 1 | 0) 
          } 
          console.dir( 
              store.getState(), 
              { colors: true, compact: false }, 
          ) 
          this.shouldIncrement = !this.shouldIncrement 
      }.bind({ shouldIncrement: false }), 1000) 
```

12.  保存文件。
13.  打开新终端并运行：

```
 node map-store.js
```

14.  当前状态将每秒显示一次，具有以下形状：

```
      { 
          "counter": Number, 
          "time": String, 
      } 
```

# 它是如何工作的。。。

增强器将商店创建者合成为一个新的。例如，以下行：

```
const store = createStore(map, acceptMap()) 
```

可以写成：

```
const store = acceptMap()(createStore)(map) 
```

实际上，在某种程度上，它将原来的`createStore`方法包装成了另一个`createStore`方法。

组合可以解释为一组函数，这些函数被称为接受前一个函数的结果参数。例如：

```
const c = (...args) => f(g(h(...args))) 
```

这将从右到左将功能`f`、`g`和`h`组合为单个功能`c`。也就是说，我们可以像这样编写前一行代码：

```
const _createStore = acceptMap()(createStore) 
const store = _createStore(map) 
```

这里的`_createStore`是合成`createStore`和您的存储增强功能的结果。

# 时间旅行与 Redux

尽管您可能永远不需要编写存储增强器，但有一个特别的功能，您可能会发现它非常有用，可用于调试支持 Redux 的应用程序，使其在应用程序的状态中进行时间旅行。您只需安装**Redux DevTools 扩展**（适用于 Chrome 和 Firefox）：[即可在应用程序上实现时间旅行 https://github.com/zalmoxisus/redux-devtools-extension](https://github.com/zalmoxisus/redux-devtools-extension) 。

# 准备

在此配方中，我们将看到一个示例，说明如何利用此功能，并分析应用程序的状态在浏览器上运行的时间内是如何变化的。首先，创建一个包含以下内容的新`package.json`文件：

```
{ 
    "dependencies": { 
        "express": "4.16.3", 
        "redux": "4.0.0" 
    } 
} 
```

然后，通过打开终端并运行以下命令来安装依赖项：

```
npm install 
```

确保已在 web 浏览器中安装了 Redux DevTools 扩展。

# 怎么做。。。

构建一个计数器应用程序，当应用程序在浏览器上运行时，该应用程序将随机递增或递减初始指定计数器 10 次。但是，由于它发生得很快，用户将无法注意到自应用程序启动以来，状态实际上已经更改了 10 次。我们将使用 Redux DevTools 扩展来导航和分析状态随时间的变化。

首先，构建一个小型 ExpressJS 服务器应用程序，该应用程序将服务于客户端应用程序和安装在`node_modules`中的 Redux 库：

1.  创建一个名为`time-travel.js`的新文件
2.  添加以下代码：

```
      const express = require('express') 
      const path = require('path') 
      const app = express() 
      app.use('/lib', express.static( 
          path.join(__dirname, 'node_modules', 'redux', 'dist') 
      )) 
      app.get('/', (req, res) => { 
          res.sendFile(path.join( 
              __dirname, 
              'time-travel.html', 
          )) 
      }) 
      app.listen( 
          1337, 
          () => console.log('Web Server running on port 1337'), 
      ) 
```

3.  保存文件

接下来，构建计数器、Redux 驱动的应用程序，并具有时间旅行功能：

1.  创建一个名为`time-travel.html`的新文件
2.  添加以下 HTML 代码：

```
      <!DOCTYPE html> 
      <html lang="en"> 
      <head> 
          <meta charset="UTF-8"> 
          <title>Time travel</title> 
          <script 
           src="https://unpkg.com/@babel/standalone/babel.min.js">
          </script> 
          <script src="/lib/redux.js"></script> 
      </head> 
      <body> 
          <h1>Counter: <span id="counter"></span></h1> 
          <script type="text/babel"> 
              // Add JavaScript Code here 
          </script> 
      </body> 
      </html> 
```

3.  在 script 标记中添加 JavaScript 代码，从步骤 4 开始，遵循接下来的步骤
4.  保留对`span`HTML 元素的引用，该元素将在状态更改时显示计数器的当前值：

```
      const counterElem = document.querySelector('#counter') 
```

5.  从 Redux 库中获取`createStore`方法和`bindActionCreators`方法：

```
      const { 
          createStore, 
          bindActionCreators, 
      } = Redux 
```

6.  定义两种操作类型：

```
      const TYPE = { 
          INC_COUNTER: 'INC_COUNTER', 
          DEC_COUNTER: 'DEC_COUNTER', 
      } 
```

7.  定义两个动作创建者：

```
      const actions = { 
          incCounter: (by) => ({ type: TYPE.INC_COUNTER, by }), 
          decCounter: (by) => ({ type: TYPE.DEC_COUNTER, by }), 
      } 
```

8.  定义一个 reducer 函数，该函数将根据给定的操作类型转换状态：

```
      const reducer = (state = { value: 5 }, action) => { 
          switch (action.type) { 
              case TYPE.INC_COUNTER: 
                  return { value: state.value + action.by } 
              case TYPE.DEC_COUNTER: 
                  return { value: state.value - action.by } 
              default: 
                  return state 
          } 
      } 
```

9.  创建一个新的存储，提供在安装 Redux DevTools 扩展时在`window`对象上可用的存储增强功能：

```
      const store = createStore( 
          reducer, 
          ( 
              window.__REDUX_DEVTOOLS_EXTENSION__ && 
              window.__REDUX_DEVTOOLS_EXTENSION__() 
          ), 
      ) 
```

10.  将动作创建者绑定到商店的`dispatch`方法：

```
      const { 
          incCounter, 
          decCounter, 
      } = bindActionCreators(actions, store.dispatch) 
```

11.  向存储订阅侦听器函数，该函数将在状态更改时更新`span`HTML 元素：

```
      store.subscribe(() => { 
          const state = store.getState() 
          counterElem.textContent = state.value 
      }) 
```

12.  让我们创建一个`for`循环，当应用程序运行时，该循环将随机递增或递减计数器 10 次：

```
      for (let i = 0; i < 10; i++) { 
          const incORdec = (Math.random() * 10) > 5 
          if (incORdec) incCounter(2) 
          else decCounter(1) 
      } 
```

13.  保存文件

# 让我们测试一下。。。

要查看以前的工作，请执行以下操作：

1.  打开新终端并运行：

```
 node todo-time.js
```

2.  在浏览器中，访问：

```
      http://localhost:1337/
```

3.  打开浏览器的开发人员工具并查找 Redux 选项卡。您应该看到如下选项卡：

![](Images/d6635f01-f201-44b1-91ba-76ee735152da.png)

Redux DevTools – Tab Window

4.  滑块允许您从应用程序的最后一个状态移动到第一个状态。尝试将滑块移动到其他位置：

![](Images/64146aed-2c98-42af-bfef-96fa08b2d098.png)

Redux DevTools – Moving Slider

5.  移动滑块时，您将能够在浏览器中看到计数器的初始值，以及它如何在 for 循环中更改这十次

# 还有更多

**Redux DevTools**具有一些功能，您可能会发现这些功能对于调试和管理应用程序的状态非常有用。事实上，如果您遵循前面的方法，我建议您回到我们编写的项目，启用此增强程序，并尝试使用 Redux 开发工具进行实验。

Redux DevTools 的许多功能之一是日志监视器，它按时间顺序显示已调度的操作以及转换状态的结果值：

![](Images/c1d3b8a0-3d7d-4f30-80a0-1c660b506e43.png)

Redux DevTools – Log Monitor

# 理解 Redux 中间件

扩展 Redux 功能的最简单和最好的方法可能是使用中间件。

Redux 库中有一个名为`applyMiddleware`的 store enhancer 函数，允许您定义一个或多个中间件函数。中间件在 Redux 中的工作方式很简单，它允许您包装存储的`dispatch`方法以扩展其功能。与存储增强功能相同，中间件是可组合的，并具有以下特征：

```
middleware = API => next => action => next(action) 
```

这里，`API`是一个对象，包含来自存储的`dispatch`和`getState`方法，对`API`进行解构，签名如下：

```
middleware = ({ 
    getState, 
    dispatch, 
}) => next => action => next(action)  
```

让我们分析一下它是如何工作的：

1.  `applyMiddleware`函数接收一个或多个中间件函数作为参数。例如：

```
      applyMiddleware(middleware1, middleware2) 
```

2.  每个中间件功能在内部保留为一个`Array`。然后，在内部使用`Array.prototype.map`方法，数组通过调用自身提供中间件`API`对象来映射每个中间件功能，该对象包含存储的`dispatch`和`getState`方法。与此类似：

```
      middlewares.map((middleware) => middleware(API)) 
```

3.  然后，通过组合所有中间件函数，它为提供`next`参数的`dispatch`方法计算一个新值。在执行的第一个中间件中，`next`参数引用应用任何中间件之前的原始`dispatch`方法。例如，如果应用三个中间件功能，新的计算分派方法的签名将是：

```
      dispatch = (action) => ( 
          (action) => ( 
              (action) => store.dispatch(action) 
          )(action) 
      )(action) 
```

4.  这意味着，如果不调用`next(action)`方法，中间件功能可以中断该链并阻止某个动作被调度
5.  中间件`API`对象中的 dispatch 方法允许您使用先前应用的中间件调用存储的 dispatch 方法。这意味着，如果在使用此方法时不小心，可能会创建一个无限循环

了解它的内部工作原理一开始可能不是那么简单，但我向您保证，您很快就会得到它。

# 准备

在此配方中，您将编写一个中间件函数，在分派尚未定义的操作类型时向用户发出警告。首先，创建一个包含以下内容的新`package.json`文件：

```
{ 
    "dependencies": { 
        "redux": "4.0.0" 
    } 
} 
```

然后，通过打开终端并运行以下命令来安装依赖项：

```
npm install
```

# 怎么做。。。

当使用还原程序中从未定义的操作类型时，Redux 不会警告您或显示错误。构建将使用 Redux 管理其状态的 NodeJS 应用程序。重点是编写一个中间件函数，该函数将检查是否定义了已调度的操作类型，或者抛出错误：

1.  创建一个名为`type-check-redux.js`的新文件。
2.  包括 Redux 库：

```
      const { 
          createStore, 
          applyMiddleware, 
      } = require('redux') 
```

3.  定义包含允许的操作类型的对象：

```
      const TYPE = { 
          INCREMENT: 'INCREMENT', 
          DECREMENT: 'DECREMENT', 
          SET_TIME: 'SET_TIME', 
      } 
```

4.  创建一个伪 reducer 函数，该函数返回其原始状态（无论调用哪种操作类型）。我们不需要它来制作这个配方：

```
      const reducer = ( 
          state = null, 
          action, 
      ) => state 
```

5.  定义一个中间件函数，该函数将拦截正在调度的每个动作，并检查`TYPE`对象中是否存在该动作类型。如果该操作存在，请允许调度该操作，否则，抛出错误并通知用户调度了无效的操作类型。此外，作为错误消息的一部分，让我们向用户提供有关允许哪些有效类型的信息：

```
      const typeCheckMiddleware = api => next => action => { 
          if (Reflect.has(TYPE, action.type)) { 
              next(action) 
          } else { 
              const err = new Error( 
                  `Type "${action.type}" is not a valid` + 
                  `action type. ` + 
                  `did you mean to use one of the following` + 
                  `valid types? ` + 
                  `"${Reflect.ownKeys(TYPE).join('"|"')}"n`, 
              ) 
              throw err 
          } 
      } 
```

6.  创建存储并应用定义的中间件功能：

```
      const store = createStore( 
          reducer, 
          applyMiddleware(typeCheckMiddleware), 
      ) 
```

7.  分派两种操作类型。第一个动作类型有效，存在于`TYPE`对象中。但是，第二种是从未定义过的动作类型：

```
      store.dispatch({ type: 'INCREMENT' }) 
      store.dispatch({ type: 'MISTAKE' }) 
```

8.  保存文件。

# 让我们测试一下。。。

首先，打开一个新终端并运行：

```
    node type-check-redux.js 
```

终端输出应显示类似以下内容的错误：

```
/type-check-redux.js:25 
                throw err 
                ^ 
Error: Type "MISTAKE" is not a valid action type. did you mean to use one of the following valid types? "INCREMENT"|"DECREMENT"|"SET_TIME" 
    at Object.action [as dispatch] (/type-check-redux.js:18:15) 
    at Object.<anonymous> (/type-check-redux.js:33:7) 
```

在本例中，堆栈跟踪告诉我们错误发生在第`18`行，该行指向我们的中间件功能。但是，下一行指向第`33`、`store.dispatch({ type: 'MISTAKE' })`行，这是一件好事，因为它可以帮助您精确跟踪从未定义过的某些操作的调度位置。

# 它是如何工作的。。。

这非常简单，中间件函数检查被调度的动作的动作类型，看看它是否作为`TYPE`对象常量的属性存在。如果存在，则中间件将控制权传递给链中的下一个中间件。但是，在我们的例子中，没有下一个中间件，因此控制权被传递到存储区的原始调度方法，该方法将应用 reducer 并转换状态。另一方面，如果没有定义动作类型，中间件函数会通过不调用`next`函数和抛出错误来中断中间件链。

# 处理异步数据流

默认情况下，Redux 不处理异步数据流。有几个库可以帮助您完成这些任务。然而，在本章中，我们将使用中间件功能构建自己的实现，以使`dispatch`方法能够调度和处理异步数据流。

# 准备

在此配方中，您将使用非常小的 API 构建一个 ExpressJS 应用程序，以在发出 HTTP 请求和处理异步数据流和错误时测试您的应用程序。首先，创建一个包含以下内容的新`package.json`文件：

```
{ 
    "dependencies": { 
        "express": "4.16.3", 
        "node-fetch": "2.1.2", 
        "redux": "4.0.0" 
    } 
} 
```

然后通过打开终端并运行以下命令来安装依赖项：

```
npm install  
```

# 怎么做。。。

构建一个简单的 RESTful API 服务器，当发出 GET 请求时，该服务器将有两个端点或路径`/time`和`/date`的应答。然而，在`/date`路径上，我们将假装存在内部错误并使请求失败，以便了解如何处理异步请求中的错误：

1.  创建一个名为`api-server.js`的新文件
2.  包括 ExpressJS 库并初始化新的 ExpressJS 应用程序：

```
      const express = require('express') 
      const app = express() 
```

3.  对于`/time`路径，在发送响应之前模拟`2s`的延迟：

```
      app.get('/time', (req, res) => { 
          setTimeout(() => { 
              res.send(new Date().toTimeString()) 
          }, 2000) 
      }) 
```

4.  对于`/date`路径，在发送失败响应之前模拟`2s`的延迟：

```
      app.get('/date', (req, res) => { 
          setTimeout(() => { 
              res.destroy(new Error('Internal Server Error')) 
          }, 2000) 
      }) 
```

5.  在端口`1337`上侦听新连接

```
      app.listen( 
          1337, 
          () => console.log('API server running on port 1337'), 
      ) 
```

6.  保存文件

对于客户端，使用 Redux 构建一个 NodeJS 应用程序，该应用程序将调度同步和异步操作。编写中间件函数以允许分派方法处理异步操作：

1.  创建一个名为`async-redux.js`的新文件
2.  包括`node-fetch`和 Redux 库：

```
      const fetch = require('node-fetch') 
      const { 
          createStore, 
          applyMiddleware, 
          combineReducers, 
          bindActionCreators, 
      } = require('redux') 
```

3.  定义三种状态。每个状态表示异步操作的状态：

```
      const STATUS = { 
          PENDING: 'PENDING', 
          RESOLVED: 'RESOLVED', 
          REJECTED: 'REJECTED', 
      } 
```

4.  定义两种操作类型：

```
      const TYPE = { 
          FETCH_TIME: 'FETCH_TIME', 
          FETCH_DATE: 'FETCH_DATE', 
      } 
```

5.  定义动作创建者。请注意，value 属性在前两个动作创建者中是一个异步函数。您稍后定义的中间件功能将负责使 Redux 了解以下操作：

```
      const actions = { 
          fetchTime: () => ({ 
              type: TYPE.FETCH_TIME, 
              value: async () => { 
                  const time = await fetch( 
                      'http://localhost:1337/time' 
                  ).then((res) => res.text()) 
                  return time 
              } 
          }), 
          fetchDate: () => ({ 
              type: TYPE.FETCH_DATE, 
              value: async () => { 
                  const date = await fetch( 
                      'http://localhost:1337/date' 
                  ).then((res) => res.text()) 
                  return date 
              } 
          }), 
          setTime: (time) => ({ 
              type: TYPE.FETCH_TIME, 
              value: time, 
          }) 
      } 
```

6.  定义一个公共函数，用于设置将在减速器中使用的动作对象的值：

```
      const setValue = (prevState, action) => ({ 
          ...prevState, 
          value: action.value || null, 
          error: action.error || null, 
          status: action.status || STATUS.RESOLVED, 
      }) 
```

7.  定义应用程序的初始状态：

```
      const iniState = { 
          time: { 
              value: null, 
              error: null, 
              status: STATUS.RESOLVED, 
          }, 
          date: { 
              value: null, 
              error: null, 
              status: STATUS.RESOLVED, 
          } 
      } 
```

8.  定义一个 reducer 函数。请注意，只有一个 reducer 处理两个状态片，`time`和`date`：

```
      const timeReducer = (state = iniState, action) => { 
          switch (action.type) { 
              case TYPE.FETCH_TIME: return { 
                  ...state, 
                  time: setValue(state.time, action) 
              } 
              case TYPE.FETCH_DATE: return { 
                  ...state, 
                  date: setValue(state.date, action) 
              } 
              default: return state 
          } 
      } 
```

9.  定义一个中间件函数，该函数将检查分派的操作类型是否具有作为`value`属性的函数。如果是这样，那么假设`value`属性是一个异步函数。首先，我们发送一个操作，将状态设置为`PENDING`。然后，当异步函数被解析时，我们调度另一个操作将状态设置为`RESOLVED`或在出现错误时设置为`REJECTED`：

```
      const allowAsync = ({ dispatch }) => next => action => { 
          if (typeof action.value === 'function') { 
              dispatch({ 
                  type: action.type, 
                  status: STATUS.PENDING, 
              }) 
              const promise = Promise 
                  .resolve(action.value()) 
                  .then((value) => dispatch({ 
                      type: action.type, 
                      status: STATUS.RESOLVED, 
                      value, 
                  })) 
                        .catch((error) => dispatch({ 
                      type: action.type, 
                      status: STATUS.REJECTED, 
                      error: error.message, 
                  })) 
              return promise 
          } 
          return next(action) 
      } 
```

10.  创建一个新的存储并应用您定义的中间件功能来扩展`dispatch`方法的功能：

```
      const store = createStore( 
          timeReducer, 
          applyMiddleware( 
              allowAsync, 
          ), 
      ) 
```

11.  将动作创建者绑定到存储的`dispatch`方法：

```
      const { 
          setTime, 
          fetchTime, 
          fetchDate, 
      } = bindActionCreators(actions, store.dispatch) 
```

12.  每次状态发生变化时，将函数侦听器订阅到存储并在终端状态树中显示为 JSON 字符串：

```
      store.subscribe(() => { 
          console.log('x1b[1;34m%sx1b[0m', 'State has changed') 
          console.dir( 
              store.getState(), 
              { colors: true, compact: false }, 
          ) 
      }) 
```

13.  调度同步操作以设置时间：

```
      setTime(new Date().toTimeString()) 
```

14.  调度异步操作以获取和设置时间：

```
      fetchTime() 
```

15.  分派另一个异步操作以获取并尝试设置日期。请记住，此操作应该失败，并且是故意的：

```
      fetchDate() 
```

16.  保存文件。

# 让我们测试一下。。。

要查看您以前的工作，请执行以下操作：

1.  打开新终端并运行：

```
 node api-server.js
```

2.  在不关闭以前运行的 NodeJS 进程的情况下，打开另一个终端并运行：

```
 node async-redux.js
```

# 它是如何工作的。。。

1.  每次状态发生变化时，subscribed listener 函数都会在终端中漂亮地打印当前状态树
2.  第一个调度的操作是同步的。它将导致状态树的时间片更新如下，例如：

```
      time: { 
          value: "01:02:03 GMT+0000", 
          error: null, 
          status: "RESOLVED" 
      } 
```

3.  正在调度的第二个操作是异步的。在内部，调度两个操作以反映异步操作的状态，一个在异步函数仍在执行时，另一个在异步函数完成时：

```
      time: { 
          value: null, 
          error: null, 
          status: "PENDING" 
      } 
      // Later, once the operation is fulfilled: 
      time: { 
          value: "01:02:03 GMT+0000", 
          error: null, 
          status: "RESOLVED" 
      } 
```

4.  正在调度的第三个操作也是异步的。在内部，它还导致调度两个操作以反映异步操作的状态：

```
      date: { 
          value: null, 
          error: null, 
          status: "PENDING" 
      } 
      // Later, once the operation is fulfilled: 
      date: { 
          value: null, 
          error: "request to http://localhost:1337/date failed, reason:   
             socket hang up", 
          status: "REJECTED" 
      } 
```

5.  考虑到由于操作是异步的，终端中显示的输出可能并不总是以相同的顺序
6.  请注意，第一个异步操作已完成，状态标记为`RESOLVED`，而第二个异步操作已完成，状态标记为`REJECTED`
7.  状态`PENDING`、`RESOLVED`和`REJECTED`反映了 JavaScript 承诺可以是的三种状态，它们不是必须的名称，只是很容易记住

# 还有更多。。。

如果您不想编写自己的中间件函数或存储增强器来处理异步操作，可以选择使用现有的许多 Redux 库中的一个。最常用或最流行的两种是：

*   重击——[https://github.com/gaearon/redux-thunk](https://github.com/gaearon/redux-thunk)
*   雷杜传奇——[https://github.com/redux-saga/redux-saga](https://github.com/redux-saga/redux-saga)