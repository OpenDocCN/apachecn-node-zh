# 构建 RESTful API

在本章中，我们将介绍以下配方：

*   使用 ExpressJS 的路由方法执行 CRUD 操作
*   猫鼬积垢作业
*   使用 Mongoose 查询生成器
*   定义文档实例方法
*   定义静态模型方法
*   为 Mongoose 编写中间件函数
*   为 Mongoose 的模式编写自定义验证器
*   使用 ExpressJS 和 Mongoose 构建 RESTful API 来管理用户

# 技术要求

您需要具有 IDE、Visual Studio 代码、Node.js 和 MongoDB。您还需要安装 Git，以便使用本书的 Git 存储库。

本章代码文件可在 GitHub 上找到：
[https://github.com/PacktPublishing/MERN-Quick-Start-Guide/tree/master/Chapter03](https://github.com/PacktPublishing/MERN-Quick-Start-Guide/tree/master/Chapter03)

查看以下视频以查看代码的运行：
[https://goo.gl/73dE6u](https://goo.gl/73dE6u)

# 介绍

**表示状态转移**（**REST**）是 web 构建的一种架构风格。更具体地说，HTTP 1.1 协议标准是使用 REST 原则构建的。REST 提供了资源的表示。**URL**（**统一资源定位器**用于定义资源的位置，并告知浏览器资源的位置。

RESTful API 是遵循这种体系结构风格的 web 服务 API。

最常用的 HTTP 动词或方法是：`POST, GET, PUT,`和`DELETE`。这些方法是持久存储的基础，称为**CRUD**操作（**创建、读取、更新和删除**。

在本章中，菜谱将重点介绍如何通过 ExpressJS 和 Mongoose 使用 REST 架构风格构建 restfulapi。

# 使用 ExpressJS 的路由方法执行 CRUD 操作

ExpressJS 的路由具有处理 HTTP 方法的等效方法。也就是说，HTTP 方法`POST`、`GET`、`PUT`、`DELETE`可以通过以下代码进行处理：

```js
      /* Add a new user */ 
      app.post('/users', (request, response, next) => { }) 
      /* Get user */ 
      app.get('/users/:id', (request, response, next) => { }) 
      /* Update a user */ 
      app.put('/users/:id', (request, response, next) => { }) 
      /* Delete a user */ 
      app.delete('/users/:id', (request, response, next) => { })  
```

把每个 URL 都看作一个名词是很好的，正因为如此，一个动词可以对它起作用。事实上，HTTP 方法也称为 HTTP 谓词。如果我们将它们视为动词，那么当对 RESTful API 发出请求时，它们可以理解为：

*   发布用户
*   获取用户
*   更新用户
*   删除用户。

在**MVC**（**模型视图控制器**架构模式中，控制器负责将输入转换为模型或视图可以理解的内容。换句话说，它们将输入转换为动作或命令，并将其发送到模型或视图进行相应更新。

ExpressJS 的路由方法通常充当控制器。他们只是从客户端获取输入，例如从浏览器获取请求，然后将输入转换为操作。然后，这些操作被发送到模型（即应用程序的业务逻辑，例如 mongoose 模型）或视图（ReactJS 客户端应用程序）进行更新。

# 准备

请记住，我们可以使用 HTTP 方法在资源上调用操作，我们将看到如何基于这些概念构建 RESTful API web 服务。开始之前，请使用以下代码创建一个新的`package.json`文件：

```js
      { 
        "dependencies": { 
          "express": "4.16.3", 
          "node-fetch": "2.1.1", 
          "uuid": "3.2.1" 
        } 
      } 
```

然后，通过打开终端并运行以下代码行来安装依赖项：

```js
 npm install
```

# 怎么做。。。

使用内存中的数据库或包含用户列表的对象数组构建 RESTful API。我们将允许使用 HTTP 方法的 CRUD 操作添加新用户、获取用户或用户列表、更新用户数据和删除用户：

1.  创建一个名为`restfulapi.js`的新文件
2.  导入我们需要的包并创建 ExpressJS 应用程序：

```js
     const express = require('express') 
      const uuid = require('uuid') 
      const app = express() 
```

3.  定义内存中数据库：

```js
      let data = [ 
          { id: uuid(), name: 'Bob' }, 
          { id: uuid(), name: 'Alice' }, 
      ] 
```

4.  创建一个包含 CRUD 操作函数的模型：

```js
      const usr = { 
          create(name) { 
              const user = { id: uuid(), name } 
              data.push(user) 
              return user 
          }, 
          read(id) { 
              if (id === 'all') return data 
              return data.find(user => user.id === id) 
          }, 
          update(id, name) { 
              const user = data.find(usr => usr.id === id) 
              if (!user) return { status: 'User not found' } 
              user.name = name 
              return user 
          }, 
          delete(id) { 
              data = data.filter(user => user.id !== id) 
              return { status: 'deleted', id } 
          } 
      } 
```

5.  为将用作`Create`操作的`post`方法添加请求处理程序。新用户将添加到`data`阵列中：

```js
      app.post('/users/:name', (req, res) => { 
          res.status(201).json(usr.create(req.params.name)) 
      }) 
```

6.  为将用作`Read`或`Retrieve`操作的`get`方法添加请求处理程序。如果给出了一个`id`，则在`data`数组中查找该用户。但是，如果给定的`id`为`"all"`，则会返回整个用户列表：

```js
      app.get('/users/:id', (req, res) => { 
          res.status(200).json(usr.read(req.params.id)) 
      }) 
```

7.  为将用作`Update`操作的`put`方法添加请求处理程序。为了更新`data`阵列中的特定用户，需要提供`id`：

```js
      app.put('/users/:id=:name', (req, res) => { 
          res.status(200).json(usr.update( 
              req.params.id, 
              req.params.name, 
          )) 
      }) 
```

8.  为将用作`Delete`操作的`delete`方法添加请求处理程序。它将在`data`数组中查找用户并将其删除：

```js
      app.delete('/users/:id', (req, res) => { 
          res.status(200).json(usr.delete(req.params.id)) 
      }) 
```

9.  启动应用程序，在端口`1337`上侦听新连接：

```js
      app.listen( 
          1337, 
          () => console.log('Web Server running on port 1337'), 
      ) 
```

10.  保存文件。
11.  打开终端并运行以下代码：

```js
 node restfulapi.js
```

# 让我们测试一下。。。

为了简单起见，创建一个脚本，在 RESTful API 服务器上请求并执行 CRUD 操作：

1.  创建一个名为`test-restfulapi.js`的新文件。
2.  添加以下代码：

```js
      const fetch = require('node-fetch') 
      const r = async (url, method) => ( 
          await fetch(`http://localhost:1337${url}`, { method }) 
              .then(r => r.json()) 
      ) 
      const log = (...obj) => ( 
          obj.forEach(o => console.dir(o, { colors: true })) 
      ) 
      async function test() { 
          const users = await r('/users/all', 'get') 
          const { id } = users[0] 
          const getById = await r(`/users/${id}`, 'get') 
          const updateById = await r(`/users/${id}=John`, 'put') 
          const deleteById = await r(`/users/${id}`, 'delete') 
          const addUsr = await r(`/users/Smith`, 'post') 
          const getAll = await r('/users/all', 'get') 
          log('[GET] users:', users) 
          log(`[GET] a user with id="${id}":`, getById) 
          log(`[PUT] a user with id="${id}":`, updateById) 
          log(`[POST] a new user:`, addUsr) 
          log(`[DELETE] a user with id="${id}":`, deleteById) 
          log(`[GET] users:`, getAll) 
      } 
      test() 
```

3.  保存文件。
4.  打开新终端并运行以下代码：

```js
    node test-restfulapi.js

```

# 它是如何工作的。。。

我们的 RESTful API 应用程序将在端口`1337`上本地运行。当运行测试代码时，它将连接到它并使用不同的 HTTP 方法发出多个请求，以创建用户、检索用户、更新用户和删除用户。所有操作都将记录在终端中。

如果您愿意自己测试，可以替换`test`函数中的所有代码，并使用`r`函数进行定制请求。例如，要创建一个名为`Smith`的新用户：

```js
r(`/users/Smith`, 'post') 
```

# 猫鼬积垢作业

开发人员选择使用 Mongoose 而不是 Node.js 的官方 MongoDB 驱动程序的众多原因之一是，它允许您通过使用模式轻松创建数据结构，而且还因为内置的验证。MongoDB 是一个面向文档的数据库，这意味着文档的结构各不相同。

在 MVC 架构模式中，Mongoose 通常用于创建塑造或定义数据结构的模型。

这就是典型猫鼬模式的定义方式，然后将其编译为模型：

```js
      const PersonSchema = new Schema({ 
          firstName: String, 
          lastName: String, 
      }) 
      const Person = connection.model('Person', PersonSchema) 
```

Model names should be in singular since Mongoose will make them plural and lowercase them when saving the collection to the database. For instance, if the model is named "User", it will be saved as a collection named "users" in MongoDB. Mongoose includes an internal dictionary to pluralize common names. That means if your model's name is a common name, such as "Person", it will be saved in MongoDB as a collection named "people".

Mongoose 允许以下类型定义架构的路径或文档结构：

*   一串
*   数字
*   布尔值
*   大堆
*   日期
*   缓冲器
*   混合的
*   目标
*   小数 128

可以直接使用`String`、`Number`、`Boolean`、`Buffer`、`Date`的全局构造函数来声明模式类型：

```js
      const { Schema} = require('mongoose') 
      const PersonSchema = new Schema({ 
          name: String, 
          age: Number, 
          isSingle: Boolean, 
          birthday: Date, 
          description: Buffer, 
      }) 
```

这些模式类型在导出的`mongoose`对象中名为`SchemaTypes`的对象下也可用：

```js
      const { Schema, SchemaTypes } = require('mongoose') 
      const PersonSchema = new Schema({ 
          name: SchemaTypes.String, 
          age: SchemaTypes.Number, 
          isSingle: SchemaTypes.Boolean, 
          birthday: SchemaTypes.Date, 
          description: SchemaTypes.Buffer, 
      }) 
```

可以使用对象作为属性来声明架构类型，该属性使您能够更好地控制特定的架构类型。以以下代码为例：

```js
      const { Schema } = require('mongoose') 
      const PersonSchema = new Schema({ 
          name: { type: String, required: true, default: 'Unknown' }, 
          age: { type: Number, min: 18, max: 80, required: true }, 
          isSingle: { type: Boolean }, 
          birthday: { type: Date, required: true }, 
          description: { type: Buffer }, 
      }) 
```

架构类型也可以是数组。例如，如果我们需要一个字段来定义用户在字符串数组中喜欢的内容，可以使用以下代码：

```js
      const PersonSchema = new Schema({ 
          name: String, 
          age: Number, 
          likes: [String], 
      }) 
```

要了解更多关于模式类型的信息，请访问官方 Mongoose 文档网站：[http://mongoosejs.com/docs/schematypes.html](http://mongoosejs.com/docs/schematypes.html) 。

# 准备

在这个配方中，您将看到如何定义模式并对数据库集合执行 CRUD 操作。首先，确保已安装 MongoDB 并且它正在运行。作为替代方案，如果您愿意，云中的 MongoDB**DBaaS**（**数据库即服务**实例也可以。开始之前，请使用以下代码创建一个新的`package.json`文件：

```js
      { 
        "dependencies": { 
          "mongoose": "5.0.11" 
       } 
     } 
```

然后，通过打开终端并运行以下代码来安装依赖项：

```js
 npm install
```

# 怎么做。。。

定义一个用户架构，该架构将包含用户的名字、姓氏和定义用户喜欢的内容的字符串数组：

1.  创建一个名为`mongoose-models.js`的新文件
2.  包括猫鼬 NPM 模块。然后，创建到 MongoDB 的连接：

```js
      const mongoose = require('mongoose') 
      const { connection, Schema } = mongoose 
      mongoose.connect( 
          'mongodb://localhost:27017/test' 
      ).catch(console.error) 
```

3.  定义架构：

```js
      const UserSchema = new Schema({ 
          firstName: String, 
          lastName: String, 
          likes: [String], 
      }) 
```

4.  将架构编译为模型：

```js
      const User = mongoose.model('User', UserSchema) 
```

5.  定义将用于添加新用户的函数：

```js
      const addUser = (firstName, lastName) => new User({ 
          firstName, 
          lastName, 
      }).save() 
```

6.  定义一个函数，该函数将用于通过其`id`从用户集合中检索用户：

```js
      const getUser = (id) => User.findById(id) 
```

7.  定义一个函数，通过其`id`将用户从用户集合中删除：

```js
      const removeUser = (id) => User.remove({ id }) 
```

8.  定义一个事件侦听器，一旦与数据库建立连接，该侦听器将执行 CRUD 操作。首先，添加一个新用户并保存它。然后，使用其`id`检索同一用户。接下来，修改用户的属性并保存它。最后，通过`id`将用户从集合中移除：

```js
      connection.once('connected', async () => { 
          try { 
              // Create 
              const newUser = await addUser('John', 'Smith') 
              // Read 
              const user = await getUser(newUser.id) 
              // Update 
              user.firstName = 'Jonny' 
              user.lastName = 'Smithy' 
              user.likes = [ 
                  'cooking', 
                  'watching movies', 
                  'ice cream', 
              ] 
              await user.save() 
              console.log(JSON.stringify(user, null, 4)) 
              // Delete 
              await removeUser(user.id) 
          } catch (error) { 
              console.dir(error.message, { colors: true }) 
          } finally { 
              await connection.close() 
          } 
      }) 
```

9.  保存文件。
10.  打开终端并运行以下代码：

```js
    node mongoose-models.js
```

在终端中执行上一个命令，如果成功，将显示类似于以下内容的代码，例如：

```js
      { 
          "likes": [ 
        "cooking", 
              "watching movies", 
              "ice cream" 
                ], 
          "_id": "[some id]", 
          "firstName": "Jonny", 
          "lastName": "Smithy", 
          "__v": 1 
      } 
```

# 另见

*   [第 1 章](1.html)、*MERN 堆栈简介*、*节安装 NPM 包*
*   [第一章](1.html)、*MERN 栈简介*、*节安装 MongoDB*

# 使用 Mongoose 查询生成器

每个 Mongoose 模型都有静态助手方法来执行多种操作，例如检索文档。将回调传递给这些帮助器方法时，将立即执行该操作：

```js
      const user = await User.findOne({ 
          firstName: 'Jonh', 
          age: { $lte: 30 }, 
      }, (error, document) => { 
          if (error) return console.log(error) 
          console.log(document) 
      }) 
```

否则，如果没有定义回调，则返回*查询生成器界面*，以后可以执行：

```js
      const user = User.findOne({ 
          firstName: 'Jonh', 
          age: { $lte: 30 }, 
      }) 
      user.exec((error, document) => { 
          if (error) return console.log(error) 
          console.log(document) 
      }) 
```

查询还有一个`.then`函数，可以用作`Promise`。调用`.then`时，首先在内部执行带有`.exec`的查询，然后返回一个`Promise`。这也允许我们使用`async/await`。在`async`函数中，例如：

```js
      try { 
          const user = await User.findOne({ 
              firstName: 'Jonh', 
              age: { $lte: 30 }, 
          }) 
          console.log(user) 
      } catch (error) { 
          console.log(error) 
      }  
```

我们可以通过两种方式进行查询。一种方法是提供一个用作条件的 JSON 对象，另一种方法允许您使用链接语法创建查询。对于更熟悉 SQL 数据库的开发人员来说，链接语法会感觉更舒服。例如：

```js
      try { 
          const user = await User.findOne() 
        .where('firstName', 'John') 
              .where('age').lte(30) 
          console.log(user) 
      }       catch (error) { 
          console.log(error) 
      }  
```

# 准备

在此配方中，您将使用链接语法和`async/await`函数建立查询。首先，确保已安装 MongoDB 并且它正在运行。另外，如果您愿意，云中的 MongoDB DBaaS 实例也可以。开始之前，请使用以下代码创建一个新的`package.json`文件：

```js
      { 
        "dependencies": { 
          "mongoose": "5.0.11" 
        } 
      } 
```

然后，通过打开终端并运行以下命令来安装依赖项：

```js
 npm install  
```

# 怎么做。。。

1.  创建一个名为`chaining-queries.js`的新文件

2.  包括猫鼬 NPM 模块。然后，创建一个新连接：

```js
      const mongoose = require('mongoose') 
      const { connection, Schema } = mongoose 
      mongoose.connect( 
          'mongodb://localhost:27017/test' 
      ).catch(console.error) 
```

3.  定义架构：

```js
      const UserSchema = new Schema({ 
          firstName: String, 
          lastName: String, 
          age: Number, 
      }) 
```

4.  将架构编译为模型：

```js
      const User = mongoose.model('User', UserSchema) 
```

5.  连接到数据库后，向用户集合添加新文档。然后，使用链接语法查询最近创建的用户。此外，使用`select`方法限制从文档中检索哪些字段：

```js
      connection.once('connected', async () => { 
          try { 
              const user = await new User({ 
                  firstName: 'John', 
                  lastName: 'Snow', 
                  age: 30, 
              }).save() 
              const findUser = await User.findOne() 
                  .where('firstName').equals('John') 
                  .where('age').lte(30) 
                  .select('lastName age') 
              console.log(JSON.stringify(findUser, null, 4)) 
              await user.remove() 
          } catch (error) { 
              console.dir(error.message, { colors: true }) 
          } finally { 
              await connection.close() 
          } 
      }) 
```

6.  保存文件
7.  打开终端并运行：

```js
    node chaining-queries.js

```

# 另见

*   [第 1 章](1.html)、*MERN 堆栈简介*、*节安装 NPM 包*
*   [第一章](1.html)、*MERN 栈简介*、*节安装 MongoDB*

# 定义文档实例方法

文档有自己的内置实例方法，如`save`和`remove`。但是，我们也可以编写自己的实例方法。

文档是模型的实例。可以显式创建它们：

```js
      const instance = new Model() 
```

也可以是查询的结果：

```js
      Model.findOne([conditions]).then((instance) => {}) 
```

文档实例方法在架构中定义。所有模式都有一个名为`method`的方法，允许您定义自定义实例方法。

# 准备

在此配方中，您将定义一个模式和自定义文档实例方法，用于修改和读取文档属性。首先，确保已安装 MongoDB 并且它正在运行。另外，如果您愿意，云中的 MongoDB DBaaS 实例也可以。开始之前，请使用以下代码创建一个新的`package.json`文件：

```js
{ 
  "dependencies": { 
    "mongoose": "5.0.11" 
  } 
} 
```

然后，通过打开终端并运行以下代码来安装依赖项：

```js
    npm install
```

# 怎么做。。。

1.  创建一个名为`document-methods.js`的新文件
2.  包括猫鼬 NPM 模块。然后，创建到 MongoDB 的新连接：

```js
      const mongooconst mongoose = require('mongoose') 
      const { connection, Schema } = mongoose 
      mongoose.connect( 
          'mongodb://localhost:27017/test' 
      ).catch(console.error) 
```

3.  定义架构：

```js
      const UserSchema = new Schema({ 
          firstName: String, 
          lastName: String, 
          likes: [String], 
      }) 
```

4.  定义一个文档实例方法，用于从包含全名的字符串中设置用户的名字和姓氏：

```js
      UserSchema.method('setFullName', function setFullName(v) { 
          const fullName = String(v).split(' ') 
          this.lastName = fullName[0] || '' 
          this.firstName = fullName[1] || '' 
      }) 
```

5.  定义一个文档实例方法，用于获取连接`firstName`和`lastName`属性的用户全名：

```js
      UserSchema.method('getFullName', function getFullName() { 
          return `${this.lastName} ${this.firstName}` 
      }) 
```

6.  定义一个名为`loves`的文档实例方法，该方法将期望一个参数添加到字符串的`likes`数组中：

```js
      UserSchema.method('loves', function loves(stuff) { 
          this.likes.push(stuff) 
      }) 
```

7.  定义一个名为`dislikes`的文档实例方法，该方法将从`likes`数组中删除用户以前喜欢的一项内容：

```js
      UserSchema.method('dislikes', function dislikes(stuff) { 
          this.likes = this.likes.filter(str => str !== stuff) 
      }) 
```

8.  将架构编译为模型：

```js
      const User = mongoose.model('User', UserSchema) 
```

9.  Mongoose 连接到数据库后，创建一个新用户并使用`setFullName`方法填充字段`firstName`和`lastName`，然后使用`loves`方法填充`likes`数组。接下来，使用链接语法查询集合中的用户，并使用`dislikes`方法从`likes`数组中删除`"snakes"`：

```js
      connection.once('connected', async () => { 
          try { 
              // Create 
              const user = new User() 
              user.setFullName('Huang Jingxuan') 
              user.loves('kitties') 
              user.loves('strawberries') 
              user.loves('snakes') 
              await user.save() 
              // Update 
              const person = await User.findOne() 
                  .where('firstName', 'Jingxuan') 
                  .where('likes').in(['snakes', 'kitties']) 
              person.dislikes('snakes') 
              await person.save() 
              // Display 
              console.log(person.getFullName()) 
              console.log(JSON.stringify(person, null, 4)) 
              // Remove 
              await user.remove() 
          } catch (error) { 
              console.dir(error.message, { colors: true }) 
          } finally { 
              await connection.close() 
          } 
      }) 
```

10.  保存文件。
11.  打开终端并运行以下代码：

```js
       node document-methods.js
```

# 还有更多。。。

还可以使用`methods`，schema 属性定义文档实例方法。例如：

```js
UserSchema.methods.setFullName = function setFullName(v) { 
    const fullName = String(v).split(' ') 
    this.lastName = fullName[0] || '' 
    this.firstName = fullName[1] || '' 
} 
```

# 另见

*   [第 1 章](1.html)、*MERN 堆栈简介*、*节安装 NPM 包*
*   [第一章](1.html)、*MERN 栈简介*、*节安装 MongoDB*

# 定义静态模型方法

模型具有内置的静态方法，如`find`、`findOne`和`findOneAndRemove`。Mongoose 还允许我们定义自定义静态模型方法。静态模型方法在模式中的定义方式与文档实例方法相同。

模式有一个名为`statics`的属性，它是一个对象。`statics`对象中定义的所有方法都会传递给模型。静态模型方法也可以通过调用`static`模式方法来定义。

# 准备

在此配方中，您将定义一个模式和自定义静态模型方法来扩展模型的功能。首先，确保已安装 MongoDB 并且它正在运行。另外，如果您愿意，云中的 MongoDB DBaaS 实例也可以。开始之前，请使用以下代码创建一个新的`package.json`文件：

```js
{ 
  "dependencies": { 
    "mongoose": "5.0.11" 
  } 
} 
```

然后，通过打开终端并运行以下命令来安装依赖项：

```js
npm install
```

# 怎么做。。。

定义一个名为`getByFullName`的静态模型方法，允许您使用其全名搜索特定用户：

1.  创建一个名为`static-methods.js`的新文件
2.  包括 Mongoose NPM 模块并创建到 MongoDB 的新连接：

```js
      const mongoose = require('mongoose') 
      const { connection, Schema } = mongoose 
      mongoose.connect( 
          'mongodb://localhost:27017/test' 
      ).catch(console.error) 
```

3.  定义架构：

```js
      const UsrSchm = new Schema({ 
          firstName: String, 
          lastName: String, 
          likes: [String], 
      }) 
```

4.  定义`getByFullName`静态模型方法：

```js
      UsrSchm.static('getByFullName', function getByFullName(v) { 
          const fullName = String(v).split(' ') 
          const lastName = fullName[0] || '' 
          const firstName = fullName[1] || '' 
          return this.findOne() 
              .where('firstName').equals(firstName) 
              .where('lastName').equals(lastName) 
      }) 
```

5.  将架构编译为模型：

```js
      const User = mongoose.model('User', UsrSchm) 
```

6.  连接后，创建一个新用户并保存它。然后，使用`getByFullName`静态模型方法在使用全名的用户集合中查找用户：

```js
      connection.once('connected', async () => { 
          try { 
              // Create 
              const user = new User({ 
                  firstName: 'Jingxuan', 
                  lastName: 'Huang', 
                  likes: ['kitties', 'strawberries'], 
              }) 
              await user.save() 
              // Read 
              const person = await User.getByFullName( 
                  'Huang Jingxuan' 
              ) 
              console.log(JSON.stringify(person, null, 4)) 
              await person.remove() 
              await connection.close() 
          } catch (error) { 
              console.log(error.message) 
          } 
      }) 
```

6.  保存文件
7.  打开终端并运行以下代码：

```js
    node static-methods.js

```

# 还有更多。。。

静态模型方法也可以使用`statics`模式属性定义。例如：

```js
UsrSchm.statics.getByFullName = function getByFullName(v) { 
    const fullName = String(v).split(' ') 
    const lastName = fullName[0] || '' 
    const firstName = fullName[1] || '' 
    return this.findOne() 
        .where('firstName').equals(firstName) 
        .where('lastName').equals(lastName) 
} 
```

# 另见

*   [第 1 章](1.html)、*MERN 堆栈简介*、*节安装 NPM 包*
*   [第一章](1.html)、*MERN 栈简介*、*节安装 MongoDB*

# 为 Mongoose 编写中间件函数

Mongoose 中的中间件功能也称为`hooks`。吊钩有两种类型`pre hooks`和`post hooks`。

`pre hooks`和立柱挂钩之间的区别非常简单。在调用方法之前调用`pre hooks`，在方法之后调用`post hooks`。例如：

```js
      const UserSchema = new Schema({ 
          firstName: String, 
          lastName: String, 
          fullName: String, 
      }) 
      UserSchema.pre('save', async function preSave() { 
          this.fullName = `${this.lastName} ${this.firstName}` 
      }) 
      UserSchema.post('save', async function postSave(doc) { 
          console.log(`New user created: ${doc.fullName}`) 
      }) 
      const User = mongoose.model('User', UserSchema) 
```

之后，一旦连接到数据库，`async`函数中：

```js
      const user = new User({ 
          firstName: 'John', 
          lastName: 'Smith', 
      }) 
      await user.save() 
```

调用`save`方法后，首先执行`pre hook`。文档保存后，执行`post hook`。在上一个示例中，它将在终端输出中显示以下文本：

```js
    New user created: Smith John
```

Mongoose 中有四种不同类型的中间件功能：文档中间件、模型中间件、聚合中间件和查询中间件。所有这些都是在模式级别定义的。区别在于，当执行钩子时，`this`的上下文指的是文档、模型、聚合对象或查询对象。

All types of middleware support pre and post hooks

# 准备

在本配方中，我们将看到这三种类型的中间件功能如何在 Mongoose 中工作：

*   文档中间件
*   模型中间件
*   查询中间件

首先，确保已安装 MongoDB 并且它正在运行。另外，如果您愿意，云中的 MongoDB DBaaS 实例也可以。开始之前，请使用以下代码创建一个新的`package.json`文件：

```js
      { 
        "dependencies": { 
          "mongoose": "5.0.11" 
        } 
      } 
```

然后，通过打开终端并运行以下命令来安装依赖项：

```js
 npm install
```

# 怎么做。。。

在文档中间件功能中，`this`的上下文是指文档。文档有以下内置方法，您可以为其定义`hooks`：

*   `init`：从 MongoDB 返回文档后立即在内部调用。Mongoose 使用 setter 将文档标记为已修改或文档的哪些字段已修改。`init`在没有设置符的情况下初始化文档。
*   `validate`：执行单据的内置和自定义设置的验证规则。
*   `save`：将文档保存到数据库中。
*   `remove`：从数据库中删除文档。

# 文档中间件功能

为文档内置方法创建`pre`和`post`钩子：

1.  创建一个名为`1-document-middleware.js`的新文件
2.  包括 Mongoose NPM 模块并创建到 MongoDB 的新连接：

```js
      const mongoose = require('mongoose') 
      const { connection, Schema } = mongoose 
      mongoose.connect( 
          'mongodb://localhost:27017/test' 
      ).catch(console.error) 
```

3.  定义架构：

```js
      const UserSchema = new Schema({ 
          firstName: { type: String, required: true }, 
          lastName: { type: String, required: true }, 
      }) 
```

4.  `init`单据方式增加`pre`和`post`钩子：

```js
      UserSchema.pre('init', async function preInit() { 
          console.log('A document is going to be initialized.') 
      }) 
      UserSchema.post('init', async function postInit() { 
          console.log('A document was initialized.') 
      }) 
```

5.  `validate`单据方式增加`pre`和`post`钩子：

```js
      UserSchema.pre('validate', async function preValidate() { 
          console.log('A document is going to be validated.') 
      }) 
      UserSchema.post('validate', async function postValidate() { 
          console.log('All validation rules were executed.') 
      }) 
```

6.  `save`单据方式增加`pre`和`post`钩子：

```js
      UserSchema.pre('save', async function preSave() { 
          console.log('Preparing to save the document') 
      }) 
      UserSchema.post('save', async function postSave() { 
          console.log(`A doc was saved id=${this.id}`) 
      }) 
```

7.  `remove`单据方式增加`pre`和`post`钩子：

```js
      UserSchema.pre('remove', async function preRemove() { 
          console.log(`Doc with id=${this.id} will be removed`) 
      }) 
      UserSchema.post('remove', async function postRemove() { 
          console.log(`Doc with id=${this.id} was removed`) 
      }) 
```

8.  将架构编译为模型：

```js
      const User = mongoose.model('User', UserSchema) 
```

9.  建立新连接后，创建文档并执行一些基本操作，如保存、检索和删除文档：

```js
      connection.once('connected', async () => { 
          try { 
              const user = new User({ 
                  firstName: 'John', 
                  lastName: 'Smith', 
              }) 
              await user.save() 
              await User.findById(user.id) 
              await user.remove() 
              await connection.close() 
          } catch (error) { 
              await connection.close() 
              console.dir(error.message, { colors: true }) 
          } 
      }) 
```

10.  保存文件
11.  打开终端并运行：

```js
 node document-middleware.js
```

12.  在终端上，输出应显示：

```js
      A document is going to be validated. 
      All validation rules were executed. 
      Preparing to save the document 
      A doc was saved id=[ID] 
      A document is going to be initialized. 
      A document was initialized. 
      Doc with id=[ID] will be removed 
      Doc with id=[ID] was removed 
```

保存文档时，它首先触发`validation`钩子，确保字段通过内置验证规则或自定义规则设置的规则。在代码中，字段标记为必需。然后触发`save`挂钩。之后，使用模型方法从数据库中检索最近创建的用户，一旦检索到文档，就会触发`init`钩子。最后，从数据库中删除文档会触发`remove`钩子。

在钩子中，您可以与文档交互。例如，下面的`save`预钩子将修改字段`firstName`和`lastName`，使其成为大写字符串：

```js
UserSchema.pre('save', async function preSave() { 
    this.firstName = this.firstName.toUpperCase() 
    this.lastName = this.lastName.toUpperCase() 
}) 
```

同样，我们可以在钩子中抛出一个错误，以防止执行下一个错误。例如：

```js
UserSchema.pre('save', async function preSave() { 
    throw new Error('Doc was prevented from being saved.') 
}) 
```

查询中间件功能的定义与文档中间件功能的定义完全相同。但是，`this`的上下文不是指文档，而是指查询对象。查询中间件功能仅在以下模型和查询功能中受支持：

*   `count`：统计符合特定查询条件的单据数
*   `find`：返回符合特定查询条件的文档数组
*   `findOne`：返回符合特定查询条件的单据
*   `findOneAndRemove`：与`findOne`类似。但是，在找到文档后，它将被删除
*   `findOneAndUpdate`：与`findOne`类似，但一旦找到符合特定查询条件的单据，也可以进行更新
*   `update`：更新一张或多张符合一定查询条件的单据

# 查询中间件功能

为查询内置方法创建前置和后置挂钩：

1.  创建一个名为`2-query-middleware.js`的新文件
2.  包括 Mongoose NPM 模块并创建到 MongoDB 的新连接：

```js
      const mongoose = require('mongoose') 
      const { connection, Schema } = mongoose 
      mongoose.connect( 
          'mongodb://localhost:27017/test' 
      ).catch(console.error) 
```

3.  定义架构：

```js
      const UserSchema = new Schema({ 
          firstName: { type: String, required: true }, 
          lastName: { type: String, required: true }, 
      }) 
```

4.  定义`count`、`find`、`findOne`和`update`方法的前后挂钩：

```js
      UserSchema.pre('count', async function preCount() { 
          console.log( 
              `Preparing to count document with this criteria: 
              ${JSON.stringify(this._conditions)}` 
          ) 
      }) 
      UserSchema.post('count', async function postCount(count) { 
          console.log(`Counted ${count} documents that coincide`) 
      }) 
      UserSchema.pre('find', async function preFind() { 
          console.log( 
              `Preparing to find all documents with criteria: 
              ${JSON.stringify(this._conditions)}` 
          ) 
      }) 
      UserSchema.post('find', async function postFind(docs) { 
          console.log(`Found ${docs.length} documents`) 
      }) 
      UserSchema.pre('findOne', async function prefOne() { 
          console.log( 
              `Preparing to find one document with criteria: 
              ${JSON.stringify(this._conditions)}` 
          ) 
      }) 
      UserSchema.post('findOne', async function postfOne(doc) { 
          console.log(`Found 1 document:`, JSON.stringify(doc)) 
      }) 
      UserSchema.pre('update', async function preUpdate() { 
          console.log( 
              `Preparing to update all documents with criteria: 
              ${JSON.stringify(this._conditions)}` 
          ) 
      }) 
      UserSchema.post('update', async function postUpdate(r) { 
          console.log(`${r.result.ok} document(s) were updated`) 
      }) 
```

5.  将架构编译为模型：

```js
      const User = mongoose.model('User', UserSchema) 
```

6.  成功建立到数据库的连接后，创建一个文档，保存它，并使用我们为其定义挂钩的方法：

```js
      connection.once('connected', async () => { 
          try { 
              const user = new User({ 
                  firstName: 'John', 
                  lastName: 'Smith', 
              }) 
              await user.save() 
              await User 
                  .where('firstName').equals('John') 
                  .update({ lastName: 'Anderson' }) 
              await User 
                  .findOne() 
                  .select(['lastName']) 
                  .where('firstName').equals('John') 
              await User 
                  .find() 
                  .where('firstName').equals('John') 
              await User 
                  .where('firstName').equals('Neo') 
                  .count() 
              await user.remove() 
          } catch (error) { 
              console.dir(error, { colors: true }) 
          } finally { 
              await connection.close() 
          } 
      }) 
```

7.  保存文件
8.  打开终端并运行：

```js
 node query-middleware.js
```

9.  在终端上，输出应显示类似以下内容：

```js
      Preparing to update all documents with criteria: 
                {"firstName":"John"} 
      1 document(s) were updated 
      Preparing to find one document with criteria: 
                {"firstName":"John"} 
      Found 1 document: {"_id":"[ID]","lastName":"Anderson"} 
      Preparing to find all documents with criteria: 
                {"firstName":"John"} 
      Found 1 documents 
      Preparing to count document with this criteria: 
                {"firstName":"Neo"} 
      Counted 0 documents that coincide 
```

最后，只有一个模型实例方法支持钩子：

*   仅当通过验证的所有文档都保存在数组中时，【如果通过了验证，则将其保存在数组中】

正如您可能猜到的，模型中间件功能的定义方式与查询中间件方法和文档中间件方法的定义方式相同。

# 模型中间件功能

对于`post`和`pre`模型：

1.  创建一个名为`3-model-middleware.js`的新文件
2.  包括 Mongoose NPM 模块并创建到 MongoDB 的新连接：

```js
      const mongoose = require('mongoose') 
      const { connection, Schema } = mongoose 
      mongoose.connect( 
          'mongodb://localhost:27017/test' 
      ).catch(console.error) 
```

3.  定义架构：

```js
      const UserSchema = new Schema({ 
          firstName: { type: String, required: true }, 
          lastName: { type: String, required: true }, 
      }) 
```

4.  为`insertMany`模型方法定义`pre`和`post`挂钩：

```js
      UserSchema.pre('insertMany', async function prMany() { 
          console.log('Preparing docs...') 
      }) 
      UserSchema.post('insertMany', async function psMany(docs) { 
          console.log('The following docs were created:n', docs) 
      }) 
```

5.  将架构编译为模型：

```js
      const User = mongoose.model('User', UserSchema) 
```

6.  建立与数据库的连接后，使用`insertMany`方法一次插入两个文档：

```js
      connection.once('connected', async () => { 
          try { 
              await User.insertMany([ 
                  { firstName: 'Leo', lastName: 'Smith' }, 
                  { firstName: 'Neo', lastName: 'Jackson' }, 
              ]) 
          } catch (error) { 
              console.dir(error, { colors: true }) 
          } finally { 
              await connection.close() 
          } 
      }) 
```

7.  保存文件
8.  打开终端并运行：

```js
 node query-middleware.js
```

9.  在终端上，输出应显示：

```js
      Preparing docs... 
      The following documents were created: 
      [ { firstName: 'Leo', lastName: 'Smith', _id: [id] }, 
        { firstName: 'Neo', lastName: 'Jackson', _id: [id] } ] 
```

# 还有更多。。。

将字段标记为所需字段非常有用，以避免在数据库中保存“null”值。另一种方法是为在文档创建时未明确定义的字段设置默认值。例如：

```js
      const UserSchema = new Schema({ 
          name: { 
              type: string, 
              required: true, 
              default: 'unknown', 
          } 
      }) 
```

创建新文档时，如果未分配路径或属性`name`，则会分配模式类型选项`default`中定义的默认值。

The schema type `default` option can also be a function. The value returned by calling this function is assigned as the default value.

定义模式类型时，只需添加括号即可创建子文档或数组。例如：

```js
      const WishBoxSchema = new Schema({ 
          wishes: { 
              type: [String], 
              required: true, 
              default: [ 
                  'To be a snowman', 
                  'To be a string', 
                  'To be an example', 
              ], 
          }, 
      }) 
```

创建新文档时，`wishes`属性或路径中将包含字符串数组。如果未提供数组，则将使用默认值创建文档。

# 另见

*   [第 1 章](1.html)、*MERN 堆栈简介*、*节安装 NPM 包*
*   [第一章](1.html)、*MERN 栈简介*、*节安装 MongoDB*

# 为 Mongoose 的模式编写自定义验证器

Mongoose 有几个内置的验证规则。例如，如果定义一个模式类型为`string`的属性并将其设置为`required`，则将执行两个验证规则，一个用于检查该属性是否为有效的`string`，另一个用于检查该属性是否为`null`或`undefined`。

还可以在 Mongoose 中定义自定义验证规则和自定义错误验证消息，以便在将某些属性保存到数据库之前，更好地控制接受这些属性的方式和时间。

验证规则在模式中定义。所有模式类型都有一个内置的验证器`required`，这意味着它不能包含`undefined`或`null`值。`required`验证器可以是`boolean`、`function`或`array`类型。例如：

```js
      path: { type: String, required: true } 
      path: { type: String, required: [true, 'Custom error message'] } 
      path: { type: String, required: () => true } 
```

字符串架构类型具有以下内置验证器：

*   `enum`：表示字符串只能有`enum`数组中指定的值。例如：

```js
      gender: { 
      type: SchemaTypes.String, 
      enum: ['male', 'female', 'other'], 
      } 
```

*   `match`：使用`RegExp`测试数值。例如，要允许以`www`开头的值：

```js
      website: { 
      type: SchemaTypes.String, 
      match: /^www/, 
      } 
```

*   `maxlength`：定义字符串可以具有的最大长度。
*   `minlength`：定义字符串可以具有的最小长度。例如，要仅允许介于`5`和`20`字符之间的字符串：

```js
      name: { 
      type: SchemaTypes.String, 
      minlength: 5, 
      maxlength: 20, 
      } 
```

许多架构类型有两个内置的验证器：

*   `min`：定义一个数字可以具有的最小值。
*   `max`：定义一个数字可以拥有的最大值。例如，仅允许介于`18`和`100`之间的数字：

```js
      age: { 
      type: String, 
      min: 18, 
      max: 100, 
      } 
```

Undefined values pass all validators without error. If you want to throw an error if a value is `undefined`, do not forget to use the `required` validator to `true`

当内置验证器有时不能满足您的要求，或者您希望执行复杂的验证规则时，您有一个名为`validate.`的选项或属性，它接受一个具有两个属性`validator`和`message,`的对象，允许我们编写自定义验证器：

```js
      nickname: { 
      type: String, 
      validate: { 
      validator: function validator(value) { 
      return /^[a-zA-Z-]$/.test(value) 
      }, 
      message: '{VALUE} is not a valid nickname.', 
      }, 
      } 
```

# 准备

在此配方中，您将看到如何使用自定义验证规则来确保某个字段匹配或满足定义的规则。首先，确保已安装 MongoDB 并且它正在运行。另外，如果您愿意，云中的 MongoDB DBaaS 实例也可以。开始之前，请使用以下代码创建一个新的`package.json`文件：

```js
      { 
        "dependencies": { 
          "mongoose": "5.0.11" 
        } 
      } 
```

然后，通过打开终端并运行以下命令来安装依赖项：

```js
 npm install  
```

# 怎么做。。。

创建用户架构，并确保所有用户名均为字符串类型，最小长度为 6 个字符，最大长度为 20 个字符，与正则表达式匹配，并且是必需的：

1.  创建一个名为`custom-validation.js`的新文件
2.  包括 Mongoose NPM 模块并创建与数据库的新连接：

```js
      const mongoose = require('mongoose') 
      const { connection, Schema } = mongoose 
      mongoose.connect( 
          'mongodb://localhost:27017/test' 
      ).catch(console.error) 
```

3.  为`username`字段定义包含验证规则的架构：

```js
      const UserSchema = new Schema({ 
          username: { 
              type: String, 
              minlength: 6, 
              maxlength: 20, 
              required: [true, 'user is required'], 
              validate: { 
                  message: '{VALUE} is not a valid username', 
                  validator: (val) => /^[a-zA-Z]+$/.test(val), 
              }, 
          }, 
      }) 
```

4.  将架构编译为模型：

```js
      const User = mongoose.model('User', UserSchema) 
```

5.  建立与数据库的连接后，使用无效字段创建新文档，并使用`validateSync`文档方法触发验证内置和自定义方法：

```js
      connection.once('connected', async () => { 
          try { 
              const user = new User() 
              let errors = null 
              // username field is not defined 
              errors = user.validateSync() 
              console.dir(errors.errors['username'].message) 
              // username contains less than 6 characters 
              user.username = 'Smith' 
              errors = user.validateSync() 
              console.dir(errors.errors['username'].message) 
              // RegExp matching 
              user.username = 'Smith_9876' 
              errors = user.validateSync() 
              console.dir(errors.errors['username'].message) 
          } catch (error) { 
              console.dir(error, { colors: true }) 
          } finally { 
              await connection.close() 
          } 
      }) 
```

6.  保存文件
7.  打开终端并运行：

```js
 node custom-validation.js  
```

8.  在终端上，输出应显示：

```js
      'user is required' 
      'Path `username` (`Smith`) is shorter than the minimum allowed             
       length (6).' 
      'Smith_9876 is not a valid username' 
```

# 另见

*   [第 1 章](1.html)、*MERN 堆栈简介*、*节安装 NPM 包*
*   [第一章](1.html)、*MERN 栈简介*、*章节*安装 MongoDB**

# 使用 ExpressJS 和 Mongoose 构建 RESTful API 来管理用户

在此配方中，您将构建一个 RESTful API，该 API 将允许创建新用户、登录、显示用户信息和删除用户配置文件。此外，您将学习如何使用客户端 API 构建 NodeJS REPL，您可以使用客户端 API 与服务器的 RESTful API 交互。

一个**REPL**（**Read Eval Print Loop**）就像一个交互式 shell，您可以在其中一个接一个地执行命令。例如，可以通过在终端中运行以下命令来打开 Node.js REPL：

```js
node -i 
```

这里，`-i`标志代表互动。现在，您可以在新的上下文中执行逐段计算的 JavaScript 代码。

# 准备

本食谱将重点展示 Mongoose 与 ExpressJS 的集成，使用以前的食谱中看到的内容。首先，确保已安装 MongoDB 并且它正在运行。另外，如果您愿意，云中的 MongoDB DBaaS 实例也可以。开始之前，请使用以下代码创建一个新的`package.json`文件：

```js
      { 
        "dependencies": { 
          "body-parser": "1.18.2", 
          "connect-mongo": "2.0.1", 
          "express": "4.16.3", 
          "express-session": "1.15.6", 
          "mongoose": "5.0.11", 
          "node-fetch": "2.1.2" 
        } 
      } 
```

然后，通过打开终端并运行以下代码来安装依赖项：

```js
npm install
```

# 怎么做。。。

首先，创建一个名为`server.js`的文件，该文件将包含两个中间件功能。一个用于配置会话，另一个用于在允许调用任何路由之前确保与 MongoDB 有连接。然后，我们将 API 路由装载到特定路径：

1.  创建一个名为`server.js`的新文件
2.  包括所需的库。然后，初始化新的 ExpressJS 应用程序并创建到 MongoDB 的连接：

```js
      const mongoose = require('mongoose') 
      const express = require('express') 
      const session = require('express-session') 
      const bodyParser = require('body-parser') 
      const MongoStore = require('connect-mongo')(session) 
      const api = require('./api/controller') 
      const app = express() 
      const db = mongoose.connect( 
          'mongodb://localhost:27017/test' 
      ).then(conn => conn).catch(console.error) 
```

3.  使用`body-parser`中间件将请求主体解析为 JSON：

```js
      app.use(bodyParser.json()) 
```

4.  定义 ExpressJS 中间件功能，确保您的 web 应用程序在允许执行下一个路由处理程序之前先连接到 MongoDB：

```js
      app.use((request, response, next) => {
        Promise.resolve(db).then(
        (connection, err) => (
            typeof connection !== 'undefined'
            ? next()
            : next(new Error('MongoError'))
            )
          )
      })
```

5.  配置`express-session`中间件将会话存储在 Mongo 数据库中，而不是存储在内存中：

```js
      app.use(session({ 
          secret: 'MERN Cookbook Secrets', 
          resave: false, 
          saveUninitialized: true, 
          store: new MongoStore({ 
              collection: 'sessions', 
              mongooseConnection: mongoose.connection, 
          }), 
      })) 
```

6.  将 API 控制器安装到`"/api"`路线：

```js
      app.use('/users', api) 
```

7.  在端口 1773 上侦听新连接：

```js
      app.listen( 
          1337, 
          () => console.log('Web Server running on port 1337'), 
      ) 
```

8.  保存文件

然后，创建一个名为`api`的新目录。接下来，创建应用程序的模型或业务逻辑。使用静态和实例方法为用户定义架构，这些方法将允许用户注册、登录、注销、获取配置文件数据、更改密码和删除配置文件：

1.  在`api`目录中创建一个名为`model.js`的新文件
2.  包括 Mongoose NPM 模块和用于生成用户密码哈希的`crypto`节点 JS 模块：

```js
      const { connection, Schema } = require('mongoose') 
      const crypto = require('crypto') 
```

3.  定义架构：

```js
      const UserSchema = new Schema({ 
          username: { 
              type: String, 
              minlength: 4, 
              maxlength: 20, 
              required: [true, 'username field is required.'], 
              validate: { 
                  validator: function (value) { 
                      return /^[a-zA-Z]+$/.test(value) 
                  }, 
                  message: '{VALUE} is not a valid username.', 
              }, 
          }, 
          password: String, 
      }) 
```

4.  为`login`定义静态模型方法：

```js
      UserSchema.static('login', async function(usr, pwd) { 
          const hash = crypto.createHash('sha256') 
              .update(String(pwd)) 
          const user = await this.findOne() 
              .where('username').equals(usr) 
              .where('password').equals(hash.digest('hex')) 
          if (!user) throw new Error('Incorrect credentials.') 
          delete user.password 
          return user 
      }) 
```

5.  为`signup`定义静态模型方法：

```js
      UserSchema.static('signup', async function(usr, pwd) { 
          if (pwd.length < 6) { 
              throw new Error('Pwd must have more than 6 chars') 
          } 
          const hash = crypto.createHash('sha256').update(pwd) 
          const exist = await this.findOne() 
              .where('username') 
              .equals(usr) 
          if (exist) throw new Error('Username already exists.') 
          const user = this.create({ 
              username: usr, 
              password: hash.digest('hex'), 
          }) 
          return user 
      }) 
```

6.  为`changePass`定义一个文档实例方法：

```js
      UserSchema.method('changePass', async function(pwd) { 
          if (pwd.length < 6) { 
              throw new Error('Pwd must have more than 6 chars') 
          } 
          const hash = crypto.createHash('sha256').update(pwd) 
          this.password = hash.digest('hex') 
          return this.save() 
      }) 
```

7.  将 Mongoose 模式编译为模型并导出：

```js
      module.exports = connection.model('User', UserSchema) 
```

8.  保存文件

最后，定义一个控制器，将请求主体转换为我们的模型可以理解的操作。然后将其导出为包含所有 API 路径的 ExpressJS 路由：

1.  在`api`文件夹中创建一个名为`controller.js`的新文件
2.  导入`model.js`并初始化新的 ExpressJS 路由：

```js
      const express = require('express') 
      const User = require('./model') 
      const api = express.Router() 
```

3.  定义一个请求处理程序以检查用户是否登录，定义另一个请求处理程序以检查用户是否未登录：

```js
      const isLogged = ({ session }, res, next) => { 
          if (!session.user) res.status(403).json({ 
              status: 'You are not logged in!', 
          }) 
          else next() 
      } 
      const isNotLogged = ({ session }, res, next) => { 
          if (session.user) res.status(403).json({ 
              status: 'You are logged in already!', 
          }) 
          else next() 
      } 
```

4.  定义一个`post`请求方法来处理对`"/login"`端点的请求：

```js
      api.post('/login', isNotLogged, async (req, res) => { 
          try { 
              const { session, body } = req 
        const { username, password } = body 
              const user = await User.login(username, password) 
              session.user = { 
                  _id: user._id, 
                  username: user.username, 
              } 
              session.save(() => { 
                  res.status(200).json({ status: 'Welcome!'}) 
              }) 
          } catch (error) { 
              res.status(403).json({ error: error.message }) 
          } 
      }) 
```

5.  定义一个`post`请求方法来处理对`"/logout"`端点的请求：

```js
      api.post('/logout', isLogged, (req, res) => { 
          req.session.destroy() 
          res.status(200).send({ status: 'Bye bye!' }) 
      }) 
```

6.  定义一个`post`请求方法来处理对`"/signup"`端点的请求：

```js
      api.post('/signup', async (req, res) => { 
          try { 
              const { session, body } = req 
              const { username, password } = body 
              const user = await User.signup(username, password) 
              res.status(201).json({ status: 'Created!'}) 
          } catch (error) { 
              res.status(403).json({ error: error.message }) 
          } 
      }) 
```

7.  定义一个`get`请求方法来处理对`"/profile"`端点的请求：

```js
      api.get('/profile', isLogged, (req, res) => { 
          const { user } = req.session 
          res.status(200).json({ user }) 
      }) 
```

8.  定义一个`put`请求方法来处理对`"/changepass"`端点的请求：

```js
      api.put('/changepass', isLogged, async (req, res) => { 
          try { 
              const { session, body } = req 
              const { password } = body 
              const { _id } = session.user 
              const user = await User.findOne({ _id }) 
              if (user) { 
                  await user.changePass(password) 
                  res.status(200).json({ status: 'Pwd changed' }) 
              } else { 
                  res.status(403).json({ status: user }) 
              } 
          } catch (error) { 
              res.status(403).json({ error: error.message }) 
          } 
      }) 
```

9.  定义一个删除请求方法来处理对`"/delete"`端点的请求：

```js
      api.delete('/delete', isLogged, async (req, res) => { 
          try { 
              const { _id } = req.session.user 
              const user = await User.findOne({ _id }) 
              await user.remove() 
              req.session.destroy((err) => { 
                  if (err) throw new Error(err) 
                  res.status(200).json({ status: 'Deleted!'}) 
              }) 
          } catch (error) { 
              res.status(403).json({ error: error.message }) 
          } 
      }) 
```

10.  导出路线：

```js
      module.exports = api 
```

11.  保存文件

# 让我们测试一下。。。

您已经构建了一个 RESTful API，允许用户订阅或注册、登录、注销、获取他们的配置文件以及删除他们的配置文件。可以通过向服务器发出 HTTP 请求来执行这些操作。我们现在将构建一个小型的 NodeJS REPL 和客户端 API，允许您使用普通 JavaScript 函数与 RESTful API 服务器交互：

1.  移动到项目目录的根目录并创建一个名为`client-repl.js`的新文件。
2.  包括允许向服务器发出 HTTP 请求的`node-fetch`NPM 模块。还包括允许您创建交互式 Node.js REPL 的`repl`和`vm`Node.js 模块：

```js
      const repl = require('repl') 
      const util = require('util') 
      const vm = require('vm') 
      const fetch = require('node-fetch') 
      const { Headers } = fetch 
```

3.  定义一个变量，该变量将在用户登录后包含 cookie 中的会话 ID。cookie 将用于允许服务器识别登录用户的操作，例如获取有关您的配置文件的信息或更改密码：

```js
      let cookie = null 
```

4.  定义一个名为`query`的助手函数，该函数允许向服务器发出 HTTP 请求。`credentials`选项允许向服务器发送和接收 cookie。我们定义了`headers`，它将告诉服务器将作为 JSON 内容发送的请求主体的内容类型：

```js
      const query = (path, ops) => { 
          return fetch(`http://localhost:1337/users/${path}`, { 
              method: ops.method, 
              body: ops.body, 
              credentials: 'include', 
              body: JSON.stringify(ops.body), 
              headers: new Headers({ 
                  ...(ops.headers || {}), 
                  cookie, 
                  Accept: 'application/json', 
                  'Content-Type': 'application/json', 
              }), 
          }).then(async (r) => { 
              cookie = r.headers.get('set-cookie') || cookie 
              return { 
                  data: await r.json(), 
                  status: r.status, 
              } 
          }).catch(error => error) 
      } 
```

5.  定义允许用户注册的方法：

```js
      const signup = (username, password) => query('/signup', { 
          method: 'POST', 
          body: { username, password }, 
      }) 
```

6.  定义允许用户登录的方法：

```js
      const login = (username, password) => query('/login', { 
          method: 'POST', 
          body: { username, password }, 
      }) 
```

7.  定义允许用户注销的方法：

```js
      const logout = () => query('/logout', { 
          method: 'POST', 
      }) 
```

8.  定义允许用户获取其配置文件的方法：

```js
      const getProfile = () => query('/profile', { 
          method: 'GET', 
      }) 
```

9.  定义允许用户更改密码的方法：

```js
      const changePassword = (password) => query('/changepass', { 
          method: 'PUT', 
          body: { password }, 
      }) 
```

10.  定义允许用户删除其配置文件的方法：

```js
      const deleteProfile = () => query('/delete', { 
          method: 'DELETE', 
      }) 
```

11.  使用 REPL 导出对象中的 start 方法启动新的 REPL 服务器。我们将指定 eval 方法来使用 VM 模块执行 JavaScript 代码，然后，如果返回承诺，它将等待承诺得到解决，然后允许用户在 REPL 中输入更多命令或键入更多 JavaScript 代码。我们还将指定 writer 方法，该方法将漂亮地打印调用先前定义的方法的结果：

```js
      const replServer = repl.start({ 
          prompt: '> ', 
          ignoreUndefined: true, 
          async eval(cmd, context, filename, callback) { 
              const script = new vm.Script(cmd) 
              const is_raw = process.stdin.isRaw 
              process.stdin.setRawMode(false) 
              try { 
                  const res = await Promise.resolve( 
                      script.runInContext(context, { 
                          displayErrors: false, 
                          breakOnSigint: true, 
                      }) 
                  ) 
                  callback(null, res) 
              } catch (error) { 
                  callback(error) 
              } finally { 
                  process.stdin.setRawMode(is_raw) 
              } 
          }, 
          writer(output) { 
              return util.inspect(output, { 
                  breakLength: process.stdout.columns, 
                  colors: true, 
                  compact: false, 
              }) 
          } 
      }) 
```

12.  将先前定义的方法添加到将执行 JavaScript 代码的 REPL 服务器的上下文中：

```js
      replServer.context.api = { 
          signup, 
          login, 
          logout, 
          getProfile, 
          changePassword, 
          deleteProfile, 
      } 
```

13.  保存文件

现在，您可以在终端上运行 RESTful API 服务器：

```js
node server.js 
```

在另一个终端中，运行刚才创建的 NodeJS REPL 应用程序：

```js
node client-repl.js
```

在 REPL 中，您可以执行 JavaScript 代码，还可以访问导出的方法。例如，您可以在 REPL 中逐行执行以下 JavaScript 代码：

```js
      api.signup('John', 'zxcvbnm') 
      api.login('John', 'zxcvbnm') 
      api.getProfile() 
      api.changePassword('newPwd') 
      api.logout() 
      api.login('John', 'incorrectPwd') 
```

# 它是如何工作的。。。

RESTful API 服务器将接受以下路径的请求：

*   `POST/users/login`：如果 MongoDB 中`users`集合中不存在用户名，则向客户端发送错误消息。否则，它将返回欢迎消息。
*   `POST/users/logout`：这会破坏会话 ID。
*   `POST/users/signup`：使用定义的密码创建一个新用户名。但是，如果用户名或密码未通过验证，则会向客户端发送错误。当用户名已经存在时，它还会向客户端发送错误消息。
*   `GET/users/profile`：如果用户登录，则将用户信息发送给客户端。否则，将向客户端发送错误消息。
*   `PUT/users/changepass/`：这将更改当前登录用户的密码。但是，如果用户未登录，则会向客户端发送错误消息。
*   `DELETE/users/delete`：这将从 MongoDB 中的集合`users`中删除登录用户的配置文件。会话将被销毁，并向客户端发送确认消息。如果用户未登录，则会向客户端发送错误消息

# 另见

*   [第一章](1.html)*MERN Stack 简介*章节*安装 NPM 包*
*   [第一章](1.html)、*MERN Stack 简介*、*节安装 MongoDB*