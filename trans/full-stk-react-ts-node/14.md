B15508_14_Final_JC_ePub

# *第 14 章*：设置 Postgres 和 TypeForm 存储库层

在本章中，我们将学习如何设置一个存储库层，使用 Postgres 作为我们的数据库，使用 TypeORM 作为我们访问数据库的库。我们将建立我们的数据库模式，在 TypeORM 的帮助下，我们将能够为我们的应用程序执行**CRUD**（**创建、读取、更新、删除**操作。这是至关重要的一章，因为我们后端的核心活动将是检索和更新数据。

在本章中，我们将介绍以下主要主题：

*   建立我们的 Postgres 数据库
*   使用 TypeORM 理解对象关系映射器
*   使用 Postgres 和 TypeORM 构建存储库层

# 技术要求

这本书不会教你关于关系数据库的知识。因此，您应该对 SQL 有基本的了解，包括简单的查询和表结构，以及使用 Node 进行 web 开发。我们将再次使用 Node 和 visualstudio 代码来编写代码。

GitHub 存储库位于[https://github.com/PacktPublishing/Full-Stack-React-TypeScript-and-Node](https://github.com/PacktPublishing/Full-Stack-React-TypeScript-and-Node) 。使用`Chap14`文件夹中的代码。

要设置[*第 14 章*](#_idTextAnchor216)代码文件夹，请转到您的`HandsOnTypescript`文件夹并创建一个名为`Chap14`的新文件夹。

# 建立我们的博士后数据库

在本节中，我们将安装并设置 Postgres 数据库。关系数据库仍然非常相关，而如今 NoSQL 数据库风靡一时。然而，根据 StackOverflow，Postgres 仍然是世界上最流行的数据库之一。此外，它的性能是世界级的，大大超过了 MongoDB（[https://www.enterprisedb.com/news/new-benchmarks-show-postgres-dominating-mongodb-varied-workloads [T2]。因此，我们将使用 Postgres 作为我们的数据库技术。](https://www.enterprisedb.com/news/new-benchmarks-show-postgres-dominating-mongodb-varied-workloads)

让我们安装我们的 Postgres 数据库。我们将使用 EDB 提供的安装程序。EDB 是一家第三方公司，提供支持 Postgres 的工具和服务：

1.  转到 URL[https://www.enterprisedb.com/downloads/postgres-postgresql-downloads](https://www.enterprisedb.com/downloads/postgres-postgresql-downloads) 并为您的平台选择下载。我将在 Mac 上使用 12.4 版，这是截至撰写本文时的最新 Mac 版本。
2.  Accept all the defaults on the installer, including the list of components to be installed, as shown here:

    ![Figure 14.1 – Postgres Setup screen ](image/Figure_14.01_B15508.jpg)

    图 14.1–Postgres 设置屏幕

3.  Once your install finishes, start up the `pgAdmin` application. This application is the administrator application for Postgres. You should see a screen like this:

    ![Figure 14.2 – First view of pgAdmin ](image/Figure_14.02_B15508.jpg)

    图 14.2–pgAdmin 的第一视图

    如您所见，它是一个 web 浏览器应用程序。我的安装中有一些其他服务器，但如果这是您的第一次`pgAdmin`安装，您的安装中不应该有任何服务器。

4.  现在，让我们创建一个名为`HandsOnFullStackGroup`的新服务器组，以便将我们的工作与其他工作分开。服务器组只是一个容纳多个服务器实例的容器，每个服务器中都可以有多个数据库。请注意，服务器**并不**表示单个物理机器。
5.  First, select the option for **Server Group** by right-clicking over the **Servers** item, as shown here:

    ![Figure 14.3 – pgAdmin adding a server group ](image/Figure_14.03_B15508.jpg)

    图 14.3–pgAdmin 添加服务器组

6.  Next, create a server by right-clicking on the new **HandsOnFullStackGroup** and selecting **Server**. Then, enter the name `SuperForumServers` on the first screen, as follows:

    ![Figure 14.4 – The Create - Server tab ](image/Figure_14.04_B15508.jpg)

    图 14.4–创建-服务器选项卡

7.  Now, select the second tab, **Connection**, and enter `localhost` as the **Host name/address**. Then enter the password for `postgres`. The Postgres account is the root administrator account, so you need to remember this password. Here's a screenshot of this tab:

    ![Figure 14.5 – The Connection tab ](image/Figure_14.05_B15508.jpg)

    图 14.5–连接选项卡

8.  选择**保存**即可创建您的服务器。您应该看到以下视图：

![Figure 14.6 – View of the new HandsOnFullStackGroup and SuperForumServers ](image/Figure_14.06_B15508.jpg)

图 14.6–新的 HandsOnFullStackGroup 和 SuperForumServers 视图

请注意，这里已经有一个名为**postgres**的数据库。此数据库为空，但可用于存储全局数据。

现在，让我们为应用程序创建数据库。然而，在我们能够做到这一点之前，我们需要创建一个新帐户，专门用于我们的新数据库。使用默认管理员帐户 postgres 不是一个好主意，因为如果它被黑客攻击，它会让攻击者访问我们的整个服务器：

1.  在`pgAdmin`中，右键点击**登录/群组角色**并选择**创建****登录/群组角色**。然后，在**常规**选项卡中，使用`superforumsvc`作为名称。然后，在**定义**选项卡中，设置您自己的密码。接下来，进入**特权**选项卡并**确保**启用登录。其余的可以保留为默认设置。
2.  Next, right-click on the **Databases** item in the view and select **Create** | **Database**. Then, in the **General** tab, use the name `SuperForum` and select **superforumsvc** as **Owner**:

    ![Figure 14.7 – Creating the SuperForum database ](image/Figure_14.07_B15508.jpg)

    图 14.7–创建超级论坛数据库

3.  然后点击**保存**。您的视图现在应显示以下内容：

![Figure 14.8 – New database and user ](image/Figure_14.08_B15508.jpg)

图 14.8–新数据库和用户

极好的我们现在有了一个数据库。如果我们不使用 ORM，我们将不得不经历手动创建表和字段的繁琐过程。但是，正如您将看到的，TypeORM 将我们从繁重的工作中解救出来，并为我们提供了查询数据库的强大语言功能。

在下一节中，我们将深入研究 typeform。我们将了解它是如何工作的，以及它如何在多个层次上帮助我们与数据库交互。

# 使用 TypeORM 理解对象关系映射器

在这一节中，我们将学习什么是**对象关系映射器**（**ORM**技术。我们还将了解 TypeORM，它是最流行的 JavaScript ORM 框架之一。ORM 可以使使用数据库变得更加容易，并减少开发人员的一些认知负荷。

作为程序员，您知道不同的编程语言有不兼容的类型。例如，JavaScript，不管名称如何，都不能直接使用甚至访问 Java 类型。为了让任何一种语言使用另一种语言的类型，我们需要进行某种翻译。在某种程度上，这就是拥有 Web API 等服务的原因。WebAPI 以字符串格式向调用方提供所有数据，如 JSON。这允许任何调用者使用数据，因为它可以被任何语言读取。

数据库到编码语言的转换具有类似的类型不兼容性。因此，通常在进行返回数据的查询之后，我们必须从数据库中获取每个字段的值，并手动编写代码以将其转换为编码语言中的特定类型。然而，如果我们使用 ORM，大部分工作都会消失。

ORM 的设计使其*知道*如何将数据库字段映射到代码字段，并处理翻译工作。此外，大多数 ORM 都具有基于代码中创建的实体结构在数据库上自动创建表和字段的某种能力。您可以将实体视为编码语言端的类型，表示与数据库端的表相似的对象。例如，如果我们在 JavaScript 中有一个名为`User`的实体，那么我们希望数据库中有一个名为`Users`的表来匹配它（它是复数形式，因为一个表包含多个用户）。

仅此功能就可以为开发人员节省大量的时间和精力，但除此之外，一个好的 ORM 还具有帮助构建查询、安全插入参数（减少 SQL 注入攻击的机会）以及处理事务的功能。事务是原子数据库操作，必须全部完成，否则所有涉及的操作都将撤消。

笔记

SQL 注入攻击是恶意人员试图插入与开发人员最初意图不同的 SQL 代码。它可能会导致数据丢失和应用程序失败等问题。

对于我们的应用程序，我们将使用 typeform。TypeORM 是一种流行且评级很高的用于 TypeScript 的 ORM，在 GitHub 上拥有 20000 多个用户。它提供了上面提到的所有功能，并且很容易入门，尽管成为高级用户确实需要付出相当大的努力。它支持多个数据库，包括 Microsoft SQL、MySQL 和 Oracle。

它丰富的功能集将为我们节省大量的时间，而且因为许多 JavaScript 项目都使用 TypeORM，所以如果您在使用它时遇到问题，有大量的开发人员社区可以提供帮助。

在本节中，我们学习了 ORM 技术。我们了解了它是什么，以及它为什么重要和有价值。在下一节中，我们将使用 TypeForm 构建我们自己的项目。让我们开始吧。

# 使用 Postgres 和 TypeORM 构建我们的存储库层

在本节中，我们将了解使用存储库层的重要性。为我们的应用程序的一个大而重要的部分提供一个单独的层可以帮助代码重构变得更容易。这对于理解应用程序的工作原理也很有帮助，因为主要部分在逻辑上是分开的。

在[*第一章*](01.html#_idTextAnchor017)*理解类型脚本*中，我们学习了**面向对象编程**（**OOP**）。实现 OOP 设计的主要机制之一是使用抽象。通过在单独的层中创建数据库访问代码，我们使用了抽象。您可能还记得，抽象的好处之一是它在内部隐藏代码的实现，并向外部调用方公开接口。此外，因为所有与访问数据库相关的代码都在一个地方，所以我们不必到处寻找数据库查询代码。我们知道这段代码位于应用程序的哪一层。使代码在逻辑上保持分离称为关注点分离。

那么，让我们开始构建存储库层：

1.  First, we need to copy our server code that we created in [*Chapter 13*](13.html#_idTextAnchor208), *Setting Up Session State Using Express and Redis*. Go to the `Chapter13` folder in the source code and copy the `super-forum-server` folder into the `Chapter14` folder.

    笔记

    您需要删除`node_modules`文件夹和`package-lock.json`文件，然后使用命令重新运行安装。

    ```
    npm install 
    ```

2.  Next, we need to install TypeORM and its related dependencies. Run the following command:

    ```
    npm i typeorm pg bcryptjs cors class-validator
    npm i @types/pg @types/cors @types/bcryptjs -D
    ```

    通过这个命令，我们已经安装了`typeorm`。`pg`是与博士后沟通的客户。`bcryptjs`是一个加密库，我们将使用它在插入数据库之前对密码进行加密。需要使用`cors`来允许我们接收来自不同域（而非服务器域）的客户端请求。在现代应用程序中，客户端代码可能与服务器端代码不在同一台服务器上。当我们创建一个 API（如 GraphQL）时尤其如此，它可能被多个客户端使用。当我们开始将客户端的 React 应用程序与服务器集成时，您也会看到这一点，因为它们将在不同的端口上运行。

    `class-validator`是分配用于验证的装饰器的依赖项。稍后我们将借助示例对此进行更详细的讨论。

3.  Now, before we can start creating our Entities database, we need to create a configuration file so that our TypeORM code can access our Postgres database. This means that we also have to update our `.env` file with our database configurations. Open the `.env` file and add these variables. Our server was installed locally, so `PG_HOST` has the value `localhost`:

    ```
    PG_HOST=localhost
    ```

    服务器用于通信的端口如下所示：

    ```
    PG_PORT=5432
    ```

    我们的数据库账号名称如下：

    ```
    PG_ACCOUNT=superforumsvc
    ```

    使用您为自己的数据库创建的密码：

    ```
    PG_PASSWORD=<your-password>
    ```

    我们的数据库名称如下：

    ```
    PG_DATABASE=SuperForum
    ```

    正如前面提到的，TypeORM 将为我们创建表和字段，并在它们发生变化时对它们进行维护。`PG_SYNCHRONIZE`启用该功能：

    ```
    PG_SYNCHRONIZE=true
    ```

    当然，一旦投入生产，就必须禁用此功能，以防止不必要的数据库更改。

    我们的实体文件（包括子目录）的位置如下：

    ```
    PG_ENTITIES="src/repo/**/*.*"
    ```

    我们实体的根目录如下所示：

    ```
    PG_ENTITIES_DIR="src/repo"
    ```

    `PG_LOGGING`确定是否在服务器上启用日志记录：

    ```
    PG_LOGGING=false
    ```

    应在生产中启用日志，以便跟踪问题。然而，日志可以创建巨大的文件，所以我们不会在开发中启用它。

4.  Now we can create our TypeORM configuration file. In the root of our project, `Chap13/super-forum-server`, create the file `ormconfig.js` and add this code to it:

    ```
    require("dotenv").config();
    ```

    首先，我们通过要求得到我们的`.env`配置：

    ```
    module.exports = [
      {
        type: "postgres",
    ```

    我们将连接到哪个数据库类型？由于 TypeORM 支持多个数据库，我们需要指出这一点。

    其余的值使用我们的`.env`文件中的配置，因此它们是不言自明的：

    ```
        host: process.env.PG_HOST,
        port: process.env.PG_PORT,
        username: process.env.PG_ACCOUNT,
        password: process.env.PG_PASSWORD,
        database: process.env.PG_DATABASE,
        synchronize: process.env.PG_SYNCHRONIZE,
        logging: process.env.PG_LOGGING,
        entities: [process.env.PG_ENTITIES],
        cli: {
          entitiesDir: process.env.PG_ENTITIES_DIR
        },
      }
    ];
    ```

    现在，我们已经准备好开始创建实体。

5.  Now that we've installed our dependencies and set up the configuration to the database, let's create our first entity, the User. Change the directory to the `Chap14/super-forum-server` folder and then create, inside the `src` folder, a folder called `repo`. We'll place all of our repository code there. Then, create a file inside `repo` called `User.ts` with the following code in it:

    ```
    import { Entity, PrimaryGeneratedColumn, Column } from "typeorm";
    ```

    这些 TypeForm 导入将允许我们创建`User`实体类。`Entity`、`PrimaryGeneratedColumn`和`Column`被称为装饰师。修饰符是放置在相关代码行前面的属性，它提供关于[T6]字段或对象的[T4]附加配置[T5]信息。你可以把它们看作是一条捷径。您可以简单地添加一个设置配置的标记，而不是编写一些长代码行。我们将在此代码中看到示例：

    ```
    import { Length } from "class-validator";
    ```

    这是一个长度验证器。

    接下来是我们第一次使用装饰器。[T0]装饰器告诉 TypeORM 即将定义的类是一个名为[T1]的实体。换句话说，在我们的代码中，将有名为`User`的对象直接映射到名为`Users`的数据库中的表：

    ```
    @Entity({ name: "Users" })
    ```

    在数据库中，每个表都必须有一个唯一的标识字段。这就是`PrimaryGeneratedColumn`所表明的。字段名将为`id`。请注意，`id`中的“”未大写。我们稍后将解决此问题：

    ```
    export class User {
      @PrimaryGeneratedColumn({ name: "id", type: "bigint" })
      id: string;
    ```

    接下来，我们将首次使用`Column`装饰器：

    ```
      @Column("varchar", {
        name: "Email",
        length: 120,
        unique: true,
        nullable: false,
      })
      email: string;
    ```

    正如您所见，它用于定义数据库字段`Email`，在我们的 TypeScript 代码中将被称为`email`。同样，装饰器被用来将代码对象映射到数据库实体。现在，让我们更仔细地检查一下`Column`装饰器。首先，它定义我们的列是`varchar`数据库类型。同样，数据库类型与代码类型不同，如下所示。接下来，我们看到`name`字段，它被设置为`Email`。这将是`Users`表中该字段的确切名称。然后我们有`length`，表示该字段允许的最大字符数。`unique`属性告诉 Postgres 强制每个`User`条目必须有唯一的电子邮件。最后，我们将`nullable`设置为`false`，这意味着该字段在数据库中必须有一个值：

    ```
      @Column("varchar", {
        name: "UserName",
        length: 60,
        unique: true,
        nullable: false,
      })
      userName: string;
      @Column("varchar", { name: "Password", length: 100,   nullable: false })
    @Length(8, 100)
    ```

    在这里，我们使用`Length`修饰符来确保输入的字段具有最小和最大字符长度：

    ```
      password: string;
    ```

    两个字段`userName`和`password`以`varchar`作为列，设置与`email`类似：

    ```
      @Column("boolean", { name: "Confirmed", default: false, 
        nullable: false })
      confirmed: boolean;
    ```

    现在，我们看到一个`confirmed`字段，属于`boolean`类型。`confirmed`字段将显示新注册的用户帐户是否已通过电子邮件验证。注意，这是很自然的，但默认设置表示在将记录插入数据库时，除非明确设置，否则将设置为`false`：

    ```
      @Column("boolean", { name: "IsDisabled", default:     false, nullable: false }) 
      isDisabled: boolean;
    }
    ```

    最后，这里是`isDisabled`字段，它允许我们出于管理目的禁用账户。

6.  Great! Now we can see whether TypeORM will create our new `Users` table on our behalf. The last thing we need to do is connect to the Postgres database from our code. Update `index.ts` like this:

    ```
    import express from "express";
    import session from "express-session";
    import connectRedis from "connect-redis";
    import Redis from "ioredis";
    import { createConnection } from "typeorm";
    require("dotenv").config();
    ```

    我们从 TypeForm 中导入了`createConnection`函数：

    ```
    const main = async () => {
      const app = express();
      const router = express.Router();
    await createConnection();
    ```

    这里，我们已经打电话给`createConnection`。但请注意，我们的代码现在封装在一个名为`main`的函数中，即`async`。我们需要它的原因是`createConnection`是一个`async`呼叫，需要一个`await`前缀。因此，我们需要将其封装在`async`函数中，这就是`main`函数的作用。

    剩余代码相同，如下所示：

    ```
      const redis = new Redis({
        port: Number(process.env.REDIS_PORT),
        host: process.env.REDIS_HOST,
        password: process.env.REDIS_PASSWORD,
      });
      const RedisStore = connectRedis(session);
      const redisStore = new RedisStore({
        client: redis,
      });
      app.use(
        session({
          store: redisStore,
          name: process.env.COOKIE_NAME,
          sameSite: "Strict",
          secret: process.env.SESSION_SECRET,
          resave: false,
          saveUninitialized: false,
          cookie: {
            path: "/",
            httpOnly: true,
            secure: false,
            maxAge: 1000 * 60 * 60 * 24,
          },
        } as any)
    );
    ```

    同样地，代码与相同：

    ```
      app.use(router);
      router.get("/", (req, res, next) => {
        if (!req.session!.userId) {
          req.session!.userId = req.query.userid;
          console.log("Userid is set");
          req.session!.loadedCount = 0;
        } else {
          req.session!.loadedCount = Number(req.session!.       loadedCount) + 1;
        }
        res.send(
          `userId: ${req.session!.userId}, loadedCount: 
            ${req.session!.loadedCount}`
        );
      });
      app.listen({ port: process.env.SERVER_PORT }, () => {
        console.log(`Server ready on port 
         ${process.env.SERVER_PORT}`);
      });
    };
    main();
    ```

    最后，我们调用了`main`函数来执行它。

7.  Now, let's run our application by running the following command:

    ```
    npm start
    ```

    终端上没有任何变化。但是，如果您打开`pgAdmin`并转到**表**视图，您将看到新的`Users`表，其中包含为我们创建的所有列：

    ![Figure 14.9 – New Users table ](image/Figure_14.09_B15508.jpg)

    图 14.9–新用户表

    这是一个巨大的时间节省！你能想象如果我们必须自己手动创建每个表吗？有所有的字段和约束？这需要几个小时。

    请注意我们的专栏的设置与装饰师的设置相同。例如，我们的电子邮件有多种字符，长度为 120，不能为空。

8.  然而，我们有一个小问题。我们的`id`栏不使用大写，即使我们的其他栏也使用大写。让我们来解决这个问题。再次打开`User.ts`文件，只需将`PrimaryGeneratedColumn`修饰符的名称设置更改为`Id`而不是`id`（仅在修饰符中；将`id`字段名称保留在我们的 JavaScript 中）。如果服务器未运行，请重新启动它。但重启后，右键点击**表**视图并选择**刷新**刷新**表**视图。您应该看到我们的`id`栏目已经更新为`Id`。这是 TypeORM 的一个非常好的特性，因为手动更改列名或约束有时会很痛苦。
9.  Great! Now we just need to create our other entities: `Thread` and `ThreadItem`. Again, `Thread` is the initial starting post in our forum and `ThreadItems` are the responses. First, stop your server so that it doesn't create our database items before we're ready. Now, since this is mostly repetitive, I'll just show the code here without comment.

    这两个文件的导入将完全相同，如下所示：

    ```
    import { Entity, PrimaryGeneratedColumn, Column } from "typeorm";
    import { Length } from "class-validator";
    ```

    `Thread`实体目前看起来是这样的（一旦我们建立了表关系，我们将添加更多字段）：

    ```
    @Entity({ name: "Threads" })
    export class Thread {
      @PrimaryGeneratedColumn({ name: "Id", type: "bigint" })
      id: string;
      @Column("int", { name: "Views", default: 0, nullable:    false })
      views: number;
      @Column("boolean", { name: "IsDisabled", default:     false, nullable: false }) 
      isDisabled: boolean;
      @Column("varchar", { name: "Title", length: 150,    nullable: false })
      @Length(5, 150)
      title: string;
      @Column("varchar", { name: "Body", length: 2500,    nullable: true
       })
      @Length(10, 2500)
      body: string;
    }
    ```

    `ThreadItem`看起来像这样：

    ```
    @Entity({ name: "ThreadItems" })
    export class ThreadItem {
      @PrimaryGeneratedColumn({ name: "Id", type: "bigint" })
      id: string;
      @Column("int", { name: "Views", default: 0, nullable:   false })
      views: number;
      @Column("boolean", { name: "IsDisabled", default:    false, nullable: false })
      isDisabled: boolean;
      @Column("varchar", { name: "Body", length: 2500,    nullable: true
       })
      @Length(10, 2500)
      body: string;
    }
    ```

10.  正如您所见，两个实体都非常简单。现在，重新启动服务器，您将看到两个新表：**线程**和**线程项**：

![Figure 14.10 – Threads and ThreadItems ](image/Figure_14.10_B15508.jpg)

图 14.10–螺纹和螺纹项目

我们仍然有许多字段需要添加，例如点列。但首先，让我们在表之间建立一些关系。例如，每个表都应该与特定用户关联。让我们首先添加以下关系：

1.  First, stop your server. Then, in your `User.ts` file, add this to the bottom of your class. I'll assume you know how to add any required imports by now and won't mention them further:

    ```
    @OneToMany(() => Thread, (thread) => thread.user)
      threads: Thread[];
    ```

    `OneToMany`修饰符显示，对于每个`User`个体，都可能有多个`Threads`关联。

2.  Now, add this to the bottom of your `Thread.ts` file's `Thread` class:

    ```
    @ManyToOne(
        () => User,
        (user:User) => user.threads
      )
      user: User;
    ```

    `ManyToOne`装饰符显示多个线程中的每个`Thread`只有一个`User`与之关联。虽然教授 SQL 超出了本书的范围，但简单地说，这些关系对数据库起到了约束作用，这意味着我们被阻止插入毫无意义的数据；例如，有多个`Users`*拥有*一个`Thread`。

3.  Now, let's establish the relationship of our `Thread` to `ThreadItems`. Add this code to the `Thread` class:

    ```
    @OneToMany(
        () => ThreadItem,
        threadItems => threadItems.thread
      )
      threadItems: ThreadItem[];
    ```

    同样，这表明一个`Thread`可以有多个`ThreadItems`与其关联。现在，让我们更新一下我们的`ThreadItem`：

    ```
    @ManyToOne(() => User, (user) => user.threads)
      user: User;
    ```

    一个`ThreadItem`和一个`Thread`一样，只能有一个`User`作为所有者与之关联：

    ```
      @ManyToOne(() => Thread, (thread) => thread.   threadItems)
      thread: Thread;
    ```

4.  每个`ThreadItem`只能有一个父`Thread`。现在，如果您重新启动服务器，您将看到以下新关系：

![Figure 14.11 – Relationships ](image/Figure_14.11_B15508.jpg)

图 14.11–关系

您将在`Threads`和`ThreadItems`表中看到添加了新的列。例如，在`ThreadItems`中，添加了`userId`和`threadId`以表示它们的各自的关系。然而，在表中，没有添加任何内容。这是因为`Users`表与`Threads`表有`OneToMany`关系。因此，该关系由`CREATE TABLE public."Threads"`脚本的图像中显示的约束表示。如您所见，`userId`列有一个约束。因此，通过指示每个线程都有一个与之关联的`User`，它隐式地指示每个`User`可以有一个或多个它所拥有的`Threads`。

现在，让我们建立我们的积分体系。在积分的情况下，即喜欢或不喜欢，我们需要允许用户只能向上或向下投票一次。然而，无法在单个表中表示这一点。因此，我们将创建两个新表，`ThreadPoints`和`ThreadItemPoints`，它们将与相关的`Users`、`Threads`和`ThreadItems`关联。

1.  First, shut down your server and then create the `ThreadPoint.ts` file. Then, add this code to it:

    ```
    @Entity({ name: "ThreadPoints" })
    export class ThreadPoint {
      @PrimaryGeneratedColumn({ name: "Id", type: "bigint" }) 
        // for typeorm
      id: string;
      @Column("boolean", { name: "IsDecrement", default:    false, nullable: false })
      isDecrement: boolean;
      @ManyToOne(() => User, (user) => user.threadPoints)
      user: User;
      @ManyToOne(() => Thread, (thread) => thread.   threadPoints)
      thread: Thread;
    }
    ```

    所以，我们在这段代码中所做的是，这一点是针对特定的`User`和`Thread`。我们还指出，如果`isDecrement`字段是`true`，那么构成厌恶。这意味着点有三种可能的状态：完全没有点、喜欢点或不喜欢点。稍后，我们将在存储库查询中编写一些代码来处理这三种状态。

2.  Now, add this code to the `User.ts` class:

    ```
    @OneToMany(() => ThreadPoint, (threadPoint) => threadPoint.user)
      threadPoints: ThreadPoint[];
    ```

    同样，这段代码完成了代码中的关联。

3.  Next, add the following to the `Thread.ts` class:

    ```
    @OneToMany(() => ThreadPoint, (threadPoint) => 
     threadPoint.thread)
      threadPoints: ThreadPoint[];
    ```

    这也完成了与`ThreadPoint`的关联。

4.  Now, we need to do the same thing for `ThreadItemPoints`. Create `ThreadItemPoint.ts` and add the following code:

    ```
    @Entity({ name: "ThreadItemPoints" })
    export class ThreadItemPoint {
      @PrimaryGeneratedColumn({ name: "Id", type: "bigint" }) 
        // for typeorm
      id: string;
      @Column("boolean", { name: "IsDecrement", default:   false,
       nullable: false })
      isDecrement: boolean;
      @ManyToOne(() => User, (user) => user.threadPoints)
      user: User;
      @ManyToOne(() => ThreadItem, (threadItem) => 
        threadItem.threadItemPoints)
      threadItem: ThreadItem;
    }
    ```

    这是与`ThreadPoint`非常相似的设置。

5.  Now we update our `User` class by adding the following:

    ```
    @OneToMany(() => ThreadItemPoint, (threadItemPoint) => 
     threadItemPoint.user)
      threadItemPoints: ThreadItemPoint[];
    ```

    我们通过添加以下内容来更新`ThreadItem`类：

    ```
    @OneToMany(
        () => ThreadItemPoint,
        (threadItemPoint) => threadItemPoint.threadItem
      )
      threadItemPoints: ThreadItemPoint[];
    ```

    这就完成了与`ThreadItemPoint`相关的关联。

不过我们还没做完。您可以回忆[*第 11 章*](11.html#_idTextAnchor167)*我们将学习的内容——在线论坛应用*我们的线程将有类别，因此我们也需要创建该实体及其关系：

1.  First, create the `ThreadCategory.ts` file and add this code to it:

    ```
    @Entity({ name: "ThreadCategories" })
    export class ThreadCategory {
      @PrimaryGeneratedColumn({ name: "Id", type: "bigint" }) 
        // for typeorm
      id: string;
      @Column("varchar", {
        name: "Name",
        length: 100,
        unique: true,
        nullable: false,
      })
      name: string;
      @Column("varchar", {
        name: "Description",
        length: 150,
        nullable: true,
      })
      description: string;
      @OneToMany(() => Thread, (thread) => thread.category)
      threads: Thread[];
    }
    ```

    `ThreadCategory`的设置与其他实体非常相似。

2.  Now, add this to the `Thread.ts` class:

    ```
    @ManyToOne(() => ThreadCategory, (threadCategory) => 
      threadCategory.threads)
      category: ThreadCategory;
    ```

    当然，这在之间建立了`Thread`和`ThreadCategory`之间的关系。

3.  现在，运行服务器，它应该创建表和关联。

现在我们已经创建了我们需要的实体以及它们的关联。但是，每当我们向数据库添加数据时，我们都希望记录数据的创建或更改时间。然而，实现这一点将在所有实体中创建相同的字段，我们不希望反复编写相同的代码。

既然 TypeScript 允许我们在类中使用继承，那么让我们创建一个基类，它包含我们需要的字段，然后让每个实体从这个基类继承。此外，TypeORM 要求我们的实体从它自己的基类继承，以便能够连接到它的 API。那么，让我们也在自己的基类中添加 TypeORM 基类：

1.  Create a file called `Auditable.ts` and add this code:

    ```
    import { Column, BaseEntity } from "typeorm";
    export class Auditable extends BaseEntity {
      @Column("varchar", {
        name: "CreatedBy",
        length: 60,
        default: () => `getpgusername()`,
        nullable: false,
      })
      createdBy: string;
    ```

    `Getpgusername`是服务账户`superforumsvc`，这是字段的默认值，除非明确设置：

    ```
      @Column("timestamp with time zone", {
        name: "CreatedOn",
        default: () => `now()`,
        nullable: false,
      })
      createdOn: Date;
    ```

    除非明确设置，否则此字段将默认为当前时间和日期`now()`。

    正如您所看到的，这些字段对于它们的作用是不言自明的。但是，请注意，我们的基类`Auditable`也扩展了名为`BaseEntity`的类型化基类。这种`BaseEntity`继承允许我们的实体通过 TypeForm 访问 Postgres 数据库：

    ```
      @Column("varchar", {
        name: "LastModifiedBy",
        length: 60,
        default: () => `getpgusername()`,
        nullable: false,
      })
      lastModifiedBy: string;
      @Column("timestamp with time zone", {
        name: "LastModifiedOn",
        default: () => `now()`,
        nullable: false,
      })
      lastModifiedOn: Date;
    }
    ```

2.  OK, so that's the new `Auditable` base class covered. Now we want to make our entities inherit it. This is simple. For example, in the `User` class, just add the `extends` keyword and add the `Auditable` class like this:

    ```
    export class User extends Auditable {
    ```

    对每个实体重复此过程，然后重新启动服务器（记住根据需要添加导入语句）。刷新视图后，您将看到如下新字段：

![Figure 14.12 – User updated for Auditable ](image/Figure_14.12_B15508.jpg)

图 14.12–可审核的用户更新

令人惊叹的现在我们可以创建存储库，它将实际调用我们的数据库。由于我们在上一章中创建了我们的会话状态，[*第 13 章*](13.html#_idTextAnchor208)*使用 Express 和 Redis*设置会话状态，让我们先创建与身份验证相关的呼叫：

1.  在创建主代码之前，我们需要先做一些事情。您可能还记得[*第 11 章*](11.html#_idTextAnchor167)*我们将学习的内容——在线论坛应用*，我们使用了一个名为`isPasswordValid`的功能来检查用户的密码是否足够长和复杂。我们需要在我们的服务器上重用这些代码，因为正如我当时提到的，验证一般都应该在客户端和服务器上进行。因此，让我们暂时将`PasswordValidator.ts`文件和`common/validators`文件夹结构复制到我们的服务器项目中，稍后我将展示一种跨多个项目共享代码的方法。
2.  Let's also create a validator for email addresses. Create an `EmailValidator.ts` file in the same `common/validators` directory and add this code:

    ```
    export const isEmailValid = (email: string) => {
    if (!email) return "Email cannot be empty";
    ```

    这里，我查过一个空地址。

    ```
      if (!email.includes("@")) {
        return "Please enter valid email address.";
    ```

    在这里，我检查了@符号。

    ```
      }
      if (/\s+/g.test(email)) {
        return "Email cannot have whitespaces";
    ```

    最后，这里我检查了中的空白。

    ```
      }
      return "";
    };
    ```

    如果未发现问题，则返回空的字符串。

3.  Create the `UserRepo.ts` file and add this code:

    ```
    import { User } from "./User";
    import bcrypt from "bcryptjs";
    import { isPasswordValid } from "../common/validators/PasswordValidator";
    import { isEmailValid } from "../common/validators/EmailValidator";
    ```

    首先，我们有我们的进口，包括我们的验证器。

    ```
    const saltRounds = 10;
    ```

    `saltRounds`用于密码加密，您很快就会看到。

    ```
    export class UserResult {
      constructor(public messages?: Array<string>, public    user?:
       User) {}
    }
    ```

    我们将使用`UserResult`类型来指示身份验证期间是否发生错误。如您所见，它基本上是围绕`User`对象的包装器。我们使用这个对象作为函数的返回类型。我们这样做是因为在进行网络呼叫或其他复杂呼叫时，出现问题并不罕见。因此，能够在我们的对象中包含错误或状态消息是有益的。请注意，`messages`和`user`这两个成员是如何可选的。一旦我们开始使用这种类型，它就会派上用场。

    ```
    export const register = async (
      email: string,
      userName: string,
      password: string
    ): Promise<UserResult> => {
    ```

    这是我们`register`功能的开始。

    ```
      const result = isPasswordValid(password);
      if (!result.isValid) {
        return {
          messages: [
            "Passwords must have min length 8, 1 upper          character, 1 number, and 1 symbol",
          ],
        };
      }
      const trimmedEmail = email.trim().toLowerCase();
      const emailErrorMsg = isEmailValid(trimmedEmail);
      if (emailErrorMsg) {
        return {
          messages: [emailErrorMsg],
        };
      }
    ```

    这里，我们运行了两个验证器，`isPasswordValid`和`isEmailValid`。请注意，我们是如何使用对象文字作为返回对象，而不是包含`user`成员的。同样，TypeScript 只关心对象的形状与类型的形状匹配。因此，在这个案例中，由于我们的`UserResult`成员`user`是可选的，我们可以创建一个不包含它的`UserResult`对象。打字脚本非常灵活。

    ```
      const salt = await bcrypt.genSalt(saltRounds);
      const hashedPassword = await bcrypt.hash(password,    salt);
    ```

    在这里，我们使用`saltRounds`常量和`bcryptjs`对密码进行了加密。

    ```
      const userEntity = await User.create({
        email: trimmedEmail,
        userName,
        password: hashedPassword,
      }).save();
    ```

    然后，如果我们通过验证，我们`create`我们的`User`实体，然后立即`save`它。这两种方法都来自 TypeORM，请注意，在对实体数据库进行更改时，您**必须**始终运行`save`功能，否则它将无法在服务器上完成。

    ```
      userEntity.password = ""; // blank out for security
      return {
         user: userEntity
      };
    };
    ```

    然后，我们返回新的实体，再次，因为我们的调用没有错误，所以我们只返回`user`对象，没有任何`messages`。

4.  Let's try this new function, `register`, with a real network call. Update the `index.ts` file like this:

    ```
    import express from "express";
    import session from "express-session";
    import connectRedis from "connect-redis";
    import Redis from "ioredis";
    import { createConnection } from "typeorm";
    import { register } from "./repo/UserRepo";
    import bodyParser from "body-parser";
    ```

    注意我们现在导入`bodyParser`。

    ```
    require("dotenv").config();
    const main = async () => {
      const app = express();
      const router = express.Router();
      await createConnection();
      const redis = new Redis({
        port: Number(process.env.REDIS_PORT),
        host: process.env.REDIS_HOST,
        password: process.env.REDIS_PASSWORD,
      });
      const RedisStore = connectRedis(session);
      const redisStore = new RedisStore({
        client: redis,
      });
      app.use(bodyParser.json());	
    ```

    在这里，我们已经设置了`bodyParser`，所以可以从帖子中读取`json`参数。

    ```
      app.use(
        session({
          store: redisStore,
          name: process.env.COOKIE_NAME,
          sameSite: "Strict",
          secret: process.env.SESSION_SECRET,
          resave: false,
          saveUninitialized: false,
          cookie: {
            path: "/",
            httpOnly: true,
            secure: false,
            maxAge: 1000 * 60 * 60 * 24,
          },
        } as any)
      );
    ```

    所有此代码保持不变：

    ```
      app.use(router);
      router.post("/register", async (req, res, next) => {
        try {
          console.log("params", req.body);
          const userResult = await register(
            req.body.email,
            req.body.userName,
            req.body.password
          );
          if (userResult && userResult.user) {
            res.send(`new user created, userId: ${userResult.         user.id}`);
          } else if (userResult && userResult.messages) {
            res.send(userResult.messages[0]);
          } else {
            next();
          }
        } catch (ex) {
          res.send(ex.message);
        }
      });
    ```

    如您所见，我们删除了之前的`get`路由，并在注册 URL 中将其替换为`post`。此调用现在运行我们的`UserRepo``register`功能，如果成功，则返回带有新用户 ID 的消息。如果未成功，则返回 repo 调用的错误消息。在本例中，我们只使用第一条消息，因为我们将在[*第 15 章*](15.html#_idTextAnchor222)*中删除这些路由并用 GraphQL 替换，*添加 GraphQL 模式–第一部分*：*

    警告

    我们发回的错误仅用于学习目的。您不希望将异常产生的错误消息发送给生产中的用户。这是令人困惑的，在某些情况下，可能会打开您的网站进行攻击。

    ```
      app.listen({ port: process.env.SERVER_PORT }, () => {
        console.log(`Server ready on port
         ${process.env.SERVER_PORT}`);
      });
    };
    main();
    ```

现在我们开始测试。然而，我们需要改用邮递员而不是卷发。Postman是一个免费应用程序，它将允许我们在接受会话 cookie 的同时向服务器发出`GET`和`POST`呼叫。它非常容易使用：

1.  首先，进入[https://www.postman.com/downloads](https://www.postman.com/downloads) 下载并为您的系统安装 Postman。
2.  安装之后，您应该做的第一件事是使用 Postman 在站点的根目录上运行`GET`调用。我在`index.ts`中为根目录创建了一个简单的路由，它将初始化会话及其 cookie。在我们的网站上运行`GET`呼叫，如下所示：

![Figure 14.13 – Running Postman on the root of the site ](image/Figure_14.13_B15508.jpg)

图 14.13–在站点根目录上运行邮递员

这是如何运行相同的`GET`呼叫：

1.  在标有**GET**的顶部选项卡下方，您应该看到左侧的下拉菜单。选择**获取**并添加本地 URL。没有参数，点击**发送**即可。
2.  然后，在左下角，您将看到另一个下拉列表。选择**Cookies**，您应该会看到我们的 cookie 名为**superforum**。

现在您拥有维护会话状态所需的 cookie。因此，我们现在可以继续我们的测试，从开始使用`register`功能：

1.  打开一个新标签，选择**POST**，然后添加 URL`http://localhost:5000/register`。
2.  Click on the **Headers** tab and insert **Content-Type**, as shown here:

    ![Figure 14.14 – Content-Type ](image/Figure_14.14_B15508.jpg)

    图 14.14–内容类型

3.  Now, select the **Body** tab right next to **Headers** and enter the **JSON** shown in *Figure 14.15*. Running this should show the same error result:

    ![Figure 14.15 – Register fail ](image/Figure_14.15_B15508.jpg)

    图 14.15–寄存器失败

    正如您所看到的，我们正在通过和`email`，虽然它是无效的，`userName`和`password`也是无效的。

    但是，这个失败是好的，因为我们已经确认我们的验证是有效的。

4.  Let's fix the password and try again. Update the password to `Test123!@#` and run it again like this:

    ![Figure 14.16 – Trying to register again  ](image/Figure_14.16_B15508.jpg)

    图 14.16–尝试再次注册

    现在您应该看到消息**请输入有效的电子邮件地址**。同样，这是我们想要的，因为显然给出的电子邮件是无效的。

5.  Let's try one more time. Update the email to `test@test.com` and run this:

    ![Figure 14.17 – Successful registration ](image/Figure_14.17_B15508.jpg)

    图 14.17–成功注册

    输出消息**新建用户创建，用户 ID:10**显示我们的用户确实创建并保存了。

    笔记

    当我在准备这本书的过程中做一些测试时，我正在显示一个 ID`10`。ID 字段通常从`1`开始。如果您没有再次看到此结果，请确保您在使用`GET`呼叫时在我们网站的根目录上运行 Postman。

6.  Sweet! That worked! Now, let's look at our `Users` table to check that the user was indeed added:

    ![Figure 14.18 – A new user added to the Users table ](image/Figure_14.18_B15508.jpg)

    图 14.18–添加到用户表的新用户

    您可以通过右键点击`pgAdmin`中的`Users`表并选择`Scripts > SELECT Script`来运行显示的查询。您可以点击顶部的播放按钮来运行脚本。但是，正如您所看到的，我们的用户被插入到数据库中。

7.  Now, let's update `UserRepo` with our `login` function. Add the following code to the end of `UserRepo`:

    ```
    export const login = async (
      userName: string,
      password: string
    ): Promise<UserResult> => {
      const user = await User.findOne({
        where: { userName },
      });
      if (!user) {
        return {
          messages: [userNotFound(userName)],
        };
      }
      if (!user.confirmed) {
        return {
          messages: ["User has not confirmed their        registration email yet."],
        };
      }
      const passwordMatch = await bcrypt.compare(password, 
        user?.password);
      if (!passwordMatch) {
        return {
          messages: ["Password is invalid."],
        };
      }
      return {
        user: user,
      };
    };
    ```

    这里没什么可展示的。我们尝试使用给定的`userName`找到一个用户。如果未找到，则使用名为`userNotFound`的函数发回一条消息，说明未找到`user`。因为稍后我将重用此消息。这是一个简单的函数，所以我在这里不讨论它（在源代码中）。如果找到了用户，那么我们首先看账号是否被确认。如果没有，我们将提供一个错误。接下来，我们使用`bcryptjs`检查他们的密码，因为我们在注册期间使用该工具对其进行加密。如果不匹配，我们也会提供一个错误。如果一切顺利且`user`存在，我们将返回`user`。

8.  Let's try running this as well. Update `index.ts` by adding this new route just below the register route:

    ```
    router.post("/login", async (req, res, next) => {
        try {
          console.log("params", req.body);
          const userResult = await login(req.body.userName, 
            req.body.password);
          if (userResult && userResult.user) {
            req.session!.userId = userResult.user?.id;
            res.send(`user logged in, userId: 
             ${req.session!.userId}`);
          } else if (userResult && userResult.messages) {
            res.send(userResult.messages[0]);
          } else {
            next();
          }
        } catch (ex) {
          res.send(ex.message);
        }
      });
    ```

    这与我们的`register`路线非常相似。但是，这里我们将用户的`id`保存到会话状态，然后使用该会话发回消息。

9.  Let's run this route and see what happens. Again, open a new tab in Postman and run the settings as shown here. **Remember** to add the **Content-Type** header in the **Headers** tab:

    ![Figure 14.19 – Login route ](image/Figure_14.19_B15508.jpg)

    图 14.19–登录路径

    同样，这很好，因为我们的验证正在工作。

10.  Go to your `pgAdmin` and open the same screen you used to run the `SELECT` query to see our first inserted user. Then, run this SQL to update our user's `confirmed` column to be `true`:

    ![Figure 14.20 – Update user's confirmed field ](image/Figure_14.20_B15508.jpg)

    图 14.20–更新用户确认字段

    一旦运行查询，您应该会看到相同的消息，如*图 14.20*所示。

11.  现在，让我们运行 Postman 尝试再次登录：

![Figure 14.21 – Logging in the user ](image/Figure_14.21_B15508.jpg)

图 14.21–登录用户

现在我们的用户可以登录，根据返回的消息，我们可以看到我们的会话状态正在使用中。我已经在源代码中创建了`logout`函数和路由。我不会在这里展示，因为它很简单。

笔记

如果您尝试保存到会话失败，请确保您的 Redis 服务正在运行。

令人惊叹的我们已经走了很长的路。我们现在有了基于工作会话的身份验证，但还没有完成。我们需要创建插入`Threads`和`ThreadItems`的方法，以及检索它们的方法。让我们从`Threads`开始：

1.  Before we create our new `ThreadRepo` repository, let's build a small helper. In `UserRepo`, we had a type called `UserResult` that had an array of messages and a user as members. You'll notice that any repo of `Threads`, `ThreadItems`, and `Categories` will need a similar construction. It should have an array of messages and entities, although the entity returned will be an array of items and not just one.

    这似乎是一个使用类型脚本泛型的好地方，这样我们就可以在所有这些实体中共享一个结果类型。让我们创建一个名为`QueryResult`的新的通用结果对象类型。我们在[*第 2 章*](02.html#_idTextAnchor025)*探索 TypeScript*中学习了 TypeScript 泛型。

    创建一个名为`QueryArrayResult.ts`的文件并将此代码添加到其中：

    ```
    export class QueryArrayResult<T> {
      constructor(public messages?: Array<string>, public    entities?: Array<T>) {}
    }
    ```

    如您所见，它与原始的`UserResult`非常相似。但是，该类型使用`T`类型的泛型来表示我们的任何实体。

    警告

    `pg`依赖项还有一个名为`QueryArrayResult`的类型。导入我们的依赖项时，请确保您导入了我们的文件，而不是[T2]。

2.  Now, let's use this new `QueryArrayResult` type in our `ThreadRepo`. Create a new file, `ThreadRepo.ts`, inside the `repo` folder and add the following code:

    ```
    export const createThread = async (
      userId: string,
      categoryId: string,
      title: string,
      body: string
    ): Promise<QueryArrayResult<Thread>> => {
    ```

    显示的参数是所必需的，因为每个`Thread`必须与关联一个用户和一个类别。但是请注意，`userId`来自我们的课程。

    ```
      const titleMsg = isThreadTitleValid(title);
      if (titleMsg) {
        return {	
          messages: [titleMsg],
        };
      }
      const bodyMsg = isThreadBodyValid(body);
      if (bodyMsg) {
        return {
          messages: [bodyMsg],
        };
      }
    ```

    这里我们验证我们的[T0]和[T1]。

    ```
      // users must be logged in to post
      const user = await User.findOne({
        id: userId,
      });
      if (!user) {
        return {
          messages: ["User not logged in."],
        };
      }
    ```

    在这里，我们使用`userId`提供的会话，并尝试找到匹配的`user`。我们以后需要这个`user`对象来创建新的`Thread`。

    ```
      const category = await ThreadCategory.findOne({
        id: categoryId,
      });
      if (!category) {
        return {
          messages: ["category not found."],
        };
      }
    ```

    这里我们得到一个`category`对象，因为我们需要在创建新`Thread`的过程中再次传递它。

    ```
      const thread = await Thread.create({
        title,
        body,
        user,
        category,
      }).save();
      if (!thread) {
        return {
          messages: ["Failed to create thread."],
        };
      }
    ```

    正如您所看到的，我们通过`title`、`body`、`user`和`category`来创建我们的新`Thread`。

    ```
      return {
        messages: ["Thread created successfully."],
      };
    };
    ```

    我们只返回消息，因为不需要返回实际的对象。此外，就 API 有效负载大小而言，返回不需要的对象是低效的。

3.  在继续之前，我们需要向数据库中添加一些`ThreadCategories`，以便我们可以实际使用`createThread`函数。转到源代码并找到`utils/InsertThreadCategories.txt`文件。将这些`insert`语句复制粘贴到`pgAdmin`的查询屏幕中并运行。这将创建列出的`ThreadCategories`。
4.  Next, we need to add our route for creating `Threads`. Add the following code to `index.ts`:

    ```
    router.post("/createthread", async (req, res, next) => {
        try {
          console.log("userId", req.session);
          console.log("body", req.body);
          const msg = await createThread(
            req.session!.userId, // notice this is from          session!
            req.body.categoryId,
            req.body.title,
            req.body.body
          );
    ```

    在这个超简单调用中，我们将参数传递给`createThread`函数。同样，我们的`userId`来自我们的会话，因为用户应该登录才能发布，然后我们只返回结果消息。

    ```
          res.send(msg);
        } catch (ex) {
          console.log(ex);
          res.send(ex.message);
        }
      });
    ```

5.  Let's try running this route. First, however, run the logout route in Postman. You'll find it on the `http://localhost:5000/logout` URL. I'm sure you can set up Postman yourself now. Once that is done, let's try and run the `createthread` route and hopefully, it should fail validation:

    ![Figure 14.22 – Test createthread route ](image/Figure_14.22_B15508.jpg)

    图 14.22–测试线程路径

    是的，它没有按预期进行验证。

6.  现在，让我们再次登录，以便创建会话。继续和邮递员再做一次，然后再运行`createthread`路线。这一次，它应该处理消息**线程创建成功**。
7.  OK. Now we need two more functions, one to get a single `Thread` by its ID, and another to get all the threads for `ThreadCategory`. Add this code to `ThreadRepo`:

    ```
    export const getThreadById = async (
      id: string
    ): Promise<QueryOneResult<Thread>> => {
      const thread = await Thread.findOne({ id });
      if (!thread) {
        return {
          messages: ["Thread not found."],
        };
      }
      return {
        entity: thread,
      };
    };
    ```

    这个`getThreadById`函数非常简单。它只是基于 ID 查找单个线程。

    ```
    export const getThreadsByCategoryId = async (
      categoryId: string
    ): Promise<QueryArrayResult<Thread>> => {
      const threads = await Thread.   createQueryBuilder("thread")
        .where(`thread."categoryId" = :categoryId`, {       categoryId })
        .leftJoinAndSelect("thread.category", "category")
        .orderBy("thread.createdOn", "DESC")
        .getMany();
    ```

    这个`getThreadsByCategoryId`函数更有趣。`Thread.createQueryBuilder`是 TypeForm 中的一个特殊函数，它允许我们构建更复杂的查询。函数的`thread`参数是一个别名，用于表示查询中的 Threads 表。因此，如果您查看查询的其余部分，例如`where`子句，您可以看到我们使用`thread`作为字段或关系的前缀。`leftJoinAndSelect`函数意味着我们要进行 SQL 左连接，但我们也要返回相关实体，在本例中为`ThreadCategory`，以及结果集。`OrderBy`是非常不言自明的，`getMany`只是指归还所有物品。

    ```
      if (!threads) {
        return {
          messages: ["Threads of category not found."],
        };
      }
      console.log(threads);
      return {
        entities: threads,
      };
    };
    ```

8.  The rest of the code is pretty straightforward. Let's test `getThreadsByCategoryId` as a route. Add this to the `index.ts` file:

    ```
    router.post("/threadbycategory", async (req, res, next) => {
        try {
          const threadResult = await 
           getThreadsByCategoryId(req.body.categoryId);
    ```

    这里，我们已经使用`categoryId`参数对`getThreadsByCategoryId`进行了调用。

    ```
          if (threadResult && threadResult.entities) {
            let items = "";
            threadResult.entities.forEach((th) => {
              items += th.title + ", ";
            });
            res.send(items);
          } else if (threadResult && threadResult.messages) {
            res.send(threadResult.messages[0]);
          }
    ```

    在这个`if else`代码中，我们要么显示所有标题，要么显示错误。

    ```
        } catch (ex) {
          console.log(ex);
          res.send(ex.message);
        }
      });
    ```

9.  [T0]代码的其余部分与以前一样。在你的邮递员客户中运行这个，你应该看到这个。同样，您的身份证号码可能会有所不同：

![Figure 14.23 – Test threadsbycategory route ](image/Figure_14.23_B15508.jpg)

图 14.23–测试螺纹 B 分类路线

我将把`getThreadById`的测试留给你，因为这很容易。同样，源代码在我们的项目存储库中。

`ThreadItems`的代码几乎相同，并且在我们的源代码中。所以，我不会在这里回顾它。现在，我们确实需要一些更多的功能来获取诸如`ThreadCategories`之类的内容，以填充 React 应用程序的`LeftMenu`。我们还需要为我们的`Threads`和`ThreadItems`检索点。我们还需要相关的`Thread`数据用于`UserProfile`屏幕。然而，这些调用将重复我们在本节中学习的许多概念，并且我们必须创建路由，一旦启动 GraphQL 服务器代码，最终将删除这些路由。因此，让我们把这些留给[*第 15 章*](15.html#_idTextAnchor222)*添加 GraphQL 模式——第一部分*，我们也可以开始将后端GraphQL 代码与React 前端集成。

在本节中，我们学习了如何构建一个存储库层，并使用 TypeORM 对 Postgres 进行查询。在下一章中，一旦我们开始集成 GraphQL，我们将重用我们的查询技能，因此这是我们将继续使用的重要知识。

# 总结

在本章中，我们学习了如何建立 Postgres 数据库，以及如何使用 ORM、TypeORM 查询它。我们还学习了如何通过使用存储库层来保持代码的干净分离。

在下一章中，我们将学习如何在服务器上启用 GraphQL。我们还将完成数据库查询，并将后端集成到 React 前端。