Expanding Your Application  

# 扩展应用程序

在本章中，我们将重点介绍更大、更复杂的应用程序，添加如下配方：

*   使用 Redux 管理状态
*   使用 redux thunk 执行异步操作
*   使用 react 路由器添加路由
*   向路由添加授权
*   代码拆分以提高性能

# 介绍

在前两章中，我们了解了如何使用`React`开发 web 应用程序，并努力使其在国际上可用、可供所有人访问，并且具有良好的引导风格。在本章中，我们将添加更多的功能，这是大多数应用程序的典型特征。

# 使用 Redux 管理状态

构建应用程序有什么困难？显然，您可以使用普通的 JS 做任何事情，但是当您试图保持 UI 和应用程序的状态同步时，事情开始变得棘手。你呼叫服务，你得到数据。数据必须反映在多个地方，HTML 元素必须更改、添加或删除，等等，这就是复杂性所在。

到目前为止，我们只处理组件中的状态，您可以继续这样做：顶级组件的状态将包括您需要的所有内容，您可以通过将您需要的所有内容作为道具传递给下面的组件来进行管理。当然，随着应用程序的增长，这将无法很好地扩展。引爆点是什么？`Redux`是一个管理状态的工具，但它自己的开发人员建议，当且仅当您满足以下条件时，才应该使用他们的包，我引用[https://redux.js.org/#before-继续](https://redux.js.org/#before-proceeding-further)：

*   <q class="calibre43">“您有合理数量的数据随时间变化。”</q>
*   <q class="calibre43">“你的国家需要一个单一的真相来源。”</q> 
*   <q class="calibre43">“您发现将所有状态保存在顶级组件中不再足够。”</q>

当然，这些规则并不是很精确，并且考虑到了主观性，所以没有明确的点可以让*有*来使用`Redux`。然而，对于大多数现代大规模应用程序来说，`Redux`可能会派上用场，这是非常安全的，因此在本章的其余部分中，让我们假设这一点。

在这个配方中，我们将安装`Redux`，并开始在`React`中了解如何使用它。

# 准备

首先，我们必须安装两个包：`redux`、状态管理包本身以及使用`Redux`和`React`的`react-redux`绑定。（您可以将`Redux`与其他框架或库一起使用，但本书未介绍这一点。）安装很简单，只需使用`npm`，就像我们之前多次做的那样：

```
npm install redux react-redux --save
```

为了使用`Redux`，我们必须学习几个概念：

*   *存储*：您保存应用程序状态的唯一地方（“单一真相来源”）。您在应用程序开始时全局创建存储，然后将*组件连接到它。连接的组件将在状态更改时重新渲染，它们需要渲染的所有内容都应该来自存储。只能通过操作更新存储。*
*   *动作*：您的组件*向*发送的对象包含您想要的任何新数据。动作总是有一个`type`属性来区分不同的类型和任何其他数据，没有任何限制。动作通常由*动作创建者*创建，以简化编码，并在发送后由还原器处理。
*   *Reducers*：纯函数（意思是，没有副作用！），根据操作中接收到的数据改变应用程序的状态。国家永远不会改变；相反，无论需要什么样的改变，都必须产生一个新的国家。作为旧状态和操作中接收的数据的函数，reducer 生成新状态。

如下图所示：

![](assets/9dd5a133-27e4-4945-a705-a4ac6f449bc2.png)

Data flow in Redux is strictly uni-directional, always following a circular pattern

使用此流循环有助于保持状态和视图同步，因为后者是根据前者生成的，并且对状态的所有更新都会立即导致视图更新。我们已经安装了必要的工具来使用，我们知道我们必须做什么；现在，让我们来看一个实际的例子。

You may want to look at `eslint-plugin-redux`, which gives you some rules for how to get the best out of `Redux`. Check it out at [https://github.com/DianaSuvorova/eslint-plugin-react-redux](https://github.com/DianaSuvorova/eslint-plugin-react-redux), and if you're interested, add some or all of its rules to your `ESLint` configuration; by default, they are all disabled.

在这个食谱中，让我们做一个简单的例子来展示上一节中的大部分概念。在阅读了网上的多篇文章和教程后，我认为必须提供一些涉及计数器的示例，我们不要打破这个传统，在这里也这样做！我们想有一个计数器，我们可以通过点击一些按钮来修改，我们还想知道我们点击了多少次。

# 怎么做。。。

在我们开始编写代码之前，让我们先公开一下：如果没有`Redux`，我们将编写太多的代码行*而不需要*`Redux`——我们不会有*合理数量的数据随着时间*而变化，但只有几个计数，我们当然不会*发现将您的所有状态保存在顶级组件*中还不够好，但是因为我们需要一个简单的初始示例，所以我们将使用`Redux`。

# 定义动作

首先，我们需要一些行动。我们需要递增和递减计数器，还需要将其重置为零。前两个需求可以通过一个动作来实现（递减就是增加一个负数），因此我们需要两个动作，每个动作由一个常量标识：

```
// Source file: src/counterApp/counter.actions.js

/* @flow */

export const COUNTER_INCREMENT = "counter:increment";
export const COUNTER_RESET = "counter:reset";

export type CounterAction = {
    type: string,
    value?: number
};

export const reset = () =>
    ({
        type: COUNTER_RESET
    }: CounterAction);

export const increment = (inc: number) =>
    ({
        type: COUNTER_INCREMENT,
        value: inc
    }: CounterAction);

export const decrement = (dec: number) =>
    ({
        type: COUNTER_INCREMENT,
        value: -dec
    }: CounterAction);

// *returning increment(-dec) would have worked as well*
```

事实上，我们应该说`increment()`、`decrement()`和`reset()`是动作创造者；实际操作是这些函数返回的值。

# 写减速机

然后，在定义了我们的动作之后，我们需要一个减速器来处理它们。当然，这也意味着我们必须定义状态的形状及其初始值：

```
// Source file: src/counterApp/counter.reducer.js

/* @flow */

import { COUNTER_INCREMENT, COUNTER_RESET } from "./counter.actions";

import type { CounterAction } from "./counter.actions.js";

export const reducer = (
 state = {
 // *initial state*
 count: 0,
 clicks: 0
 },
    action: CounterAction
) => {
    switch (action.type) {
        case COUNTER_INCREMENT:
            return {
                count: state.count + action.value,
                clicks: state.clicks + 1
            };

        case COUNTER_RESET:
            return { count: 0, clicks: state.clicks + 1 };

        default:
            return state;
    }
};
```

我们的减速机基本上是一个开关语句；当找到正确的类型时，将返回一个新状态。这个模式非常重要，是`Redux`的关键。我们不只是更新状态，而是每次都生成一个新的状态对象。我们需要一个默认情况，因为操作被传递给所有的简化程序（不是在我们的情况下，因为我们只有一个简化程序），所以简化程序可能会忽略一个操作。

In our example, we have a single reducer and a single set of actions, so it can be argued that they could all be placed together in the same file, but that's not likely with most applications. Furthermore, if your state grows too large, check out `combineReducers()` at [https://redux.js.org/api/combinereducers](https://redux.js.org/api/combinereducers), and you'll be able to work in a more organized way, with multiple reducers and a store divided into logical pieces.

# 定义存储

然后，在前面所有的定义之后，我们可以定义我们的商店：

```
// Source file: src/counterApp/store.js

/* @flow */

import { createStore } from "redux";

import { reducer } from "./counter.reducer.js";

export const store = createStore(reducer);
```

顺便说一句，也可以通过将其作为第二个参数传递给`createStore()`来定义状态的初始值。

# 构建我们的组件

最后，在完全定义了我们的存储以及将要调度的操作和将处理它们的缩减器之后，我们可以通过定义组件快速完成。我们的`Counter`组件将包含文本、计数器值和几个按钮。请注意，我们正在接收`count`（计数器值）作为一个道具，我们还有一个`dispatch()`函数作为另一个道具：

```
// Source file: src/counterApp/counter.component.js

/* @flow */

import React from "react";
import { PropTypes } from "prop-types";

import {
    increment,
    decrement,
    reset,
    CounterAction
} from "./counter.actions.js";

export class Counter extends React.PureComponent<{
    count: number,
    dispatch: CounterAction => any
}> {
    static propTypes = {
        count: PropTypes.number.isRequired,
        dispatch: PropTypes.func.isRequired
    };

    onAdd1 = () => this.props.dispatch(increment(1));
    onSub2 = () => this.props.dispatch(decrement(2));
    onReset = () => this.props.dispatch(reset());

    render() {
        return (
            <div>
                Value: {this.props.count}
                <br />
                <button onClick={this.onAdd1}>Add 1</button>
                <button onClick={this.onSub2}>Subtract 2</button>
                <button onClick={this.onReset}>Reset</button>
            </div>
        );
    }
}
```

每个按钮都分派一个由我们前面看到的动作创建者创建的动作

我们需要第二个组件。`ClicksDisplay`组件更简单！我们收到`clicks`的总数作为道具，我们只需显示它：

```
// Source file: src/counterApp/clicksDisplay.component.js

/* @flow */

import React from "react";
import { PropTypes } from "prop-types";

export class ClicksDisplay extends React.PureComponent<{
    clicks: number
}> {
    static propTypes = {
        clicks: PropTypes.number.isRequired
    };

    render() {
        return <div>Clicks so far: {this.props.clicks}</div>;
    }
}
```

# 将组件连接到存储

一个好的设计规则，分离关注点，指出您不应该直接将组件连接到存储，而是应该创建一个新的组件，一个连接的组件，它将从存储中获得所需的一切并将其传递给原始组件。例如，这条规则将简化我们的所有测试：我们的基本组件仍将通过道具接收所有内容，我们不必为了测试它们而对商店进行任何模拟或类似的操作。

A good article on defining components, by Dan Abramov, is *Presentational and Container Components*, at [https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0](https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0). More on this can be found in *Container Components*, at [https://medium.com/@learnreact/container-components-c0e67432e005](https://medium.com/@learnreact/container-components-c0e67432e005).

因此，根据这条规则，对于我们想要连接的每个组件，我们将添加一个新的连接版本。在我们的例子中，连接的计数版本如下，因此组件的`count`道具将接收`state.count`值：

```
// Source file: src/counterApp/counter.connected.js

/* @flow */

import { connect } from "react-redux";

import { Counter } from "./counter.component";

const getProps = state => ({ count: state.count });

export const ConnectedCounter = connect(getProps)(Counter);
```

同样，显示点击总数的组件将以类似方式连接：

```
// Source file: src/counterApp/clicksDisplay.connected.js

/* @flow */

import { connect } from "react-redux";

import { ClicksDisplay } from "./clicksDisplay.component";

const getProps = state => ({
 clicks: state.clicks
});

export const ConnectedClicksDisplay = connect(getProps)(ClicksDisplay);
```

我们将把这些连接的组件放在主代码中，它们将从存储中获取值，并将它们传递给我们的原始组件，这些组件将完全不变。

# 定义主页面

最后一段代码基于`create-react-app`生成的标准`App.js`文件；`App`类由`index.js`导入：

```
// Source file: src/App.counter.js

/* @flow */

import React, { Component, Fragment } from "react";
import { Provider } from "react-redux";

import { store } from "./counterApp/store";
import { ConnectedCounter, ConnectedClicksDisplay } from "./counterApp";

class App extends Component<{}> {
    render() {
        return (
 <Provider store={store}>
                <Fragment>
                    <ConnectedCounter />
                    <hr />
                    <ConnectedClicksDisplay />
                </Fragment>
 </Provider>
        );
    }
}
```

这里的关键部分是`<Provider>`组件。这是`React`最新`Context`功能的一部分（参见[https://reactjs.org/docs/context.html](https://reactjs.org/docs/context.html) 获取更多信息），并允许以下任何组件访问`store`对象；`connect()`函数（我们在上一节中使用）使用它为这些组件提供道具，并订阅它们的更改。顺便说一下，我们在这里使用`Fragment`，只是因为`Provider`需要一个元素。除此之外，`<div>`也可以发挥作用。

把所有东西放在一起，让我们看看这是怎么回事！

# 它是如何工作的。。。

启动应用程序时，当前状态计数为零，单击次数也为零，因此屏幕如下所示：

![](assets/ec2ddcd2-4e51-4d4e-b062-0ab272acab79.png)

Our counter application in its initial state.

单击以下按钮后，值和单击次数会更新，视图会在发生更改时自动反映这些更改；请参见下面的屏幕截图。确保了解所有事情是如何发生的：

*   无论何时单击按钮，都会调度一个操作。
*   当减速器处理动作时，它会创建一个新状态。
*   当`React`看到状态更改时，它会重新绘制您的应用程序。请看以下屏幕截图：

![](assets/b13fdefc-caf6-40d0-873a-590d502d2f98.png)

After every click, the counter value and the number of clicks get automatically updated, and the view is re-rendered

因此，我们已经看到，我们可以与`Redux`合作，以保持全局状态，并在需要时重新呈现视图，而无需我们额外的工作。现在，让我们考虑一个常见的问题：例如，当我们做 Ajax 调用时，我们将如何处理异步更改？

# 另见

`Redux`不是唯一可以与`React`一起使用的状态管理包。最受欢迎的当然是`MobX`，它添加了反应式编程概念，如可观察对象和数组；请点击[查看 https://github.com/mobxjs/mobx](https://github.com/mobxjs/mobx) 。它的基本模式与`Redux`模式大不相同，在许多方面更简单，更类似于电子表格；然而，在使用它之前，要准备好改变你的思维方式！

# 使用 redux thunk 执行异步操作

我们如何执行异步操作，例如调用 web 服务？这种调用需要一些不同的处理：如果我们仍在等待 Ajax 调用的结果，就不能只发送一个操作。`Redux`*thunk*中间件允许您编写一个动作创建者，该创建者返回函数而不是动作；函数可以访问存储内容和分派函数本身，然后可以执行异步调用、分派其他函数等等。

It seems that the origin of the **thunk** word comes from a very late programming session, in which, after many hours of work, a solution to a problem was found that had been *thought before*, and *thunk* became its name as a derivative of *think*, make of it what you will!

这听起来有点神秘，所以让我们深入了解一下它是如何工作的，我们在[第 6 章](06.html)*中*定义组件*一节中构建了一个国家/地区组件**与 React*一起开发，只是这次我们将处理实际的 API 调用，我们已经有了我们在[第 4 章](04.html)中创建的`Node`服务器，*通过节点*实现 RESTful 服务。

# 怎么做…

让我们修改我们的区域应用程序，使其连接到后端服务。

首先，要使用`redux-thunk`，我们必须安装软件包：

```
npm install redux-thunk --save
```

然后，我们必须修改存储以使用新的中间件。（我们将在本章后面以及下一章中看到更多中间件。）此更改非常小，如下代码所示：

```
// Source file: src/regionsApp/store.js

/* @flow */

import { createStore, applyMiddleware } from "redux";
import thunk from "redux-thunk";

import { reducer } from "./worlds.reducer.js";

export const store = createStore(reducer, applyMiddleware(thunk));
```

# 定义行动

每当您尝试从服务获取数据时，一种常见模式如下：

*   *执行请求*时触发动作；此操作可能会设置一些标志，这些标志将被某些组件用来显示“正在加载…”文本或旋转图标，以显示正在发生的事情，用户应该等待
*   *如果服务请求*成功，则触发一个表示此成功的操作，重置*加载。。。*标志，并提供必须添加到存储的新数据
*   *如果服务请求*失败，则重置*加载。。。*标志，但在某些方面存在信号错误

我们的应用程序所需的操作首先是获取国家下拉列表中的国家列表，其次是获取给定国家的区域列表。行动如下：；首先，以下是与国家有关的问题：

```
// Source file: src/regionsApp/world.actions.js

/* @flow */

// Countries actions

export const COUNTRIES_REQUEST = "countries:request";
export const COUNTRIES_SUCCESS = "countries:success";
export const COUNTRIES_FAILURE = "countries:failure";

export type CountriesAction = {
    type: string,
    country?: string,
    listOfCountries?: [object]
};

export const countriesRequest = () =>
    ({
        type: COUNTRIES_REQUEST
    }: CountriesActions);

export const countriesSuccess = (listOfCountries: []) =>
    ({
        type: COUNTRIES_SUCCESS,
        listOfCountries
    }: CountriesActions);

export const countriesFailure = () =>
    ({
        type: COUNTRIES_FAILURE
    }: CountriesActions);

// *continues...*
```

对于区域，我们有一个类似的集合：

```
// *...continued*

// *Regions actions*

export const REGIONS_REQUEST = "regions:request";
export const REGIONS_SUCCESS = "regions:success";
export const REGIONS_FAILURE = "regions:failure";

export type RegionsAction = {
    type: string,
    listOfRegions?: [object]
};

export const regionsRequest = (country: string) =>
    ({
        type: REGIONS_REQUEST,
        country
    }: RegionsActions);

export const regionsSuccess = (listOfRegions: [{}]) =>
    ({
        type: REGIONS_SUCCESS,
        listOfRegions
    }: RegionsActions);

export const regionsFailure = () =>
    ({
        type: REGIONS_FAILURE
    }: RegionsActions);
```

注意我们使用的动作常数的样式`"countries"`和`"regions"`作为一种名称空间（如`"countries:success"`和`"regions:success"`中的名称空间），以避免可能的名称重复

# 写减速机

我们有行动；现在，我们需要一个减速器。其代码也不复杂：

```
// Source file: src/regionsApp/world.reducer.js

/* @flow */

import {
    COUNTRIES_REQUEST,
    COUNTRIES_SUCCESS,
    COUNTRIES_FAILURE,
    REGIONS_REQUEST,
    REGIONS_SUCCESS,
    REGIONS_FAILURE
} from "./world.actions";

import type { CountriesAction, RegionsAction } from "./world.actions";

// import type { CounterAction } from "./world.actions.js";

export const reducer = (
    state: object = {
        // initial state
        loadingCountries: false,
        currentCountry: "",
        countries: [],
        loadingRegions: false,
        regions: []
    },
    action: CountriesAction | RegionsAction
) => {
    switch (action.type) {
        case COUNTRIES_REQUEST:
            return {
                ...state,
                loadingCountries: true,
                countries: []
            };

        case COUNTRIES_SUCCESS:
            return {
                ...state,
                loadingCountries: false,
                countries: action.listOfCountries
            };

        case COUNTRIES_FAILURE:
            return {
                ...state,
                loadingCountries: false,
                countries: []
            };

        case REGIONS_REQUEST:
            return {
                ...state,
                loadingRegions: true,
                currentCountry: action.country,
                regions: []
            };

        case REGIONS_SUCCESS:
            return {
                ...state,
                loadingRegions: false,
                regions: action.listOfRegions
            };

        case REGIONS_FAILURE:
            return {
                ...state,
                loadingRegions: false,
                regions: []
            };

        default:
            return state;
    }
};
```

唯一需要注意的是以下代码样式，以您以前从未见过的方式使用 spread 运算符：

```
    return {
 ...state,
        loadingCountries: true,
        currentCountry: "",
        countries: []
    };
```

在返回新状态时必须小心，以免丢失旧状态的一部分，因此以`...state`开始对象是一种非常常见的编码模式

To avoid accidentally changing the state, a good solution is to handle state with packages such as `immutable-js` (at [https://github.com/facebook/immutable-js/](https://github.com/facebook/immutable-js/)) or `seamless-immutable` (at [https://github.com/rtfeldman/seamless-immutable](https://github.com/rtfeldman/seamless-immutable)), because then you aren't able to modify the state object; you are forced to produce a new one, avoiding many hard-to-find mistakes.

# 修改国家/地区下拉列表

我们之前有一个国家下拉列表，其中有一个国家列表。让我们重写它，这样如果没有提供这样的列表，它将使用一个函数调用 thunk，并从我们的服务器获取国家：

```
// Source file: src/regionsApp/countrySelect.component.js

/* @flow */

import React from "react";
import PropTypes from "prop-types";

import "../general.css";

export class CountrySelect extends React.PureComponent<{
    dispatch: ({}) => any
}> {
    static propTypes = {
 loading: PropTypes.bool.isRequired,
        list: PropTypes.arrayOf(PropTypes.object).isRequired,
        onSelect: PropTypes.func.isRequired,
 getCountries: PropTypes.func.isRequired
    };

    componentDidMount() {
 if (this.props.list.length === 0) {
 this.props.getCountries();
 }
    }

    onSelect = (e: { target: HTMLOptionElement }) =>
        this.props.onSelect(e.target.value);

    render() {
        if (this.props.loading) {
            return <div className="bordered">Loading countries...</div>;
        } else {
            const sortedCountries = [...this.props.list].sort(
                (a, b) => (a.countryName < b.countryName ? -1 : 1)
            );

            return (
                <div className="bordered">
                    Country:&nbsp;
                    <select
                        onChange={this.onSelect}
                        onBlur={this.onSelect}
                    >
                        <option value="">Select a country:</option>
                        {sortedCountries.map(x => (
                            <option
                                key={x.countryCode}
                                value={x.countryCode}
                            >
                                {x.countryName}
                            </option>
                        ))}
                    </select>
                </div>
            );
        }
    }
}
```

正如我们在`.componentDidMount()`方法中看到的，如果没有可用的列表，我们调用一个函数（我们很快就会看到）来获取该列表，并将其放入存储中。将使用一个`loading`属性，因此当我们等待国家/地区到达时，将显示一个`Loading countries...`文本，而不是一个空的`<select>`组件。您还会注意到我对国家/地区进行了排序，因为服务会按国家/地区代码发送它们。

这个组件的连接版本不像以前那么短，因为我们必须将道具连接到商店，也连接到要调度的操作；我在以下代码片段中突出显示了这些代码部分：

```
// Source file: src/regionsApp/countrySelect.connected.js

/* @flow */

import { connect } from "react-redux";

import { CountrySelect } from "./countrySelect.component";
import { getCountries, getRegions } from "./world.actions";

const getProps = state => ({
 list: state.countries,
 loading: state.loadingCountries
});

const getDispatch = dispatch => ({
 getCountries: () => dispatch(getCountries()),
 onSelect: c => dispatch(getRegions(c))
});

export const ConnectedCountrySelect = connect(
    getProps,
    getDispatch
)(CountrySelect);
```

# 修改区域表

由于大多数新行为将出现在国家/地区下拉组件中，我们可以使用一个非常简单的表：

```
// Source file: src/regionsApp/regionsTable.component.js

/* @flow */

import React from "react";
import PropTypes from "prop-types";

import "../general.css";

export class RegionsTable extends React.PureComponent<{
    list: Array<{
        regionCode: string,
        regionName: string
    }>
}> {
    static propTypes = {
        list: PropTypes.arrayOf(PropTypes.object).isRequired
    };

    static defaultProps = {
        list: []
    };

    render() {
        if (this.props.list.length === 0) {
            return <div className="bordered">No regions.</div>;
        } else {
            const ordered = [...this.props.list].sort(
                (a, b) => (a.regionName < b.regionName ? -1 : 1)
            );

            return (
                <div className="bordered">
                    {ordered.map(x => (
                        <div key={x.countryCode + "-" + x.regionCode}>
                            {x.regionName}
                        </div>
                    ))}
                </div>
            );
        }
    }
}
```

我们还按照字母顺序对区域进行排序，只创建一个简单的`<div>`列表，每个列表都有一个区域的名称。连接的组件可以访问区域列表和加载标志，以便在从服务器获取区域列表时显示某些内容：

```
// Source file: src/regionsApp/regionsTable.connected.js

/* @flow */

import { connect } from "react-redux";

import { RegionsTable } from "./regionsTable.component";

const getProps = state => ({
 list: state.regions,
 loading: state.loadingRegions
});

export const ConnectedRegionsTable = connect(getProps)(RegionsTable);
```

# 设置主应用程序

我们拥有所有必要的组件，因此现在可以生产我们的应用程序。（不，我没有忘记承诺的函数！）我们的主要代码如下：

```
// Source file: src/App.regions.js

/* @flow */

import React, { Component, Fragment } from "react";
import { Provider } from "react-redux";

import {
    ConnectedCountrySelect,
    ConnectedRegionsTable
} from "./regionsApp";

import { store } from "./regionsApp/store";

class App extends Component<{}> {
    render() {
        return (
            <Provider store={store}>
                <Fragment>
                    <ConnectedCountrySelect />
                    <ConnectedRegionsTable />
                </Fragment>
            </Provider>
        );
    }
}

export default App;
```

# 使用 thunks

现在，事情开始变得有趣起来。我们为国家/地区下拉列表提供了两个功能，这两个功能都将与 thunks 一起工作，以便连接到服务器。让我们看看他们！

我们需要两个功能：一个用于获取国家列表，另一个用于获取当前选定国家的地区。让我们从前者开始，并记住，此代码将添加到前面看到的操作文件中：

```
// Source file: src/regionsApp/world.actions.js

import axios from "axios";

export const getCountries = () => async dispatch => {
    try {
        dispatch(countriesRequest());
        const result = await axios.get(`http://fk-server:8080/countries`);
        dispatch(countriesSuccess(result.data));
    } catch (e) {
```

```
        dispatch(countriesFailure());
    }
};
```

首先，我们的`getCountries()`函数的签名有点奇怪（一个返回异步函数的函数，带有`dispatch`参数），但这正是`redux-thunk`所需要的。逻辑更有趣：

*   首先，我们发送`countriesRequest()`操作创建者的结果，因此应用程序的状态将显示我们正在等待一些结果。
*   然后，我们使用`axios()`包，正如前面在节点工作中使用的一样，调用服务器并获取国家列表。
*   如果呼叫成功，我们将发送一个`countriesSuccess()`行动，将我们收到的国家列表传递给它。
*   如果调用失败，我们将发送一个`countriesFailure()`操作，以显示失败。

正如您所看到的，我们的代码能够分派许多操作，但要等到适当的时候才能这样做

要使用区域，我们将使用类似的代码：

```
// Source file: src/regionsApp/world.actions.js

export const getRegions = (country: string) => async dispatch => {
    if (country) {
        try {
            dispatch(regionsRequest());
            const result = await axios.get(
                `http://fk-server:8080/regions/${country}`
            );
            dispatch(regionsSuccess(result.data));
        } catch (e) {
            dispatch(regionsFailure());
        }
    } else {
        dispatch(regionsFailure());
    }
};
```

代码与我们以前的代码非常相似，因此我们不需要做太多分析

# 它是如何工作的…

当我们`npm start`应用程序时，我们看到一个非常简单的设计；请参见下面的屏幕截图。让我们了解一下我们是如何来到这里的：

1.  显示主页。
2.  “国家”下拉列表在收到空的国家列表时，使用“砰”一声获取所有国家。
3.  发出了一个`getCountries()`行动。
4.  减速器更新了存储，将`loadingCountries`标志设置为 true
5.  页面被重新绘制，并显示`"Loading countries..."`文本，而不是下拉列表。
6.  当国家名单回来时，发出了一个`countriesSuccess()`行动，并附有收到的国家名单。
7.  减速机更新存储以包括所有国家/地区，并将`loadingCountries`重置为 false。
8.  该页面已重新绘制，现在“国家”下拉列表中有一个要显示的国家列表，如下屏幕截图所示：

![](assets/ccb95d6f-41ff-4fec-976e-b6b0d1166649.png)

Our initial screen

如果我们选择一个国家，将调用该服务，并显示结果；请参见下面的屏幕截图。其逻辑也很有趣：

1.  当绘制没有任何区域的区域表时，会显示一些`"No regions"`文本。
2.  当用户选择一个国家时，下拉列表使用 thunk 获取其地区。
3.  发出了一个`regionsRequest()`行动。

4.  当这些地区回来时，发出了一个`regionsSuccess()`行动，
5.  在 reducer 创建了一个新状态后，页面被重新绘制，显示了区域列表。请参阅以下屏幕截图：

![](assets/d5d2b52b-d1fc-4261-8fd0-effd7607882a.png)

The results of calling our restful server

然而，你可能想知道，`"Loading countries..."`文本在哪里？问题是（如果你想这么说的话！）服务响应来得太快，所以消息会闪过并消失。如果我们作弊并在`getCountries()`函数中添加一些延迟，我们可以看到更长的时间。在调用`axios()`延迟执行 5 秒之前，包括以下行：

```
await new Promise(resolve => setTimeout(resolve, 5000));
```

现在，您将有时间查看缺失状态，如以下屏幕截图所示：

![](assets/5a8870bb-c738-434e-b3dd-2d74b36e3c7f.png)

Adding some delay lets us see what's displayed while waiting for the list of countries

所以，现在我们可以看到我们的状态处理是正确的，并且所有的东西都按照我们想要的方式显示！

# 还有更多…

当您编写动作创建者时，它实际上不仅传递了`dispatch()`，而且传递了`getState()`函数。此函数可用于访问当前状态值。我们没有使用它，但是，例如，您可以为缓存或其他类似想法使用它。我们的`getRegions()`功能可以如下，检测您是否再次请求同一国家的地区：

```
// Source file: src/regionsApp/world.actions.js

export const getRegions2 = (country: string) => async (
 dispatch,
 getState
) => {
 if (country === getState().currentCountry) {
 console.log("Hey! You are getting the same country as before!");
 }

    if (country) {
        .
        .
        . *everything as earlier*
        .
        .
    }
};
```

在我们的例子中，除了记录消息之外，我们不做任何事情，但是您可以使用接收到的参数加上当前状态内容来执行一些更复杂的逻辑。

# 使用 react 路由器添加路由

当您使用`React`（与其他前端框架一样，例如`Angular`或`Vue`，仅举几个例子）时，您通常会开发**单页应用程序**（**SPA**），当您访问它们的不同部分时，不会重新加载整个页面；相反，新内容被交换到视图中，但保留在原始页面上。即使这种导航体验是现代的、流动的，但更传统的路由也会有一些方面：根据您的浏览故事，*后退*和*前进*按钮会让您移动，您还应该能够为应用程序的特定部分添加书签，以便以后能够快速返回。

与往常一样，使用`React`有很多方法来处理路由，但`react-router`是目前使用最多的库，可能是因为它确实符合`React`范式：路由只是您渲染和按预期工作的组件！让我们首先构建一个简单的应用程序来展示路由是如何工作的，在下一节中，我们将通过在允许访问某些路由之前要求身份验证来增加一点复杂性。

# 开始

`react-router`库实际上是处理`React`应用程序内路由的标准。安装它需要一个微妙的区别：不是直接获得该软件包，而是必须选择一个不同的软件包`react-router-dom`，它本身将负责获得`react-router`：

```
npm install react-router-dom --save
```

我们可以很容易地构建一个具有多个链接的应用程序，一个路由器，它将负责呈现正确的视图，甚至一个 404 页面来显示错误的链接。当然，我们将重点关注路由方面，因此换句话说，我们的应用程序将更多地是一个框架，而不是一个实际可用的网页，并且不会开始使用非常简单的样式！

# 怎么做…

在这个配方中，我们将创建一个基本的应用程序，但有几个路由；让我们看看如何。

首先，我们需要导入一些包，并创建几个组件来表示应用程序中的不同页面。对于后者，由于我们不打算包含任何实际的逻辑或内容，我们将使用非常简单的功能组件来呈现单个`H1`标题。。。我告诉过你我们的申请会很简单！

```
// Source file: src/App.routing.js

/* @flow */

import React, { Component } from "react";
import { Provider } from "react-redux";
import { BrowserRouter, Switch, Route, Link } from "react-router-dom";

import { store } from "./routingApp/store";

const Home = () => <h1>Home Sweet Home</h1>;
const Help = () => <h1>Help! SOS!</h1>;
const Alpha = () => <h1>Alpha</h1>;
const Bravo = () => <h1>Bravo</h1>;
const Charlie = () => <h1>Charlie</h1>;
const Zulu = () => <h1>Zulu</h1>;
const Error404 = () => <h1>404 Error!</h1>;

// *continued...*
```

现在，为了继续，我们必须规划我们的应用程序。我们将有一个带有`<nav>`条的`<header>`，其中我们将包含指向应用程序各部分的链接。在下面，我们将有一个公共区域，其中将渲染正确的组件。我们的`<App>`组件可能如下所示，但在现实生活中，您可能会在单独的文件中定义所有路由；为了简洁起见，我将所有内容都放在这里：

```
// *...continued*

class App extends Component<{}> {
    render() {
        return (
            <Provider store={store}>
 <BrowserRouter>
                    <div>
                        <header>
                            <nav>
                                <Link to="/">Home</Link>&nbsp;
                                <Link to="/about/routing">
                                    About Routing
                                </Link>&nbsp;
                                <Link to="/alpha">Alpha...</Link>&nbsp;
                                <Link to="/bravo">Bravo...</Link>&nbsp;
                                <Link to="/charlie">Charlie...
                                </Link>&nbsp;
                                <Link to="/wrong">...Wrong...
                                </Link>&nbsp;
                                <Link to="/zulu">Zulu</Link>&nbsp;
                                <Link to="/help">Help</Link>&nbsp;
                            </nav>
                        </header>

                        <Switch>
                            <Route path="/" component={Home} />
                            <Route path="/help" component={Help} />
 <Route
 path="/about/:something"
 render={props => (
 <div>
 <h1>About...</h1>
 {props.match.params.something}
 </div>
 )}
 />
                            <Route path="/alpha" component={Alpha} />
                            <Route path="/bravo" component={Bravo} />
                            <Route path="/charlie" component={Charlie} 
                            />
                            <Route path="/zulu" component={Zulu} />
                            <Route component={Error404} />
                        </Switch>
                    </div>
                </BrowserRouter>
            </Provider>
        );
    }
}

export default App;
```

我强调了代码的几个部分；让我们看看原因：

*   `<BrowserRouter>`是一个基于 HTML5“历史”API 的组件，负责保持您的视图与 URL 同步；后者的变化将通过一种新的观点反映出来。

*   `<Link ...>`是您必须使用的组件，而不是通常的`<a ...>`HTML 标记，`to=`指向所需的路径。
*   `<Switch>`是一个组件，用于渲染第一个子`<Route>`或`<Redirect>`组件（我们将很快使用`<Redirect>`来），该组件恰好与当前位置匹配
*   `<Route ...>`定义匹配路径时必须渲染的组件。请注意，您可能必须精确指定，以避免错误的巧合；否则，访问`"/alpha"`将与第一条路线`"/"`匹配，并显示错误的组件。您可以通过使用`component=`或提供`render()`功能来指定要呈现的内容；当需要显示多个组件或获取某些参数时，后者非常有用。特别是，我们将其用于`"/about/:something"`；当匹配此路由时，将以类似于`Express`（查看[第 4 章](04.html)中的*添加路由*部分*与节点*实现 RESTful 服务）的方式提供一个新的道具，属性与 URL 的冒号起始部分一致。您可以通过指定`path=`来省略此项，然后您将得到一个*全面的*，它对于 404 错误非常有用，就像我们在这里所做的那样。

所以，我们有代码；让我们看看它的实际行动。

# 它是如何工作的…

如果您`npm start`打开应用程序，然后导航到它，您将看到主页，如以下屏幕截图所示：

![](assets/5a219e50-a1cc-4580-b82d-554e9accf5b8.png)

Our routing application, showing the component for the basic "/" route

如果您选择了任何有效的路由（即，不要选择错误的路由，至少还没有！），匹配的路由将被激活，并显示相应的组件，如以下屏幕截图所示：

![](assets/7225873e-e3b7-4868-a774-a4f76c251447.png)

Picking a valid route gets you the corresponding component

最后，如果选择了错误的路线，将显示默认组件，如下所示：

![](assets/fe9b3a61-8712-4ef4-a3b8-ecdf78eba46d.png)

The last route in our <Switch> is a catch-all for undefined routes

# 还有更多…

有一些我们还没有使用过：直接导航到给定路线或返回到以前位置的可能性等等。无论何时匹配`<Route>`，渲染组件都会获得一些特殊道具，您可以使用这些道具：

*   `this.props.history`，提供对浏览器历史记录的访问，有`.goBack()`返回上一页或`.push("someURL")`导航到不同页面等多种方式；见[https://developer.mozilla.org/en-US/docs/Web/API/History_API](https://developer.mozilla.org/en-US/docs/Web/API/History_API) 尤其是[https://github.com/ReactTraining/react-router/blob/master/packages/react-router/docs/api/history.md](https://github.com/ReactTraining/react-router/blob/master/packages/react-router/docs/api/history.md) 了解更多信息
*   `this.props.location`，具有多个与当前位置及其 URL 相关的属性；参见[https://github.com/ReactTraining/react-router/blob/master/packages/react-router/docs/api/location.md](https://github.com/ReactTraining/react-router/blob/master/packages/react-router/docs/api/location.md) 获取额外数据
*   `this.props.match`，告诉您当前路线是如何匹配的；参见[https://github.com/ReactTraining/react-router/blob/master/packages/react-router/docs/api/match.md](https://github.com/ReactTraining/react-router/blob/master/packages/react-router/docs/api/match.md)

因此，我们现在能够处理路线问题；让我们继续讨论需要授权的路线。

# 向路由添加授权

我们前面的路由示例运行得很好，但在某些应用程序中，您可能需要授权，以便只有登录的用户才能访问您网站的部分内容。（如果您使用的是我们在[第 4 章](04.html)中开发的 API，*通过节点*实现 RESTful 服务，而节点需要**JSON Web 令牌**（**JWT**），那么您还需要识别用户.那么，让我们看看我们需要做哪些额外工作才能在页面上同时显示受限和非受限路由。

# 怎么做…

让我们通过保护一些路由并要求以前成功登录来为应用程序添加授权。

我们可以找到一个非常类似于`React`的解决方案。我们将有一些不受保护的路由，任何人都可以不受限制地访问，以及需要登录的受保护路由。我们需要两个组件。

# 创建登录组件

首先，让我们创建一个`<Login>`组件，称之为 RESTful 服务器，向其传递用户名和密码，然后（如果值正确）返回 JWT：

```
// Source file: src/routingApp/login.component.js

/* @flow */

import React from "react";
import PropTypes from "prop-types";
import { Redirect } from "react-router-dom";

export class Login extends React.PureComponent<{
    logging: boolean
}> {
    static propTypes = {
        onLogin: PropTypes.func.isRequired,
        logging: PropTypes.bool.isRequired,
        token: PropTypes.string.isRequired,
        location: PropTypes.object
    };

    state = {
        userName: "",
        password: ""
    };

    onUserNameBlur = e => this.setState({ userName: e.target.value });

    onPasswordBlur = e => this.setState({ password: e.target.value });

    onLoginClick = () =>
        this.props.onLogin(this.state.userName, this.state.password);

    render() {
        if (
            this.state.userName &&
            this.state.password &&
            this.props.token
        ) {
            return (
                <Redirect to={this.props.location.state.from.pathname} />
            );
        } else {
            return (
                <div>
                    <h1>Login Form</h1>
                    <div>
                        User:<input
                            type="text"
                            onBlur={this.onUserNameBlur}
                        />
                    </div>
                    <div>
                        Password:
                        <input
                            type="password"
                            onBlur={this.onPasswordBlur}
                        />
                    </div>
                    <button
                        onClick={this.onLoginClick}
                        disabled={this.props.logging}
                    >
                        Login
                    </button>
                </div>
            );
        }
    }
}
```

# 定义动作和减速器

在进入细节之前，让我们先看看减速机和我们将要采取的行动。前者非常简单，因为基本上我们关心的是有一个`token`和`logging`标志：

```
// Source file: src/routingApp/login.reducer.js

/* @flow */

import {
    LOGIN_REQUEST,
    LOGIN_SUCCESS,
    LOGIN_FAILURE
} from "./login.actions";

export const reducer = (
    state: object = {
        // initial state
        logging: false,
        token: ""
    },
    action
) => {
    switch (action.type) {
        case LOGIN_REQUEST:
            return {
                ...state,
                logging: true,
                token: ""
            };

        case LOGIN_SUCCESS:
            return {
                ...state,
                logging: false,
                token: action.token
            };

        case LOGIN_FAILURE:
            return {
                ...state,
                logging: false
            };

        default:
            return state;
    }
};
```

我们将有一些行动创造者，他们将帮助我们理解其余部分。重要的是尝试连接到服务器的`attemptLogin()`，如果成功，则存储标记用户已登录的令牌：

```
// Source file: src/routingApp/login.actions.js

/* @flow */

import { loginService } from "./serviceApi";

export const LOGIN_REQUEST = "login:request";
export const LOGIN_SUCCESS = "login:success";
export const LOGIN_FAILURE = "login:failure";

export const loginRequest = () => ({
    type: LOGIN_REQUEST
});

export const loginSuccess = (token: string) => ({
    type: LOGIN_SUCCESS,
    token
});

export const loginFailure = () => ({
    type: LOGIN_FAILURE
});

// Complex actions:

export const attemptLogin = (
    user: string,
    password: string
) => async dispatch => {
    try {
        dispatch(loginRequest());
        *// the next line delays execution for 5 seconds:*
 *// await new Promise(resolve => setTimeout(resolve, 5000));*
        const result = await loginService(user, password);
        dispatch(loginSuccess(result.data));
    } catch (e) {
        dispatch(loginFailure());
    }
};
```

We'll leave it as an exercise to you to write a `<LogOut>` component that will provide a button, which when clicked will just call an action to delete the current token.

# 创建组件以保护路由

为了保护路由，让我们创建一个新组件来检查用户是否登录。在第一种情况下，将显示路由，无需进一步 ado。但是，在第二种情况下，将生成`<Redirect>`，而不是原始路由的组件，从而将用户重定向到登录页面：

```
// Source file: src/routingApp/authRoute.component.js

/* @flow */

import React from "react";
import { Route, Redirect } from "react-router-dom";
import PropTypes from "prop-types";

export class Auth extends React.Component<{
    loginRoute: string,
    token: string,
    location: object
}> {
    static propTypes = {
        loginRoute: PropTypes.string.isRequired,
        token: PropTypes.string.isRequired,
        location: PropTypes.object
    };

    render() {
        const myProps = { ...this.props };
        if (!myProps.token) {
            delete myProps.component;
            myProps.render = () => (
                <Redirect
                    to={{
                        pathname: this.props.loginRoute,
                        state: { from: this.props.location }
                    }}
                />
            );
        }
        return <Route {...myProps} />;
    }
}
```

我们将此组件连接到存储，以便它可以访问当前令牌以及登录页面的路径：

```
// Source file: src/routingApp/authRoute.connected.js

/* @flow */

import { connect } from "react-redux";

import { Auth } from "./authRoute.component";
export const AuthRoute = connect(state => ({
    token: state.token,
    loginRoute: "/login"
}))(Auth);
```

现在，我们拥有我们需要的一切；让我们努力吧！

# 它是如何工作的…

为了使用新组件，我们将在本章前面的原始路线中更改一些内容。让我们保护一些路线。只需将`Route`更改为`AuthRoute`：

```
// Source file: src/App.routing.auth.js

<AuthRoute path="/alpha" component={Alpha} />
<AuthRoute path="/bravo" component={Bravo} />
<AuthRoute path="/charlie" component={Charlie} />
<AuthRoute path="/zulu" component={Zulu} />
<AuthRoute component={Error404} />
```

所有更改的路由都需要事先登录，如果用户输入了错误的路由，我们甚至不会告诉他们 404 错误；我们将强制他们首先登录，如果他们不这样做，他们甚至无法了解该路由是否存在。

现在，如果我们打开应用程序并尝试访问正常的未受保护的路由，一切都会像以前一样工作。但是，如果您尝试访问某些受保护的路由，例如`"/charlie"`，您将被重定向到登录页面，如以下屏幕截图所示：

![](assets/9eb6ebae-52a5-46fe-934b-6354900e3064.png)

Trying to go to a protected route will redirect you to the login screen

登录后，`<Login>`组件将生成自己的`<Redirect>`，将用户发送回最初请求的页面。请参见以下屏幕截图：

![](assets/a5d19edd-fb7b-4603-829b-236a48fe0a59.png)

After a successful login process, you'll be redirected again to the page you had first requested; the URL now points to the page we wanted to access

所以，现在你有了一种处理各种路线的方法，而且是一种非常`React`的方式！

# 还有更多…

在通常的 web 开发中，您使用 cookie 或可能的本地存储来访问信息，但在`React`应用程序中，将令牌（或您使用的任何东西）存储在状态中就足够了。如果需要为 API 调用提供令牌，请记住操作定义如下：

```
const anActionCreator = 
    (...*parameters*...) => 
        (dispatch, getState) => 
            { ...*your action*... }
```

因此，您可以通过`getState()`功能访问令牌，并根据需要将其传回服务器；回到`getRegions2()`代码，在那里我们看到了如何执行异步操作，以查看使用此函数的示例。

# 代码拆分以提高性能

随着应用程序规模的增长，加载速度会逐渐变慢，这会让用户感到不快。（请记住，并不是每个人都可以访问高速连接，特别是在移动设备中！）此外，如果用户只需要一小部分代码，就不必下载整个代码：例如，如果用户想要浏览产品，为什么要下载注册视图

这个空间和速度问题的解决方案是*代码拆分*，这意味着您的应用程序将被分解成更小的块，只有在需要时才会加载。幸运的是，有很多很好的工具可以实现这一点，它们不涉及对现有代码的太多更改，所以这是一个全面的胜利。

# 准备

导入模块时，它是静态的，并且所需模块的代码包含在通用源代码包中。但是，您可以使用*动态*`import()`调用在运行时加载代码。你可以自己处理，但是已经有一个简单的包可以导入，`react-loadable`，它可以处理大多数情况。让我们以通常的方式安装它：

```
npm install react-loadable --save
```

我们将使用此软件包的一些功能，因此您应该看看[https://github.com/jamiebuilds/react-loadable](https://github.com/jamiebuilds/react-loadable) 了解更多增强动态代码加载功能的方法。

As of December 2018, `import()` is at stage 3, meaning that it's a candidate for acceptance, expecting only few a (if any) changes and is well on its way to stage 4, which means that it will be included in the formal ECMAScript standard. However, as with other JS extensions, you can already use them in your code, and it's supported by `Babel` and `Webpack`. You can read more about `import()` at [https://tc39.github.io/proposal-dynamic-import/](https://tc39.github.io/proposal-dynamic-import/).

# 怎么做…

让我们修改我们的路由应用程序，即使它很小-尝试代码拆分。

首先，让我们看看我们的主代码是什么样子的：

```
// Source file: src/App.splitting.js

/* @flow */

/* eslint-disable */

import React, { Component } from "react";
import { BrowserRouter, Switch, Route, Link } from "react-router-dom";

import {
 AsyncAlpha,
 AsyncBravo,
 AsyncCharlie,
 AsyncZulu,
 AsyncHelp
} from "./splittingApp";

const Home = () => <h1>Home Sweet Home</h1>;
const Error404 = () => <h1>404 Error!</h1>;

class App extends Component<{}> {
    render() {
        return (
            <BrowserRouter>
                <div>
                    <header>
                        <nav>
                            <Link to="/">Home</Link>&nbsp;
                            <Link to="/alpha">Alpha...</Link>&nbsp;
                            <Link to="/bravo">Bravo...</Link>&nbsp;
                            <Link to="/charlie">Charlie...</Link>&nbsp;
                            <Link to="/wrong">...Wrong...</Link>&nbsp;
                            <Link to="/zulu">Zulu</Link>&nbsp;
                            <Link to="/help">Help</Link>&nbsp;
                        </nav>
                    </header>

                    <Switch>
                        <Route exact path="/" component={Home} />
                        <Route path="/help" component={AsyncHelp} />
                        <Route path="/alpha" component={AsyncAlpha} />
                        <Route path="/bravo" component={AsyncBravo} />
                        <Route path="/charlie" component={AsyncCharlie} 
                        />
                        <Route path="/zulu" component={AsyncZulu} />
                        <Route component={Error404} />
                    </Switch>
                </div>
            </BrowserRouter>
        );
    }
}

export default App;
```

我们已经分离了`Alpha`、`Bravo`和其他组件，以便可以动态加载它们。查看其中一个的代码就足够了：

```
// Source file: src/splittingApp/alpha.component.js

/* @flow */

import React from "react";

const Alpha = () => <h1>Alpha</h1>;

export default Alpha;
```

但是`AsyncAlpha`、`AsyncBravo`和其他的呢？这些组件是正常组件的动态加载版本，我们可以使用`react-loadable`获得：

```
// Source file: src/splittingApp/alpha.loadable.js

/* @flow */

import Loadable from "react-loadable";

import { LoadingStatus } from "./loadingStatus.component";

export const AsyncAlpha = Loadable({
 loader: () => import("./alpha.component"),
 loading: LoadingStatus
});
```

`AsyncAlpha`组件可以动态加载，加载时由`LoadingStatus`组件提供其内容；你可以随心所欲地做，但我做了一件非常简单的事：

```
// Source file: src/splittingApp/loadingStatus.component.js

/* @flow */

import React from "react";
import PropTypes from "prop-types";

export class LoadingStatus extends React.Component<{
    isLoading: boolean,
    error: boolean
}> {
    static propTypes = {
        isLoading: PropTypes.bool,
        error: PropTypes.bool
    };

    render() {
 if (this.props.isLoading) {
 return <div>Loading...</div>;
 } else if (this.props.error) {
 return <div>ERROR: the component could not be loaded.</div>;
 } else {
 return null;
 }
    }
}
```

所以，现在我们知道了如何动态加载任何组件，让我们看看它是如何工作的。

Being able to load components dynamically, instead of whole routes as usual with web applications, is a great plus. For example, your application could have a large, heavy component in a tab, but why load it unless the user actually goes to that tab? Deferred loading can also help show a page faster; you could endeavor to first show components at the top, and use dynamic imports for the components at the bottom.

# 它是如何工作的…

我们将使用 web 开发者工具来查看网络传输。当我们启动应用程序时，我们会看到主页和一些传输，包括主源代码块`bundle.js`。随着应用程序变大，这个文件的大小将大幅增长。请参见以下屏幕截图：

![](assets/da642b65-fe14-4799-8cf1-c743015c4499.png)

The initial load of the page shows that only bundle.js was sent over the net

如果我们点击一个链接，相应的分割代码块将被转移。访问多个链接后，您会得到如下结果：

![](assets/2eb0b6e0-d958-4832-bb6b-cd60c2f79798.png)

As you go to different links, chunks will get loaded, but only as needed

即使我们的示例非常小，您也可以很容易地将应用程序划分为几个较小的块。我们无法给出规则来建议您何时开始应用此技术，但是，正如我们所看到的，将任何组件更改为异步加载的等效组件只需很少的努力，因此您可以开始使用此技术，即使您已经编写了所有应用程序。

# 还有更多…

由`Loadable()`创建的组件包括一个`.preload()`方法，您可以使用该方法在实际需要组件之前启动导入过程。我们可以快速测试它。例如，让我们进行设置，以便如果用户将鼠标移动到 Alpha 链接上，组件将预加载：

```
<Link to="/alpha">
    <span onMouseOver={() => AsyncAlpha.preload()}>Alpha...</span>
</Link>
```

我们可以快速验证这是否有效。加载更新版本的代码时，如果将鼠标悬停在 Alpha 链接上，您将看到一块代码被下载，但屏幕上没有任何更改，如以下屏幕截图所示：

![](assets/e533a515-be91-4495-91f8-1d201134bba1.png)

Preloading works in the background and lets you download a component in advance: a chunk (1.chunk.js) has been loaded, though it hasn't been shown onscreen

给它一些时间，请注意，当您实际单击 Alpha 链接时，该组件将立即显示，无需进一步下载。预加载有更多的用途：例如，你可以在初始页面加载后使用`setTimeout()`，或者你可以进行预测性下载，根据用户所做的事情，尝试预测用户下一步想要什么。