Using Modern JavaScript Features  

# 使用现代 JavaScript 功能

我们将在本章中介绍的配方如下：

*   添加类型
*   使用字符串
*   增强代码
*   定义功能
*   功能性编程
*   紧凑地执行异步调用
*   使用对象和类
*   在模块中组织代码
*   确定功能的可用性

# 介绍

在上一章中，我们将使用本书中使用的许多工具来设置工作环境。在本章中，我们将为本书的其余部分做好准备，我们将考虑 JavaScript 的一些有趣而强大的现代功能，这些功能可以帮助您更有效地编写更好的代码。

我们将考虑一些新的语言功能，这些功能将派上用场，但肯定不是所有的！JS 已经发展成为一种大型语言，并且有一些您可能永远都不需要的特性。从一开始，我们还将更认真地与`Flow`合作，旨在放弃使用*非类型 JS*，以更安全的方式开发代码。

强调 JS 经过多年的发展，没有一个单一的标准版本，这一点可能很重要。最新的版本（正式）称为 ECMAScript 2018，通常简称为 ES2018。该语言的当前版本列表如下：

*   ECMAScript 11997 年 6 月
*   ECMAScript 2，1998 年 6 月，基本上与以前的版本相同
*   ECMAScript 3，1999 年 12 月，添加了几个新功能
*   ECMAScript 5，2009 年 12 月（从未有过 ECMAScript 4；该版本已被放弃），也称为 JS5
*   ECMAScript 5.11911 年 6 月
*   ECMAScript 6（ES2015 或 ES6），2015 年 6 月
*   ECMAScript 7（ES2016），2016 年 6 月
*   ECMAScript 8（ES2017），2017 年 6 月
*   ECMAScript 9（ES2018），2018 年 6 月

**ECMA** was originally an acronym meaning **European Computer Manufacturers Association**, but nowadays the name is simply considered a name by itself. You can go to its site at [https://www.ecma-international.org/](https://www.ecma-international.org/) and view the standard language specification at [https://www.ecma-international.org/publications/standards/Ecma-262.htm](https://www.ecma-international.org/publications/standards/Ecma-262.htm).

每当我们在本文中引用 JS 而没有进一步的规范时，最新版本（即 ES2018）就是我们的意思。没有浏览器完全实现这个版本，在本书中，我们将使用`Babel`解决这个问题，这是一个工具，可以将现代功能转换为等效的、但较旧的、兼容的代码，因此，即使您以最新的方式编程，使用较旧浏览器的用户仍然可以运行您的代码。我们将使用的工具将自行安装`Babel`，因此我们不必这样做，但如果您感兴趣，您可以在[上阅读更多内容 https://babeljs.io/](https://babeljs.io/) 。

A very good source for all JS-related things is the **Mozilla Developer Network** (**MDN**), which has been going strong with all sorts of web documentation for over ten years. Take a look to their site at [https://developer.mozilla.org/bm/docs/Web/JavaScript](https://developer.mozilla.org/bm/docs/Web/JavaScript); we'll be frequently making reference to it. You can also read [http://es6-features.org/](http://es6-features.org/) for a wealth of examples of ES6 features.

# 添加类型

在上一章中，我们安装了`Flow`，以便可以将数据类型检查添加到 JS 中，但我们没有真正了解它的语法或规则。在讨论 JS 的特定功能之前，让我们先讨论一下这个问题。

# 开始

除非您明确要求，否则`Flow`不会检查每个文件。对于要检查的文件，必须在最上面添加一条简单的注释，如下面的代码段所示。`Flow`将忽略任何缺少此注释的文件，因此即使您正在将该工具添加到现有项目中，也可以逐步添加，一次添加一个文件：

```
/* @flow */
```

从 Flow 的控件开始，您只需指定任何变量的预期数据类型，`Flow`将检查它是否始终正确使用。幸运的是，`Flow`还能够通过值确定数据类型；例如，如果您将一个字符串分配给一个变量，它将假定该变量将包含字符串 https://flow.org/en/docs/usage/ ，您可以写以下内容：

```
/* @flow */

function foo(x: ?number): string {
    if (x) {
        return x;
    } else {
        return "some string";
    }
}

console.log(foo("x"));
```

`:?number`和`:string`注释指定`x`是可选的数字参数，`foo`应该返回字符串。你能看到代码其余部分有两个问题吗？如果你使用`npm run flow`，你会得到一个报告，说明问题所在。首先，你不能`return x`，因为变量和预期返回值之间的数据类型不匹配：

```
Error ------------------------------------------------------------------------------------- src/types_examples.js:5:16

Cannot return x because number [1] is incompatible with string [2].

        2│
 [1][2] 3│ function foo(x /* :?number */) /* :string */ {
        4│     if (x) {
        5│         return x;
        6│     } else {
        7│         return 'some string';
        8│     }
```

其次，您试图调用函数，但传递了错误类型的参数：

```

Error------------------------------------------------------------------------------------- src/types_examples.js:12:17

Cannot call foo with 'x' bound to x because string [1] is incompatible with number [2].

  [2] 3│ function foo(x /* :?number */) /* :string */ {
 :
 9│ }
 10│
 11│ // eslint-disable-next-line no-console
 [1] 12│ console.log(foo('x'));
 13│
```

前面的所有代码（类型声明除外）都是有效的 JS，因此它会被接受；`Flow`告诉您这些问题，以便您能够解决它们。现在，让我们更详细地了解一下，看看这个工具为我们提供的所有可能性。

If you want to ignore Flow's warnings for any line, precede it with a comment like `// @FlowFixMe` and follow with the reason why you want to skip that situation. See [https://flow.org/en/docs/config/options/#toc-suppress-comment-regex](https://flow.org/en/docs/config/options/#toc-suppress-comment-regex) for more on this.

# 怎么做。。。

有许多方法可以定义类型，这样您就可以毫无问题地处理简单和复杂的情况。让我们从更简单的基本类型开始，然后继续讨论更具体的情况。

# 流程中的基本类型

可能的数据类型定义见[https://flow.org/en/docs/types/](https://flow.org/en/docs/types/) -我们不会在这里全部复制它们，而是通过几个示例向您展示主要内容。请查看完整的文档，因为您应该了解各种可能性：

| `:boolean` | 布尔值。 |
| `:number` | 数值。 |
| `:string` | 串。 |
| `:null` | 空值。您不会只是声明某个变量应该始终为 null；相当地您将使用这些高级类型，例如*联合体*，我们将在下一节中看到。 |
| `:void` | 无效（未定义）值。 |
| `:mixed` | 任何类型，但仍将检查一致性。例如，如果在某一点`Flow`知道变量是布尔值，那么将其用作字符串将被标记为错误。 |
| `:any` | 任何类型，并且`Flow`不会对其进行任何检查。这相当于禁用上的类型检查任何属于*任何*类型的。 |
| `function foo(x: ?boolean)` | 具有可选`boolean`参数的函数。这与声明参数可以是`boolean`、`null`或`undefined`。 |
| `function bar() :string` | 返回字符串结果的函数。 |
| `{ property ?: number }` | 可选对象属性；如果存在，它可以是数字或未定义的，但不是`null`。 |
| `: Array&lt;number>`
`: number[]` | 两种不同样式的数字数组。如果要处理固定长度数组，可以使用*元组*；转到[https://flow.org/en/docs/types/tuples/](https://flow.org/en/docs/types/tuples/) 了解更多。 |

We will find out how to assign or define types for these definitions in the *Defining types for arrow functions* recipe, later in this chapter.

我们可以在下面的代码中看到一些定义示例。我禁用了 ESLint 关于未使用变量的规则，以避免出现明显的问题：

```
// Source file: src/types_basic.js

/* @flow */
/* eslint-disable no-unused-vars */

let someFlag: boolean;
let greatTotal: number;
let firstName: string;

function toString(x: number): string {
    return String(x);
}

function addTwo(x: number | string, y: number | string) {
    return x + y;
}

function showValue(z: mixed): void {
    // not returning anything
    console.log("Showing... ", z);
}

let numbersList: Array&lt;number>;
numbersList = [22, 9, 60]; // OK
numbersList[1] = "SEP"; // error; cannot assign a string to a number

let anotherList: number[] = [12, 4, 56];

// *continues...*
```

The `addTwo()` definition has a hidden problem: are you sure that `x` and `y` will always be of the same type? Actually, `x` could be a number and `y` could be a string, and `Flow` wouldn't complain. We have no easy way of testing this, and a runtime check for `typeof x === typeof y` would be needed.

定义对象时，应为其所有属性和方法提供数据类型。对象定义被认为是*密封的*，这意味着您不能更改对象类型。如果您不能或不愿意这样做，请从一个空对象开始，然后`Flow`将允许您随意添加属性：

```
// *...continued*

let sealedObject: { name: string, age?: number } = { name: "" };

sealedObject.name = "Ivan Horvat"; // OK

sealedObject.id = 229; // error: key isn't defined in the data type 
sealedObject = { age: 57 }; // error: mandatory "name" field is missing

let unsealedObject = {};
unsealedObject.id = 229; // OK
```

If a function expects an object with some properties, and it receives an object with those properties plus some extra ones, `Flow` won't complain. If you don't want this, use *exact objects*; see [https://flow.org/en/docs/types/objects/#toc-exact-object-types](https://flow.org/en/docs/types/objects/#toc-exact-object-types). However, this also causes problems, such as disabling the spread operator; see [https://github.com/facebook/flow/issues/2405](https://github.com/facebook/flow/issues/2405) for a (two year long!) discussion.

现在，让我们转向更复杂的定义，您可能最终会使用这些定义，因为它们更好地匹配通常的业务需求和程序规范。

# 联合类型

上一节的基本定义对于大量代码来说已经足够了，但是当您开始处理更复杂的问题时，您将需要一些更高级的`Flow`特性，并且您可能希望单独定义类型，以便在其他地方重用它们。因此，在本节和以下各节中，我们将介绍更高级的类型

在 JS 中，一个变量在不同的时间可能有不同的数据类型是很常见的。对于这种情况，您可以使用*联合**类型*：

```
// Source file: src/types_advanced.js

let flag: number | boolean;
flag = true; // OK
flag = 1; // also OK
flag = "1"; // error: wrong type

let traffic: "red" | "amber" | "green"; // traffic is implicitly string
traffic = "yellow"; // error: not allowed

type numberOrString = number | string;
function addTwo(x: numberOrString, y: numberOrString) {
    return x + y;
}

// *continues...*
```

For some occasions in which you have objects that have different properties depending on some internal value, you can also use *disjoint* unions; see [https://flow.org/en/docs/types/unions/](https://flow.org/en/docs/types/unions/). 

# 类类型

`Flow`支持类，主要是以自动方式。每次定义一个类时，它本身就成为一个类型，因此不必做任何其他事情；你可以在别处使用它。（稍后我们将在*处理对象和类*部分了解更多关于类的内容。）您可以使用与对象和函数相同的方式为属性和方法分配类型。再次以我们的`Person`类为例，下面的代码展示了如何用`Flow`定义它：

```
// Source file: src/types_advanced.js

class Person {
 // *class fields need Flow annotations*
 first: string;
 last: string;

    constructor(first: string, last: string) {
        this.first = first;
        this.last = last;
    }

    initials(): string {
        return `${this.first[0]}${this.last[0]}`;
    }

    fullName(): string {
        return `${this.first} ${this.last}`;
    }

    get lastFirst(): string {
        return `${this.last}, ${this.first}`;
    }

    set lastFirst(lf: string) {
        // *very unsafe; no checks!*
        const parts = lf.split(",");
        this.last = parts[0];
        this.first = parts[1];
    }
}

let pp = new Person("Jan", "Jansen"); // *OK*
let qq = new Person(1, 2); // ***error: wrong types for the constructor***
let rr: Person; // *OK, "Person" type is understood and can be used* 
```

但是，您可能会遇到一个问题。如果您有不同的类，即使形状完全相同，它们也不会被`Flow`认为是等价的。例如，即使`Animal`和`Pet`相等，也不允许将`Pet`分配给`Animal`（反之亦然）：

```
// Source file: src/types_advanced.js

class Animal {
 name: string;
 species: string;
 age: number;
}

class Pet {
 name: string;
 species: string;
 age: number;
}

let tom: Animal;
tom = new Pet(); // error: *Pet and Animal are distinct types*
```

在这种特殊情况下，如果您说`Pet`扩展了`Animal`，那么您可以将`Pet`分配给`Animal`，但不能反过来分配。更一般的解决方案包括创建一个`interface`并在几个地方使用它：

```
// Source file: src/types_advanced.js interface AnimalInt {
 name: string;
 species: string;
 age: number;
}

class Animal2 implements AnimalInt {
 name: string;
 species: string;
 age: number;
}

class Pet2 implements AnimalInt {
 name: string;
 species: string;
 age: number;
}

let tom2: AnimalInt; // *not Animal2 nor Pet2*
tom2 = new Pet2(); // *OK now*
```

请注意，`interface`定义包括三个字段，当您定义`Animal2`或`Pet2`时，并不免除您声明这些字段；因为如果这三个字段中的某一个是可选的，那么这三个字段中的任何一个都不会被标记出来。

# 类型别名

当您的类型变得更复杂时，或者当您希望在多个位置重用同一定义时，可以创建类型别名：

```
// Source file: src/types_advanced.js

type simpleFlag = number | boolean;

type complexObject = {
 id: string,
 name: string,
 indicator: simpleFlag,
 listOfValues: Array&lt;number>
};
```

在以这种方式定义类型之后，您可以在任何地方使用它们，即使是在新类型的定义中，正如我们在`complexObject`中所做的那样，我们在`complexObject`中定义了一个字段，该字段是先前定义的`simpleFlag`类型：

```
// Source file: src/types_advanced.js

let myFlag: simpleFlag;

let something: complexObject = {
 id: "B2209",
 name: "Anna Malli",
 indicator: 1,
 listOfValues: [12, 4, 56]
};
```

类型别名甚至可以是泛型的，我们将在下一节中看到。您还可以从模块导出类型，并将其导入到任何地方使用；我们将在*与图书馆合作*一节中谈到这一点。

# 泛型

在函数式编程中，通常使用`identity`函数，其定义如下：

```
// Source file: src/types_advanced.jsconst identity = x => x;
```

In combinatory logic, which we won't be going into, this corresponds with the I *combinator*.

如何为此函数编写类型定义？如果参数是一个数字，它将返回一个数字；如果它是一个字符串，它将返回一个字符串，依此类推。写下所有可能的情景都是一件苦差事，不太**不要重复自己***（***干燥**）。`Flow`提供解决方案，具有*泛型*：

```
// Source file: src/types_advanced.js

const identity = &lt;T>(x: T): T => x;
```

在本例中，`T`表示泛型类型。函数的参数和函数本身的结果都被定义为`T`类型，因此`Flow`将知道无论参数是什么类型，结果类型都是相同的。类似的语法将用于更常见的函数定义方式：

```
// Source file: src/types_advanced.jsfunction identity2&lt;T>(x: T): T {
    return x;
}
```

`Flow`还检查您是否意外限制了泛型类型。在以下情况下，您将始终返回一个数字，`T`实际上可能是任何其他不同的类型：

```
// Source file: src/types_advanced.jsfunction identity3&lt;T>(x: T): T {
    return 229; // *wrong; this is always a number, not generic*
*}*
```

您不需要将自己限制为单一泛型类型；以下示例显示了两种类型的案例：

```
// Source file: src/types_advanced.js

function makeObject&lt;T1, T2>(x: T1, y: T2) {
    return { first: x, second: y };
}
```

还可以使用泛型类型定义参数化类型，以后可以指定泛型类型。在下面的示例中，`pair`的类型定义允许您进一步创建新类型，每个新类型将始终生成相同类型的成对值：

```
// Source file: src/types_advanced.js

type pair&lt;T> = [T, T];

type pairOfNumbers = pair&lt;number>;
type pairOfStrings = pair&lt;string>;

let pn: pairOfNumbers = [22, 9];

let ps: pairOfStrings = ["F", "K"];
```

There are more ways you can use generic types; check [https://flow.org/en/docs/types/generics/](https://flow.org/en/docs/types/generics/) for a complete description of available possibilities.

# 用于更安全编码的不透明类型

在`Flow`（以及 TypeScript）中，结构相同的类型被认为是兼容的，可以使用一种类型来代替另一种类型。让我们考虑一个例子。在乌拉圭，有一张带有 DNI 代码的国家身份证：这是一个由七位数字、一个破折号和一个校验位组成的字符串。您可以使用一个应用程序来更新人们的数据：

```
// Source file: src/opaque_types.js

type dniType = string;
type nameType = string;

function updateClient(id: number, dni: dniType, name: nameType) {
    /*
        *Talk to some server*
 *Update the DNI and name for the client with given id*
    */
}
```

会发生什么？如果您没有定义更好的类型，那么没有什么可以阻止您进行类似于`updateClient(229, "Kari Nordmann", "1234567-8")`的调用；你能找出切换的值吗？因为`dniType`和`nameType`都是最底层的字符串，即使它们暗示了完全不同的概念，`Flow`也不会抱怨。`Flow`确保正确使用类型，但由于它不处理语义，您的代码仍然可能明显错误。

*不透明*类型不同，因为它们将内部实现细节从外部隐藏起来，并且具有更严格的兼容性规则。您可以有一个名为`opaque_types.js`的文件，其定义如下：

```
// Source file: src/opaque_types.js opaque type dniType = string;
type nameType = string; // *not opaque!*
```

然后，在另一个源文件中，我们可以尝试以下操作：

```
// Source file: src/opaque_usage.js

import type { dniType, nameType } from "./opaque_types";
import { stringToDni } from "./opaque_types";

let newDni = "1234567-8"; // *supposedly a DNI*
```

```
let newName = "Kari Nordmann";

updateClient(229, newName, newDni); // *doesn't work; 2nd argument should be a DNI*
updateClient(229, newDni, newName); // *doesn't work either; same reason*
```

我们如何解决这个问题？即使改变`newDni`的定义也不会有帮助：

```
let newDni: dniType = "1234567-8"; // *a string cannot be assigned to DNI*
```

即使在这个改变之后，`Flow`仍然会抱怨字符串不是 DNI。当我们处理不透明类型时，如果我们想进行类型转换，我们必须自己提供它们。在本例中，我们应该使用类型定义将这样一个函数添加到文件中：

```
// Source file: src/opaque_types.js

const stringToDni = (st: string): dniType => {
    /*
    *    do validations on st*
 *if OK, return a dniType*
 *if wrong, throw an error*
    */
    return (st: dniType);
};

export { stringToDni };
```

现在，我们可以工作了！让我们看看代码：

```
// Source file: src/opaque_usage.js

updateClient(229, stringToDni(newDni), newName); // *OK!*
```

这仍然不是最优的。我们知道所有的 DNI 值都是字符串，所以我们应该能够这样使用它们，对吗？事实并非如此：

```
// Source file: src/opaque_usage.js

function showText(st: string) {
    console.log(`Important message: ${st}`);
}

let anotherDni: dniType = stringToDni("9876543-2");
showText(anotherDni); // error!
```

`anotherDni`变量是`dniType`变量，但由于不透明类型没有关于真实类型的信息，因此尝试将其用作`string`变量失败。当然，您可以编写一个`dniToString()`函数，但这似乎有些过分，而且在一个可能有几十种数据类型的系统中很快就会失控！我们有一个退路：我们可以添加子类型约束，这将允许不透明类型用作不同的类型：

```
// Source file: src/opaque_types.js

opaque type dniType : string = string;
```

这意味着`dniType`可以用作`string`，但反之亦然。使用不透明类型将增加代码的安全性，因为会捕获更多错误，但您也可以通过这些约束获得一定程度的灵活性，这将使您的生活更加轻松。

# 与图书馆合作

今天，您创建的任何项目都很可能依赖于第三方库，而且这些库很可能不是用`Flow`编写的。默认情况下，`Flow`将忽略这些库，并且不会执行任何类型检查。这意味着您在使用库时可能犯下的任何数据类型错误都将无法识别，您必须通过测试和调试以老式的方式来处理这些错误—这是一种倒退到更糟糕的时代！

为了解决这个问题，`Flow`允许您使用**库定义**（**libdefs**）（请参见[https://flow.org/en/docs/libdefs/ 描述数据库的数据类型、接口或类，与库本身一样，如 C++和其他语言中的头文件。libdef 是`.js`文件，但它们位于项目根目录的`flow-typed`目录中。](https://flow.org/en/docs/libdefs/)

You can change this directory by editing the `.flowconfig` configuration file, but we won't meddle with it. If you are interested in effecting such a change, see the `[libs]` documentation at [https://flow.org/en/docs/config/](https://flow.org/en/docs/config/).

有一个库定义库`flow-typed`，您可以在其中找到许多流行库的现成文件；参见[https://github.com/flowtype/flow-typed](https://github.com/flowtype/flow-typed) 了解更多信息。但是，您不需要直接处理这个问题，因为有一个工具可以为您完成这项工作，尽管有时它会将责任推回给您！

The main objection against `Flow` these days, and a point for TypeScript, is that the list of supported libraries in terms of data type descriptions is far greater for the latter. There are some projects that attempt to make `Flow` work with TypeScript's descriptions, but so far this is still pending, though some good results have been shown.

首先，安装新工具：

```
npm install flow-typed --save-dev
```

然后，在`package.json`中添加一个脚本以简化工作：

```
scripts: {
    .
    .
    .
    addTypes: "flow-typed install",
    .
    .
    .
```

使用`npm run addTypes`将扫描您的项目并尝试添加所有可能的 libdef。如果它找不到合适的库定义（很抱歉，这并不罕见），它将在任何地方使用`any`创建一个基本定义。例如，我在项目中添加了`moment`库：

```
> npm install moment --save
> npm run addTypes
```

在此之后，`flow-typed`目录被添加到项目根目录中。其中出现了很多文件，包括带有`moment`库类型定义的`moment_v2.3.x.js`。对于没有 libdef 的库，也会创建文件，但您可以忽略它们。

如果您需要 libdef，但它不存在，您可以自己创建它。（请将您的工作贡献给`flow-typed`项目！）我添加了`npm install fetch --save`，但当我试图获取 libdef 时，却没有找到它。因此，我可以在没有定义的情况下继续工作（标准情况！），也可以尝试创建适当的文件；没有一个是真正的最佳情况。

I would suggest adding the `flow-typed` directory to `.gitignore` so that those files won't get uploaded to Git. Since it's standard practice to do `npm install` every time you pull from the repository, now you also have to use `npm run addTypes`—or, better yet, create a script that will do both commands!

# 使用字符串

从 JS 的第一个版本开始，字符串就一直是 JS 的一个特性，但是现在有更多的特性可用。

# 怎么做。。。

在以下几节中，我们将看到本书其余部分将使用的许多函数，例如插值（用几个部分构建字符串）或标记字符串（我们将在[第 7 章](07.html)、*的*创建用于内联样式化的样式化组件*部分中使用这些函数来设置组件的样式）增强您的应用程序*，仅显示两个示例。

# 模板字符串中的插值

每个人都曾在某个时候使用公共运算符来构建字符串，如以下代码片段所示：

```
let name = lastName + "," + firstName;
let clientUrl = basicUrl + "/clients/" + clientId + "/";
```

JS 现在添加了*模板文本*，提供了一种包含可变文本和生成多行字符串的简单方法。字符串插值非常简单，前面的代码可以重写如下：

```
let name = `${lastName}, ${firstName}`;
let clientUrl = `${basicUrl}/clients/${clientId}/`;
```

Template literals were earlier known as *template strings*, but current JS specifications don't use that expression any more. For more information, go to [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals).

模板文本由回勾字符（``...``）分隔。您可以在任何需要替换某些值或表达式的地方使用`${...}`：

```
let confirm = `Special handling: ${flagHandle ? "YES" : "NO"}`;
```

当然，在插值时，很容易过火，开始推太多逻辑。出于这个原因，我建议避免使用以下代码：

```
let list = ["London", "Paris", "Amsterdam", "Berlin", "Prague"];
let sched = `Visiting ${list.length > 0 ? list.join(", ") : "no cities"}`;
// Visiting London, Paris, Amsterdam, Berlin, Prague
```

如果`list`为空，则会生成`"Visiting no cities"`。如果你把逻辑从模板中推出来，那就更清楚了；即使生成的代码稍大一些，也会变得清晰：

```
let list = ["London", "Paris", "Amsterdam", "Berlin", "Prague"];
let destinations = list.length > 0 ? list.join(", ") : "no cities";
let sched = `Visiting ${destinations}`;
```

We'll fight the temptation to include logic in templates later, when we work in `React` (from [Chapter 6](06.html), *Developing with React*, to [Chapter 10](10.html), *Testing your Application*) and see how we can render components.

# 标记模板

标记模板是我们所研究的模板的更高级形式。基本上，这是调用函数的另一种方式，但语法类似于模板字符串。让我们看一个例子，然后解释一下：

```
// Source file: src/tagged_templates.js function showAge(strings, name, year) {
    const currYear = new Date().getFullYear();
    const yearsAgo = currYear - year;
    return (
        strings[0] + name + strings[1] + year + `, ${yearsAgo} years ago`
    );
}

const who = "Prince Valiant";
const when = 1937;
const output1 = showAge`The ${who} character was created in ${when}.`;
console.log(output1);
// *The Prince Valiant character was created in 1937, 81 years ago*

const model = "Suzuki";
const yearBought = 2009;
const output2 = showAge`My ${model} car was bought in ${yearBought}`;
console.log(output2);
// *My Suzuki car was bought in 2009, 9 years ago*
```

通过以下方式调用`showAge()`函数：

*   字符串数组，对应于模板的每个常量部分，例如，在第一种情况下，`strings[0]`是`The`，而`strings[2]`是`.`
*   包含的每个表达式的参数；在我们的例子中，有两个

该函数可以执行任何计算并返回任何类型的值，可能不是字符串！在我们的示例中，该函数生成原始字符串的*增强*版本，添加了多少年前创建漫画角色或购买汽车时发生的事情。

We'll be using tagged templates in the *Creating StyledComponents for inline styling* section of [Chapter 7](07.html), *Enhancing Your Application*; the styled-component library we'll use depends totally on this feature to allow for more readable code.

# 写入多行字符串

新模板文本的另一个特性是它们可以跨越多行。对于早期版本的 JS，如果要生成多行文本，必须在输出字符串中插入换行符（`"\n"`，如下所示：

```
let threeLines = "These are\nthree lines\nof text";
console.log(threeLines);
// *These are*
// *three lines*
// *of text*
```

使用模板字符串，您可以根据需要编写行：

```
let threeLines = `These are
three lines
of text`;
```

不过，我建议不要这样做。即使代码看起来更清晰，当它缩进时，结果看起来很难看，因为续行*必须*从第一列开始，你明白为什么吗？检查以下代码。连续行被推到左侧，破坏了缩进代码的视觉连续性：

```
if (someCondition) {
    .
    .
    .
    if (anotherCondition) {
        .
        .
        .
        var threeLines = `These are
three lines
of text`;
    }
}
```

可以使用反斜杠转义不属于模板的字符：

```
let notEscaped1 = `this is \$\{not\} interpolation\\nright? `;
// *"this is ${not} interpolation\nright? "*
```

You might want to look into `String.raw` (see [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/raw](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/raw)) for an alternative to this way of avoiding templating. You can just avoid templating altogether, since an informal poll has shown that practically no developers know of it and it isn't such a great advantage after all.

# 重复字符串

让我们以几个新的字符串相关函数结束。大多数都很容易理解，因此解释大多很简短。有关所有可用字符串函数（包括旧函数和新函数）的完整列表，请参见[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String) 。

您可以使用`.repeat(...)`方法迭代任何字符串：

```
"Hello!".repeat(3); // Hello!Hello!Hello!
```

# 填充字符串

您可以使用`.padStart(...)`和`.padEnd(...)`在原始文本的左侧或右侧添加重复字符串，将字符串填充到给定长度：

```
"Hello".padStart(12);       // "       Hello"
"Hello".padStart(12,"XYZ"); // "XYZXYZXHello"
"Hello".padStart(3);        // "Hello"; no effect here

"Hello".padEnd(12);         // "Hello       "
"Hello".padEnd(12,"XYZ");   // "HelloXYZXYZX"
"Hello".padEnd(4);          // "Hello"; no effect here either
```

在可能的用途中，您可以在左边用零填充数字。我们必须将数字转换为字符串，因为填充方法仅适用于字符串：

```
let padded = String(229.6).padStart(12, "0"); // "*0000000229.6*"
```

The reason for using `padStart` and `padEnd` instead of `padLeft` and `padRight` has to do with left-to-right and right-to-left languages. It was felt that start and end were not ambiguous, while left and right would be. For example, in Hebrew, the start of a string is printed at the right and its end is to the left.

# 字符串搜索

有一些新函数用于确定字符串是以给定字符串开头、以给定字符串结尾还是包含给定字符串。这可以让您从使用`indexOf(...)`和与长度相关的计算中解脱出来：

```
"Hello, there!".startsWith("He"); // true
"Hello, there!".endsWith("!");    // true
"Hello, there!".includes("her");  // true
```

Each of these methods has a position as an optional second parameter, which specifies where to do the search; see [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith), [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith), and [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes) for more information.

# 剪线

您可以使用`.trim(...)`、`.trimStart(...)`和`.trimEnd(...)`在两端或仅在一端修剪字符串：

```
"   Hello, there!  ".trim();      //    "*Hello, there!*"
"   Hello, there!  ".trimStart(); //    "*Hello, there!*  "
"   Hello, there!  ".trimEnd();   // "   *Hello, there!*"
```

Originally, `.trimStart()` was `.trimLeft()`, and `.trimEnd()` was `.trimRight()`, but the names were changed for the same reason as `.padStart()` and `.padEnd()` were.

# 在字符串上迭代

字符串现在是 iterable 对象（例如数组），这意味着您可以使用`for...of`逐个字符地对其进行迭代：

```
for (let ch of "PACKT") {
    console.log(ch);
}
```

扩展运算符（请深入阅读本章*扩展和连接值*部分中的内容）也将起作用，从而将字符串转换为单个字符数组：

```
let letters = [..."PACKT"];
// ["P", "A", "C", "K", "T"]
```

# 增强代码

现在，让我们看一下 JS 的几个有用的新功能，它们与基本需求和特性有关。这并不详尽，因为 JS 毕竟相当大！不过，我们将讨论您可能会使用的最有趣的功能。

# 怎么做。。。

本节中的功能并不是通过公共线程链接的，它们将帮助您编写更短、更简洁的代码，并帮助您避免可能的常见错误。

# 在严格的模式下工作

让我们从一个你可能不需要的改变开始！JS 对某些错误有些傲慢，它不会发出警告或崩溃，而是默默地忽略它们。2015 年，一个新的*严格*模式被包括在内，它改变了 JS 引擎的行为，开始报告这些错误。要启用新模式，您必须先包含一行，然后再包含一个简单的字符串：

```
"use strict";
```

包含此字符串将强制代码采用严格模式。发现了哪些错误？简要列表包括以下内容：

*   不能意外地创建全局变量。如果你在一个函数中拼错了一个变量的名字，JS 会创建一个新的全局变量，然后继续前进；在严格模式下，会产生错误。
*   您不能使用`eval()`创建变量。
*   不能有名称重复的函数参数，如`function doIt(a, b, a, c)`中所示。
*   不能删除不可写的对象属性；例如，您不能删除`someObject.prototype`。
*   不能写入某些变量；例如，您不能执行`undefined=22`或`NaN=9`。
*   `with`声明是禁止的。
*   一些单词（例如`interface`或`private`在未来版本的 JS 中被保留为关键字。

The previous list isn't complete and there're a few more changes and restrictions. For full details, read [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode).

你应该用这个吗？对于主脚本，`"use strict"`是可选的，但是对于模块和类，它是隐含的。因此，大多数代码总是在严格模式下运行，因此您将真正习惯于包含该字符串。也就是说，如果您使用的是`Babel`，transpiler 已经为您提供了所需的字符串。另一方面，节点的模块将需要它，我们将在下一章中看到。

# 作用域变量

*范围*的概念与*可见性*的理念相关联：范围是可以引用或使用已定义元素（如变量或函数）的上下文。原则上，JS 只提供了两种类型的作用域：*全局*作用域（可以在任何地方访问）和*函数*作用域（只能在函数本身内部访问）。由于范围从 JS 一开始就存在，我们只需记住两条规则，没有太多的细节：

*   作用域是分层排列的，*子*作用域可以访问*父*作用域中的所有内容，但不能反过来访问。
*   如果在内部作用域中重新定义某些内容，则将禁用对*父*作用域的访问。引用将始终指向子定义，并且您无法访问外部包含范围中的同名元素

JS5 引入了一种新类型的作用域，称为*块*作用域，它可以让您以更谨慎的方式工作。这允许您为单个块创建变量，而不在其外部存在，甚至在定义变量的函数或方法的其余部分也不存在。有了这个概念，除了使用`var`之外，增加了两种定义变量的新方法：`let`和`const`。

The new declarations are not subject to *hoisting*, so if you are not used to declaring all variables at the top of your code before they are used, you may have problems. Since the usual practice is starting functions with all declarations, this isn't likely to affect you. See [https://developer.mozilla.org/en-US/docs/Glossary/Hoisting](https://developer.mozilla.org/en-US/docs/Glossary/Hoisting) for more details.

第一个选项`let`允许您声明一个变量，该变量将被限制在使用它的块或语句中。第二个选项`const`添加了一个限制条件，即变量不应该改变值，而应该是常量；如果尝试为常数指定新值，则会产生错误。以下简单示例显示了新的行为：

Using `const` for a constant value needs little explanation, but what about `let`? The reason harkens back to the origin of the `BASIC` programming language. In that language, you assigned values to variables with code like `37 LET X1 = (B1*A4 - B2*A2) / D`; this particular line was taken from Darmouth College's `BASIC` manual facsimile, dated October 1964\. See [http://www.bitsavers.org/pdf/dartmouth/BASIC_Oct64.pdf](http://www.bitsavers.org/pdf/dartmouth/BASIC_Oct64.pdf) for more information.

```
// Source file: src/let_const.js

{ 
    let w = 0;
}
console.log(w); // *error: w is not defined!*

let x = 1;
{
    let x = 99;
}
console.log(x); // *still 1*;

let y = 2;
for (let y = 999; 1 > 2; y++) {
    /* *nothing!* */
}
console.log(y); // *still 2*;

const z = 3;
z = 9999; // *error!*
```

使用`let`也解决了一个经典问题。以下代码将执行什么操作？如下所示：

```
// Source file: src/let_const.js

// *Countdown to zero?*
var delay = 0;
for (var i = 10; i >= 0; i--) {
    delay += 1000;
    setTimeout(() => {
        console.log(i + (i > 0 ? "..." : "!"));
    }, delay);
}
```

如果您希望倒计时到零（`10... 9... 8...`倒计时到`2... 1... 0!`）并有适当的 1 秒延迟，您会感到惊讶，因为此代码发出`-1`！十一次！问题与关闭有关；循环结束时，`i`变量为`-1`，因此当等待（超时）函数运行时，`i`具有*该*值。这可以通过多种方式解决，但使用`let`代替`var`是最简单的解决方案；每个闭包将捕获循环变量的不同副本，并且倒计时将正确：

```
// Source file: src/let_const.js

var delay = 0;
for (let i = 10; i >= 0; i--) { // *minimal fix!*
    delay += 1000;
    setTimeout(() => {
        console.log(i + (i > 0 ? "..." : "!"));
    }, delay);
}
```

For more on blocks and `let`/`const`, check out [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/block](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/block), [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/const](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/const) and [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let) at MDN.

# 传播和连接价值观

新操作符`...`允许您将数组、字符串或对象展开为独立的值。这一点很难解释，也很难说明，因此让我们来看一些基本示例：

```
// Source file: src/spread_and_rest.js

let values = [22, 9, 60, 12, 4, 56];

const maxOfValues = Math.max(...values); // 60
const minOfValues = Math.min(...values); // 4
```

您还可以使用它来复制或连接阵列：

```
// Source file: src/spread_and_rest.js

let arr1 = [1, 1, 2, 3];
let arr2 = [13, 21, 34];

let copyOfArr1 = [...arr1]; // a copy of arr1 is created

let fibArray = [0, ...arr1, 5, 8, ...arr2]; // first 10 Fibonacci numbers
```

If you apply the spread operator to a string, the effect is to separate it into individual characters, much as if you had used `.split()`; for instance, `console.log(..."JS")` shows `["J", "S"]`, so this case isn't particularly interesting.

您还可以使用它来克隆或修改对象；事实上，这是我们稍后将再次遇到的用法，在[第 8 章](08.html)中*扩展您的应用程序*，主要是在我们使用`Redux`时：

```
// Source file: src/spread_and_rest.js

let person = { name: "Juan", age: 24 };

let copyOfPerson = { ...person }; // same data as in the person object

let expandedPerson = { ...person, sister: "María" };
// {name: "Juan", age: 24, sister: "María"}
```

这对于使用未定义数量的参数编写函数也很有用，避免了旧式的使用`arguments`伪数组。在这里，它不是将一个元素拆分为多个元素，而是将几个不同的元素合并到一个数组中；类似于`function many(a, ...several, b, c)`的内容是不允许的：

```
// Source file: src/spread_and_rest.js

function average(...nums: Array&lt;number>): number {
    let sum = 0;
    for (let i = 0; i &lt; nums.length; i++) {
        sum += nums[i];
    }
    return sum / nums.length;
};

console.log(average(22, 9, 60, 12, 4, 56)); // 27.166667
```

If you are wondering why I called `arguments` a pseudo-array, the reason is because it *looks* somewhat like an array, but only provides the `.length` property; see more at [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments). In any case, you won't be dealing with it, thanks to the spread operator.

# 分解数组和对象

现在 JS 提供的另一个强大的构造是解构赋值。这也比展示更难解释，所以再次让我们直接来看一些例子！最简单的情况是将数组拆分为变量：

```
let [a, b, c] = [22, 9, 60]; // *a=22, b=9, c=60*
```

更有趣的是，您可以交换或旋转变量！根据前面的示例，我们将得到以下内容：

```
[a, b] = [b, a];       // *a and b are swapped! a=9, b=22*
[c, b, a] = [b, a, c]; // *and now a=60, b=9, c=22*
```

您还可以为缺少的变量指定默认值，忽略您不关心的值，甚至应用`rest`运算符：

```
// *default values*
let [d, e = 1, f = 2, g] = [12, 4]; // *d=12, e=4, f=2, g=undefined*

// *ignoring values*
let [h, , i] = [13, 21, 34];       // *h=13, i=34*

// *using with rest*
let [j, k, ...l] = [2, 3, 5, 8];   // *j=2, k=3, l=[5,8]*
```

这也可以应用于对象，允许您拾取属性，甚至重命名它们，如下面代码中的标志和名称。默认情况下也可以指定值：

```
let obj = { p: 1, q: true, r: "FK" };

let { p, r } = obj;             // p=1, r="FK"
let { q: flag, r: name } = obj; // Renaming: flag=true, name="FK"
let { q, t = "India" } = obj;   // q=true; t="India"
```

一个有趣的用法是允许函数一次返回多个值。如果要返回（例如）两个值，可以返回一个数组或一个对象，并使用 destructuring 在一句话中分隔返回的值：

```
function minAndMax1(...nums) {
    return [Math.min(...nums), Math.max(...nums)];
}

let [small1, big1] = minAndMax1(22, 9, 60, 12, 4, 56);
```

或者，您可以使用一个对象和一个箭头功能，只是为了多样性；请注意我们使用的额外括号，因为我们返回的是一个对象。顺便说一下，我们还在重命名属性：

```
const minAndMax2 = (...nums) => ({
    min: Math.min(...nums),
    max: Math.max(...nums)
});

let { min: small2, max: big2 } = minAndMax2(22, 9, 60, 12, 4, 56);
```

You can find many examples of spreading and destructuring in MDN if you visit the following links: 

[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax) 
[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters)  
[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment)

# 做功

最后，让我们介绍一个新添加的操作符`**`，它代表功率计算：

```
let a = 2 ** 3; // *8* 
```

这只是现有`Math.pow()`功能的快捷方式：

```
let b = Math.pow(2, 3); // also 8
```

还存在一个指数赋值运算符，类似于`+=`、`-=`等：

```
let c = 4;
c **= 3; // *4 cubed: 64*
```

这是一个你可能不会经常使用的操作符，除非你处理利息计算和金融公式。最后提醒：正如在数学中一样，求幂运算符从右向左分组，因此将`2 ** 3 ** 4`计算为`2 ** (3 ** 4)`；小心！

# 定义功能

JS 从定义上讲不是一种函数式编程语言，但它实际上包含了一种成熟的函数式语言所能提供的一切。在我们的例子中，我们不会深入研究这个编程范例，但是让我们看看一些重要的特性，它们将简化您的工作。

# 怎么做。。。

JS 总是包含函数，可以用多种方式定义函数，但现在又有一种函数定义风格，可以提供多种优势；继续读下去。

# 写箭头函数

在阅读了上一段之后，您是否尝试过计算 JS 中定义函数的方法有多少种？事实上，这比你想象的要多得多，至少包括以下几点：

*   *命名函数声明*：`function one(...) {...}`
*   *匿名函数表达式*：`var two = function(...) {...}`
*   *命名函数表达式*：`var three = function someName(...) {...}`
*   *立即调用的表达式*：`var four = (function() { ...; return function(...) {...}; })()`
*   *函数构造函数*：`var five = new Function(...)`
*   *新款，一箭功能*：`var six = (...) => {...}`

你可能已经习惯了第一个三重唱，而接下来的两个可能并不常见。然而，我们现在关心的是最后一种样式，称为*箭头函数*。箭头函数的工作方式与以其他方式定义的函数基本相同，但有三个关键区别：

*   箭头函数没有`arguments`对象
*   即使未提供`return`语句，箭头函数也可能隐式返回值
*   箭头函数不绑定`this`的值

In fact, there are some more differences, including the fact that you cannot use arrow functions as constructors, they don't have a prototype property, and they cannot be used as generators. For more on this, see [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions).

正如我们在本章前面所看到的，第一个差异是通过使用扩展运算符来处理的。那么，让我们关注最后两项，它们更有趣。

# 返回值

arrow 函数可能有一个代码块，其中包含一些返回语句，也可能只是一个表达式。前一种情况与定义函数的标准方式最为相似；例如，我们可以编写一个函数来添加三个数字，如下所示，使用这两种样式。我们应该将数据类型添加到定义中，但我们很快就会开始：

```
function addThree1 (x, y, z) {
    const s = x + y + z;
    return s;
}

const addThree2 = (x, y, z) => {
    const s = x + y + z;
    return s;
};
```

如果您只需返回一个表达式，就可以编写一个等价的版本；只需在箭头后立即写下想要返回的内容：

```
const addThree3 = (x, y, z) => x + y + z;
```

有一种特殊情况：如果要返回一个对象，那么必须将其放在括号内，否则 JS 会将其与代码块混淆。对于`Redux`（我们将在[第 8 章](08.html)*扩展应用程序*的*管理状态下使用 Redux*部分看到），您可能需要编写一个*动作创建者*，返回一个*动作*即一个带有`type`的对象属性，可能还有更多：

```
const simpleAction = (t, d) => {
    type: t;
    data: d;
};

console.log(simpleAction("ADD_KEY", 229)); // *undefined*
```

这里发生了什么事？JS 将大括号解释为一个块，然后将`type`和`data`视为*标签*（参见[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/label](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/label) 如果你不记得这些！），那么整个*对象*实际上是一个不返回任何内容的块，JS 返回一个`undefined`结果。只需将对象放在括号中即可正常工作：

```
const simpleAction = (t, d) => ({
    type: t;
    data: d;
});

// *this works as expected*
```

# 在 arrow 函数中处理此问题

一个众所周知的 JS 问题是如何处理`this`，因为它的值并不总是你所期望的！现代 JS 使用箭头函数解决了这个问题，箭头函数与普通函数不同，它继承了正确的`this`值。一个众所周知的例子如下：您可能希望在几秒钟后显示以下代码`JAVASCRIPT`，但会显示`undefined`（请不要介意，您可以用更简单的方式编码`show()`；我想强调的是一个一般性问题，而不是一个特定的解决方案）：

```
// Source file: src/arrow_functions.js

function Show(value: mixed): void {
    this.saved = value;
 setTimeout(function() {
 console.log(this.saved);
 }, 1000);
}

let w = new Show("Doesn't work..."); // *instead, "undefined" is shown*
```

有三种解决方法：

*   使用`.bind()`将超时功能正确绑定到`this`的正确值
*   使用闭包并定义局部变量（通常称为`that`）来存储并保存`this`的原始值
*   使用箭头功能，无需任何额外工作即可工作

我们可以在以下代码中看到这三种解决方案：

```
// Source file: src/arrow_functions.js

function Show1(value: mixed): void {
    this.saved = value;
    setTimeout(
 function() {
 console.log(this.saved);
 }.bind(this),
        1000
    );
}

function Show2(value: mixed): void {
    this.saved = value;
    const that = this;
    setTimeout(function() {
        console.log(that.saved);
    }, 2000);
}

function Show3(value: mixed): void {
    this.saved = value;
    setTimeout(() => {
 console.log(this.saved);
 }, 3000);
}

let x = new Show1("This");
let y = new Show2("always");
let z = new Show3("works");
```

We will get to see the `.bind()` idea in React in the *Defining Components* section of [Chapter 6](06.html), *Developing with React,* where we will deal with `this` related problems.

# 定义箭头函数的类型

最后，让我们看看如何为 arrow 函数定义类型。我们可以在前面的*基本类型的*部分中看到更多的`toString()`函数的实现：

```
// Source file: src/types_basic.js

const toString2 = (x: number): string => {
    return x + "";
};

type numberToString = number => string;
const toString3: numberToString = (x: number) => String(x);
```

# 定义默认参数值

函数的一个有趣的新特性是可以为缺少的参数定义默认值。我们可以编写一个函数来计算*n<sup class="calibre26">th</sup>*根，默认情况下，该函数将计算平方根：

```
// Source file: src/default_arguments.js

function root(a: number, n: number = 2): number {
 return a ** (1 / n);
}

// Or, equivalently:
// const root = (a: number, n: number = 2): number => a ** (1 / n);

console.log(root(125, 3));       // *5*
console.log(root(4));            // *2*
console.log(root(9, undefined)); // *3*
```

如第三个示例所示，传递`undefined`等同于忽略该值。这意味着您可以为任何参数提供默认值：`someFunction(undefined, 22, undefined)`之类的调用将为第一个和第三个参数使用默认值，22 作为第二个参数。

默认值也可以用于方法和构造函数。在下面的`Counter`类中，`inc()`方法如果没有提供数字，将计数器增加`1`。此外，在构造计数器时，如果不提供初始值，将使用零：

```
// Source file: src/default_arguments.js

class Counter {
    count: number; // *required by Flow*

    constructor(i: number = 0) {
        this.count = 0;
    }

    inc(n: number = 1) {
        this.count += n;
    }
}

const cnt = new Counter();
cnt.inc(3);
cnt.inc();
cnt.inc();

console.log(cnt.count); // 5
```

最后一个细节是，您可以使用前面参数中的值来计算后面参数的默认值。一个简单的无意义的例子说明了这一点；我将跳过类型声明，因为它们与此处无关：

```
// Source file: src/default_arguments.js

function nonsense(a = 2, b = a + 1, c = a * b, d = 9) {
    console.log(a, b, c, d);
}

nonsense(1, 2, 3, 4);                 // *1 2 3 4*
nonsense();                           // *2 3 6 9*
nonsense(undefined, 4, undefined, 6); // *2 4 8 6*
```

使用默认值是简化函数使用的一种非常实用的方法，特别是在具有许多参数的复杂 API 的情况下，但允许用户忽略任何合理的值。

# 功能性编程

函数式编程通常比命令式编程更具声明性，更高级的函数可以以更简单、直接的方式完成处理。在这里，让我们看看几个函数式编程技术，您应该真正为自己的代码采用这些技术。

# 怎么做。。。

函数式编程一直存在于 JS 中，但该语言的最新版本添加了其他语言的众所周知的特性，您可以使用这些特性来缩短代码，同时也使其更易于理解。

# 将数组缩减为值

一个简单的问题：你在一个数组中循环了多少次，比如说，添加它的数字？可能性是，很多次！这种操作——通过一个数组元素一个元素地执行一些计算，以获得最终结果，这是我们将以功能方式实现的第一个操作，带有`.reduce()`。

The name `.reduce()` pretty much tells us what it does: it *reduces* a complete array to a single value. In other languages, this operation is called *fold*.

最常见的例子，大多数文本和文章都会显示，是对数组的所有元素求和，因为我有传统的想法，让我们这样做吧！必须为计算提供初始值（在本例中，因为我们需要求和，所以它将是零）和一个函数，该函数将在访问每个数组元素时更新计算值：

```
// Source file: src/map_filter_reduce.js

const someArray: Array&lt;number> = [22, 9, 60, 12, 4, 56];

const totalSum = someArray.reduce(
    (acc: number, val: number) => acc + val,
    0
); // *163*
```

它是如何工作的？在内部，`.reduce()`以获取初始值（本例中为零）开始，然后调用缩减函数，给出累计总数（`acc`和数组的第一个元素（`val`。函数必须更新累计总数：在这种情况下，它将计算*0*+*22*，因此下一个总数将是`*22*`。之后，`.reduce()`会再次调用该函数，传递它 22（更新后的总数）和`9`（第二个数组元素），`31`将成为新的累计总数。这将在整个数组中系统地进行，直到计算出最终值（`163`。请注意，循环控制的所有方面都是自动的，因此您不可能在某个地方出错，而且代码是非常声明性的：您几乎可以将其理解为“通过将所有元素相加，从零开始，将`someArray`减少为一个值”。

There are some more possibilities for `.reduce()`: check out [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce) for more information. You can also use `.reduceRight()`, which essentially works in the same fashion, but starting at the end of the array and proceeding backwards; see [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/ReduceRight](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/ReduceRight) for more information.

当然，您不仅限于处理数字数组；您可以处理任何数据类型，最终结果也可以是任何类型。例如，您可以使用`.reduce()`将名称数组转换为 HTML 项目符号列表，如下所示：

```
// Source file: src/map_filter_reduce.js

const names = ["Juan", "María", "Sylvia", "Federico"];

const bulletedList =
    "&lt;ul>" +
    names.reduce((acc, val) => `${acc}&lt;li>${val}&lt;/li>`, "") +
    "&lt;/ul>";

// *&lt;ul>&lt;li>Juan&lt;/li>&lt;li>María&lt;/li>&lt;li>Sylvia&lt;/li>&lt;li>Federico&lt;/li>&lt;/ul>*
```

只要稍加练习，就可以肯定地说，您可能能够使用更短、更清晰的代码将数组上的任何类型的计算转换为`.reduce()`调用。

# 映射数组

第二种非常常见的操作是遍历一个数组，并通过对每个元素进行某种处理来生成一个新数组。幸运的是，我们还可以通过使用`.map()`在功能上实现这一点。该函数的工作方式很简单：给定一个数组和一个函数，它将该函数应用于数组的每个元素，并生成一个包含每个调用结果的新数组。

假设我们调用了一个 web 服务并返回了一个包含人员数据的数组。我们只是想要他们的年龄，这样我们就可以做一些其他的过程；比如，计算使用该服务的人的平均年龄。我们可以简单地做到这一点：

```
// Source file: src/map_filter_reduce.js

type person = { name: string, sex: string, age: number };

const family: Array&lt;person> = [
    { name: "Huey", sex: "M", age: 7 },
    { name: "Dewey", sex: "M", age: 8 },
    { name: "Louie", sex: "M", age: 9 },
    { name: "Daisy", sex: "F", age: 25 },
    { name: "Donald", sex: "M", age: 30 },
    { name: "Della", sex: "F", age: 30 }
];

const ages = family.map(x => x.age);
//  [*7, 8, 9, 25, 30, 30*]
```

使用`.map()`与`.reduce()`一样，是处理数组的一种更短、更安全的方法。事实上，大多数情况下，这两个操作是一个接一个地使用的，一些可能的`.filter()`操作混合在一起，以选择应该或不应该处理什么；让我们现在开始吧。

The `.map()` operation also has some extra features; see [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map) for a complete description. Also, if you really want to affect the original array, rather than producing a new one, take a look at the `.forEach()` method at [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach).

# 过滤阵列

我们正在考虑的第三个操作是`.filter()`，它将扫描一个完整的数组并生成一个新的数组，但只能使用满足某些条件的元素，正如您通过函数给出的那样。按照我们的示例，我们可以通过编写以下内容，仅选择服务结果中的男性：

```
// Source file: src/map_filter_reduce.js

const males = family.filter(x => x.sex === "M");
// *an array with Huey, Dewey, Louie, and Donald records*
```

有了这三个操作，只需很少的代码就可以简单地执行调用序列并生成结果。例如，我们能找出家中最大的男性的年龄吗？是的，只需几行代码即可快速完成：

```
// Source file: src/map_filter_reduce.js

const eldestMaleAge = family
    .filter(x => x.sex === "M")
    .map(x => x.age)
    .reduce((acc, val) => Math.max(acc, val), 0); // *30*
```

这种链式操作非常常见：在本例中，我们首先选择雄性，然后选择它们的年龄，然后将数组缩减为单个值，最大值：neat！

# 从函数生成函数

让我们通过查看一个典型的函数编程工具来完成函数方面的这一部分：**高阶函数**（**HOFs**）：生成结果函数的函数！在后面的章节中，我们将实际遇到 HOFs 的更多用法；这里，让我们做一个简单的例子。

The following example is taken from my previous book for Packt, *Mastering JavaScript Functional Programming*. Chapter 2, *Thinking Functionally - A First Example*, and Chapter 6, *Producing Functions - Higher-Order Functions* will be of particular interest with regard to HOFs. See more at [www.packtpub.com/web-development/mastering-javascript-functional-programming](https://www.packtpub.com/web-development/mastering-javascript-functional-programming).

假设您开发了一个电子商务站点。用户选择产品，将其添加到他/她的购物车中，最后单击“账单我”按钮，以便向他/她的信用卡收费。但是，如果用户单击两次或更多次，他/她将多次收到账单，而不是一次。您的应用程序可能在其 HTML 中包含以下内容：

```
&lt;button id="billBtn" onclick="billUser(sales, data)">Bill me&lt;/button>
```

在脚本中的某个地方，会有如下代码。我不包括数据类型声明，因为它们与我们的代码无关；我们真的不知道或不关心`billUser()`的论点是什么：

```
function billUser(sales, data) {
    window.alert("Billing the user...");
    // *actually bill the user*
}
```

现在，你能做些什么来避免重复点击按钮？有几种不太好的解决方案，例如：

*   什么也不做，只是提醒用户，希望他们注意！
*   使用全局标志表示用户单击了一次。
*   用户点击后，从按钮上移除`onclick`处理程序。
*   将`onclick`处理程序更改为不会向用户计费的其他处理程序。

然而，所有这些解决方案都有些欠缺，依赖于全局对象，需要您处理计费功能，与用户视图紧密相连，等等。由于要求某些函数只执行一次并不是一个奇怪的要求，让我们具体说明以下内容：

*   原来的函数应该保持不变，不再做它的事情
*   我们需要一个新函数，它将调用原始函数，但只调用一次
*   我们需要一个通用的解决方案，以便在不同的情况下应用它

我们将编写一个函数，`once()`，它将把一个函数作为它的参数，并生成一个新函数，但它只会*完成它的工作*一次。逻辑不长，但仔细研究：

```
// Source file: src/functional_code.js

const once = fn => {
 let done = false;
 return (...args) => {
 if (!done) {
 done = true;
 fn(...args);
 }
    };
};
```

我们对新功能的一些分析如下：

*   定义表明，`once()`采用泛型函数（`fn()`作为参数
*   `return`语句显示`once()`返回另一个函数
*   我们使用扩展运算符来处理具有任意数量参数的函数
*   我们正在为`done`变量使用闭包，它会记住`fn()`是否被调用

I left out type definitions for clarity, but in the source code provided with this book, full definitions are provided. Can you work them out on your own? A tip: the output of the `once()` function should be the same type as the input to it.

有了这个新功能，您可以对按钮进行如下编码。当用户点击按钮时，将以`(sales, data)`作为参数调用的函数不是`billUser()`，而是将`once()`应用于`billUser()`的结果，这将导致一个只调用`billUser()`一次的新函数：

```
&lt;button id="billButton" onclick="once(billUser)(sales, data)">
Bill me
&lt;/button>;
```

这是高阶函数的概念：接收函数作为参数并生成新函数作为结果的函数。通常，我们希望实现三种可能的转换：

*   *包装功能*：我们这样做是为了让它们保留原来的功能，但增加一些新功能；例如，我们可以添加日志记录或计时，以便原始函数仍然执行其操作，但记录其参数或生成计时信息
*   *修改功能*：我们这样做是为了在一些关键点上与原版本有所不同；这就是我们对`once()`所做的，它生成了一个只运行一次的函数的新版本
*   *其他变更*：这些变更包括将函数转换为承诺（我们将在`Node`中看到这一点，在[第 3 章](03.html)的*使用承诺而不是错误优先回调*部分中，*与节点*一起开发等等

# 紧凑地执行异步调用

当 Ajax 开始出现时，它通常与回调一起使用，回调本身可能有自己的回调，其中包含更多的回调，这最终导致创造了术语*回调地狱*。为了摆脱这种不切实际的编程风格，出现了另外两种处理服务和异步调用的风格：承诺和`async`/`await`——尽管事实上，后者也使用承诺！

# 开始

让我们通过一个简单的示例来了解这两种样式。这本书是在三个不同的城市写的：印度浦那；英国伦敦；乌拉圭的蒙得维的亚，让我们做一些与这些城市相关的工作。我们将编写代码来获取这些城市的天气信息：

*   就为了蒙得维的亚
*   先是伦敦，然后是浦那，这样第二次通话直到第一次通话结束才开始
*   对于三个并行的城市，以便同时处理所有三个请求，通过重叠获得时间

我们不会深入讨论诸如使用这个或那个 API、获取私钥等细节，我们只会通过访问免费的*天气频道*页面来伪造它。我们将在`Node`中使用`axios`模块对所有编码使用以下定义；现在不要担心细节：

```
// Source file: src/get_service_with_promises.js

const axios = require("axios");

const BASE_URL = "https://weather.com/en-IN/weather/today/l/";

// *latitude and longitude data for our three cities*
const MONTEVIDEO_UY = "-34.90,-56.16";
const LONDON_EN = "51.51,-0.13";
const PUNE_IN = "18.52,73.86";

const getWeather = coords => axios.get(`${BASE_URL}${coords}`);
```

`BASE_URL`常量提供基本网址，您必须将所需城市的坐标（纬度、经度）附加到该网址。就其本身而言，我们将获得一个类似以下屏幕截图所示的页面：

![](assets/f27bb572-7800-4640-8d02-86e62e9c0190.png)

we will be using Ajax to get weather information for cities

在现实生活中，我们不会得到一个网页，而是一个 API，然后处理返回的结果。在我们的例子中，因为我们实际上并不关心数据，但是对于我们将用来进行调用的方法，我们只需要显示一些平庸的信息就可以了，比如返回了多少字节。完全没有用，我同意，但这对于我们的例子来说已经足够了！

We'll be using `axios` in several places in this book, so you may want to read its documentation, which can be found at [https://github.com/axios/axios](https://github.com/axios/axios).

# 怎么做。。。

使用函数作为回调是处理异步调用的最经典的方法，但这有几个缺点，例如代码更难阅读，并且在处理一些不太常见的情况时会遇到一系列困难。在这里，我们将研究两种不同的工作方式。

# 用承诺实现 Ajax 调用

我们可以进行 web 服务调用的第一种方法是使用承诺，它们是（直到出现更现代的`async`/`await`语句，我们将在下一节中看到）最受欢迎的方法。承诺早在一段时间前就已经存在（首先是在 2011 年左右通过 jQuery 的延迟对象，然后是通过`BlueBird`或`Q`等库），但在最近的 JS 版本中，它们变成了原生的。既然承诺不能真正被认为是新的东西，那么让我们看看一些例子，这样我们就可以继续使用更现代的工作方式。不，我们甚至不会考虑比承诺更久远，直接使用回调！

Do native promises imply that libraries won't be needed again? That's a tricky question! JS promises are quite basic, and most libraries add several methods that can simplify your coding. (See [http://bluebirdjs.com/docs/api-reference.html](http://bluebirdjs.com/docs/api-reference.html) or [https://github.com/kriskowal/q/wiki/API-Reference](https://github.com/kriskowal/q/wiki/API-Reference) for such features from `Bluebird` or `Q`.) Hence, while you may do perfectly well with native promises, in some circumstances, you may want to keep using a library. 

如果我们使用前面定义的`getWeather()`函数，获取蒙得维的亚的天气数据非常简单：

```
// Source file: src/get_service_with_promises.js

function getMontevideo() {
    getWeather(MONTEVIDEO_UY)
        .then(result => {
            console.log("Montevideo, with promises");
            console.log(`Montevideo: ${result.data.length} bytes`);
        })
        .catch(error => console.log(error.message));
}
```

`getWeather()`函数实际上返回一个承诺；其`.then()`方法对应成功案例，`.catch()`对应任何错误情况。

获取连续两个城市的数据也很简单。在第一个请求成功之前，我们不希望启动第二个请求，这将导致以下方案：

```
// Source file: src/get_service_with_promises.js

function getLondonAndPuneInSeries() {
 getWeather(LONDON_EN)
 .then(londonData => {
 getWeather(PUNE_IN)
 .then(puneData => {
                    console.log("London and Pune, in series");
                    console.log(`London: ${londonData.data.length} b`);
                    console.log(`Pune: ${puneData.data.length} b`);
                })
                .catch(error => {
                    console.log("Error getting Pune...", error.message);
                });
        })
        .catch(error => {
            console.log("Error getting London...", error.message);
        });
}
```

This is not the only way to program such a series of calls, but since we won't actually be directly working with promises, let's just skip the alternatives.

最后，为了并行调用并优化时间，将使用`Promise.all()`方法在每个城市的三个单独的承诺中建立一个新的承诺。如果所有的电话都成功了，更大的承诺也会成功；如果三个调用中的任何一个失败，那么失败也将是全局结果：

For more information on `Promise.all()`, check out [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all). If you'd rather build a promise that succeeds when *any* (instead of *all*) of the involved promises succeeds, you should use `Promise.race()`; see [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/race](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/race).

```
// Source file: src/get_service_with_promises.js

function getCitiesInParallel() {
    const montevideoGet = getWeather(MONTEVIDEO_UY);
    const londonGet = getWeather(LONDON_EN);
    const puneGet = getWeather(PUNE_IN);

    Promise.all([montevideoGet, londonGet, puneGet])
 .then(([montevideoData, londonData, puneData]) => {
            console.log("All three cities in parallel, with promises");
            console.log(`Montevideo: ${montevideoData.data.length} b`);
            console.log(`London: ${londonData.data.length} b`);
            console.log(`Pune: ${puneData.data.length} b`);
        })
        .catch(error => {
            console.log(error.message);
        });
}
```

请注意，我们如何使用分解分配来获取每个城市的数据。调用这些函数的结果可能如下：；为了清晰起见，我添加了一些间距：

```
Montevideo, with promises
Montevideo: 353277 bytes

London and Pune, in series
London: 356537 b
Pune: 351679 b

All three cities in parallel, with promises
Montevideo: 351294 b
London: 356516 b
Pune: 351679 b
```

用承诺组织 web 调用是一种简单的方法，但可能嵌套的`.then()`方法的使用可能会变得难以理解，因此我们确实应该考虑另一种方法。我们将在下一节中这样做。

# 使用 async/await 进行 Ajax 调用

第二种方式，`async`/`await`更为现代，但在内心深处，实际上也适用于承诺，但简化了工作。我们应该考虑一些重要的定义：

*   `async`函数将包含一些`await`表达式，具体取决于承诺
*   `await`表达式暂停`async`函数的执行，直到承诺得到解决
*   承诺解析后，处理将恢复，并返回值
*   如果产生错误，可通过`try ... catch`捕获
*   `await`只能在异步函数中使用

这对我们的编码有什么影响？让我们回顾一下我们的三个例子。获取单个城市的信息很简单：

```
// Source file: src/get_service_with_async_await.js async function getMontevideo() {
    try {
        const montevideoData = await getWeather(MONTEVIDEO_UY);
        console.log("Montevideo, with async/await");
        console.log(`Montevideo: ${montevideoData.data.length} bytes`);
    } catch (error) {
        console.log(error.message);
    }
}
```

我们仍然在使用一个承诺（由`axios`通过`getWeather()`调用返回的承诺），但现在代码看起来更熟悉了：您等待结果的出现，然后处理它们—看起来好像调用是同步的！ 

按顺序获取伦敦和普纳的数据也是非常直接的：你等待第一个城市的数据，然后等待第二个城市的数据，然后进行最后的处理；什么更简单？让我们看看代码：

```
// Source file: src/get_service_with_async_await.js async function getLondonAndPuneInSeries() {
    try {
        const londonData = await getWeather(LONDON_EN);
 const puneData = await getWeather(PUNE_IN);
        console.log("London and Pune, in series");
        console.log(`London: ${londonData.data.length} b`);
        console.log(`Pune: ${puneData.data.length} b`);
    } catch (error) {
        console.log(error.message);
    }
}
```

最后，并行获取所有数据还取决于我们在上一节中看到的`Promise.all()`方法：

```
// Source file: src/get_service_with_async_await.js

async function getCitiesInParallel() {
    try {
        const montevideoGet = getWeather(MONTEVIDEO_UY);
        const londonGet = getWeather(LONDON_EN);
        const puneGet = getWeather(PUNE_IN);

 const [montevideoData, londonData, puneData] = await Promise.all([
 montevideoGet,
 londonGet,
 puneGet
 ]);

        console.log("All three cities in parallel, with async/await");
        console.log(`Montevideo: ${montevideoData.data.length} b`);
        console.log(`London: ${londonData.data.length} b`);
        console.log(`Pune: ${puneData.data.length} b`);
    } catch (error) {
        console.log(error.message);
    }
}
```

并行调用代码与 pure promises 的版本非常相似：这里唯一的区别是您使用`await`结果，而不是使用`.then()`

我们已经看到了两种处理异步服务调用的方法。这两种语言都被大量使用，但在本文中，我们倾向于使用`async`/`await`，因为生成的代码看起来更清晰，额外负担更少。

# 使用对象和类

如果你想展开一场生动的讨论，可以问一组 web 开发人员：*JavaScript 是一种面向对象的语言，还是仅仅是一种基于对象的语言？*，快撤退！这场讨论虽然可能很神秘，但已经年复一年地进行着，而且可能会持续一段时间。基于对象的观点的一个常见论点是，JS 不包括类和继承，而是面向原型的。这个论点现在已经无效了，因为 JS 的最新版本提供了两个新的关键字，`class`和`extends`，它们的行为方式与其他*官方*OO 语言中的对应词几乎相同。但是，请记住，新类只是现有基于原型的继承基础上的*语法糖*；没有真正引入新的范式或模型。

JS could do inheritance, but it was harder. To see how this was achieved in the old fashioned way, look at [https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Inheritance](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Inheritance), and you'll have to agree that using `class` and `extends` is much better than assigning prototypes and constructors by hand!

# 怎么做。。。

如果您使用了其他常用编程语言，如 java、C++和 Python，则类和对象的概念应该已经明确了；我们将假设情况就是这样，看看这些概念在现代 JS 中是如何应用的。

# 定义类

让我们从基础开始，看看在现代 JS 中类是如何定义的。之后，我们将转到其他有趣的功能，但您可能不会经常使用这些功能。要定义类，我们只需编写如下内容：

```
// Source file: src/class_persons.js

class Person {
    constructor(first, last) {
        this.first = first;
        this.last = last;
    }

    initials() {
        return `${this.first[0]}${this.last[0]}`;
    }

    fullName() {
        return `${this.first} ${this.last}`;
    }
}

let pp = new Person("Erika", "Mustermann");
console.log(pp); // *Person {first: "Erika", last: "Mustermann"}*
console.log(pp.initials()); // *"EM"*
console.log(pp.fullName()); // *"Erika Mustermann"*
```

新的语法比在旧版本的 JS 中为构造函数使用函数要清晰得多。我们编写了一个`.constructor()`方法，它将初始化新对象，并且我们定义了两个方法`.initials()`和`.fullName()`，这两个方法将可用于`Person`类的所有实例。

We are following the usual convention of using an initial uppercase letter for class names and initial lowercase letters for variables, functions, methods, and so on.

# 扩展类

我们还可以扩展以前存在的类。引用原构造函数使用`super()`，引用父方法使用`super.method()`；参见此处`.fullName()`的重新定义：

```
// Source file: src/class_persons.js

class Developer extends Person {
    constructor(first, last, language) {
        super(first, last);
        this.language = language;
    }

    fullName() {
 // *redefines the original method*
        return `${super.fullName()}, ${this.language} dev`;
    }
}

let dd = new Developer("John", "Doe", "JS");
console.log(dd); // *Developer {first: "John", last: "Doe", language: "JS"}*
console.log(dd.initials()); // *"JD"*
console.log(dd.fullName()); // *"John Doe, JS dev"*
```

您不仅限于扩展自己的类；您还可以扩展 JS 版本：

```
// Source file: src/class_persons.js

class ExtDate extends Date {
    fullDate() {
        const months = [
            "JAN",
            "FEB",
            "MAR",
            "APR",
            "MAY",
            "JUN",
            "JUL",
            "AUG",
            "SEP",
            "OCT",
            "NOV",
            "DEC"
        ];

        return (
            months[this.getMonth()] + 
            " " +
            String(this.getDate()).padStart(2, "0") +
            " " +
            this.getFullYear()
        );
    }
}

console.log(new ExtDate().fullDate()); // *"MAY 01 2018"*
```

如果不需要特殊的构造函数，可以省略它；默认情况下将调用父级的构造函数。

# 实现接口

JS 不允许多重继承，也不提供实现接口的功能。但是，您可以通过使用*mixins*、使用更高阶函数（正如我们前面在*从函数*生成函数一节中看到的那样）以及将类作为参数并向其添加方法（而不是属性）来构建自己的 ersatz 接口。即使您没有实际使用它，我们也来看看一个简短的示例，因为它提供了另一个以函数方式工作的示例。

Read [https://developer.mozilla.org/en-US/docs/Glossary/Mixin](https://developer.mozilla.org/en-US/docs/Glossary/Mixin) for a definition. As an alternative, you can use TypeScript; see [https://www.typescriptlang.org/docs/handbook/interfaces.html](https://www.typescriptlang.org/docs/handbook/interfaces.html) for the latter.

让我们再一次上前面的`Person`课。让我们设想两个接口：一个接口可以为对象提供一个生成其自身 JSON 版本的方法，另一个接口可以告诉您一个对象有多少属性。（好的，这些例子都不太有用，但请耐心听我说，我们将使用的方法才是最重要的。）我们将定义两个函数，它们接收一个类作为参数，并作为结果返回它的扩展版本：

```
// Source file: src/class_persons.js

const toJsonMixin = base =>
    class extends base {
        toJson() {
            return JSON.stringify(this);
        }
    };

const countKeysMixin = base =>
    class extends base {
        countKeys() {
            return Object.keys(this).length;
        }
    };
```

现在，我们可以使用这两个 mixin 创建一个新的`PersonWithMixins`类（不是一个很好的名称，是吗？），我们甚至可以提供一个不同的实现，就像`.toJson()`方法一样。一个非常重要的细节是，要扩展的类实际上是函数调用的结果；过来看：

```
// Source file: src/class_persons.js

class PersonWithTwoMixins extends toJsonMixin(countKeysMixin(Person)) {
    toJson() { 
        // *redefine the method, just for the sake of it*
        return "NEW TOJSON " + super.toJson();
    }
}

let p2m = new PersonWithTwoMixins("Jane", "Roe");
console.log(p2m);
console.log(p2m.toJson());    // *NEW TOJSON {"first":"Jane","last":"Roe"}*
console.log(p2m.countKeys()); // *2*
```

能够以这种方式向对象添加方法可以解决实现接口的问题。这对于展示 JS 如何让您以一种高级风格工作非常重要，似乎超出了语言本身所提供的功能，这样您就不会感觉到语言在试图解决问题时阻碍了您。

Using `Flow`, we will get to use the usual Java-style implements and interface declarations, but they will only be used for type checking; see the *Implementing interfaces* section for more details.

# 静态方法

通常，有些实用程序函数与类相关，但与特定对象实例无关。在这种情况下，您可以将这些函数定义为静态方法，它们将以一种简单的方式提供。例如，我们可以创建一个`.getMonthName()`方法，它将返回给定月份的名称：

```
// Source file: src/class_persons.js

class ExtDate extends Date {
    static getMonthName(m) {
        const months = [
            "JAN",
            "FEB",
            .
            .
            .
            "DEC"
        ];
        return months[m];
    }
    fullDate2() {
        return (
            ExtDate.getMonthName(this.getMonth()) +
            " " +
            String(this.getDate()).padStart(2, "0") +
            " " +
            this.getFullYear()
        );
    }
}

console.log(new ExtDate().fullDate2()); // *"MAY 01 2018"*
console.log(ExtDate.getMonthName(8));  // *"SEP"*
```

静态方法必须通过提供类名来访问；由于它们与对象不对应，因此不能与此对象或对象本身一起使用。

# 使用 getter 和 setter

JS 现在允许您定义*动态*属性，这些属性不是对象中的存储值，而是当场计算的。例如，在前面的`Person`类中，我们可以为`lastFirst`设置一个*getter*，如下所示：

```
// Source file: src/class_persons.js

class Person {
    constructor(first, last) {
        this.first = first;
        this.last = last;
    }

    // initials() method snipped out...

    fullName() {
        return `${this.first} ${this.last}`;
    }

 get lastFirst() {
 return `${this.last}, ${this.first}`;
 }

    // *see below...*
}
```

使用此定义，您可以访问`.lastFirst`属性，就像它实际上是对象的属性一样；不需要括号：

```
pp = new Person("Jean", "Dupont");
console.log(pp.fullName()); // *"Jean Dupont"*
console.log(pp.lastFirst); // *"Dupont, Jean"*
```

您可以使用*setter*来补充 getter，它将执行您希望它执行的任何操作。例如，我们可能希望让用户为`.lastFirst`分配一个值，然后适当地更改`.first`和`.last`。

我们可以在`Person`类中添加以下定义：

```
// Source file: src/class_persons.js

class Person {
    // ...*continued from above*

 set lastFirst(lf) {
 *// very unsafe; no checks!*
 const parts = lf.split(",");
 this.last = parts[0];
 this.first = parts[1];
 }
}

pp.lastFirst = "Svensson, Sven";
console.log(pp); // *Person **{first: " Sven", last: "Svensson"}***
```

当然，不允许拥有一个属性并为同一个属性拥有一个 getter 或 setter。此外，getter 函数不能有参数，setter 函数必须只有一个参数。

You can find more information on getters and setters at [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/get](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/get) and [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/set](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/set), respectively.

前面的部分并没有穷尽 JS 在类和对象方面的所有可能性（不是很长时间），但为了清晰起见，我选择了最有可能的。

# 在模块中组织代码

随着今天的 JS 应用程序变得越来越复杂，使用名称空间和依赖项变得越来越难处理。这个问题的一个关键解决方案是*模块*的概念，它允许您将解决方案划分为独立的部分，利用封装避免不同模块之间的冲突。在本节中，我们将了解如何以这种方式工作。然而，我们将从前面的 JS 模式开始，它可能以自己的方式变得有用。

`Node`, which we'll be working with starting with the next chapter, also does modules but in a different fashion, so we'll postpone the discussion of its modules for now.

# 怎么做。。。

在处理成百上千甚至更大的代码库时，组织代码是这样一种基本的需求，在 JS 最终定义标准之前，设计了许多处理问题的方法。首先，我们将看一看更经典的*不确定*方式（我们将很快了解这意味着什么），然后再看更现代的解决方案，但请注意，在阅读其他人的代码时，您可能会遇到所有这些样式！

# 生活方式

在模块被广泛使用之前，有一种相当普遍的模式在使用，它基本上提供了与今天的模块相同的特性。首先，让我们介绍一段示例代码，然后检查其属性：

```
// Source file: src/iife_counter.js

/* @flow */

/*
   * In the following code, the only thing that needs*
 *an explicit type declaration for Flow, is "name".*
 *Flow can work out on its own the rest of the types.*
*/

const myCounter = ((name: string) => {
    let count = 0;

    const inc = () => ++count;

    const get = () => count; // private

    const toString = () => `${name}: ${get()}`;

 return {
 inc,
 toString
 }; 
})("Clicks");

console.log(myCounter); // *an object, with methods **inc** and **toString***

myCounter.inc(); // *1*
myCounter.inc(); // *2*
myCounter.inc(); // *3*

myCounter.toString(); // *"Clicks: 3"*
```

定义一个函数并立即调用它称为 IIFE，发音为*iffy*，表示*立即调用的函数表达式*

IIFEs are also known as *Self-Executing Anonymous Functions*, which doesn't sound as good as *iffy*!

我们定义了一个函数（以`name => ...`开头的函数），但我们立即调用了它（之后以`("Clicks")`开头）。因此，分配给`myCounter`的不是函数，而是它的返回值，即一个对象，我们来分析一下这个对象的内容。由于函数的作用域规则，从外部看不到内部定义的任何内容。在我们的具体案例中，这意味着`count`、`get()`、`inc()`和`toString()`将无法访问。然而，由于我们的 iLife 返回一个包含后两个函数的对象，因此这两个（并且只有这两个）可以从外部使用：这被称为*显示模块模式*。

A question: where is the `"Clicks"` value stored, and why isn't the value of `count` lost from call to call? The answer to both questions has to do with a well-known JS feature, *closures*, which has been in the language since its beginning. See [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures) for more information on this.

如果到目前为止您一直在关注，那么您应该清楚以下几点：

*   模块中定义的任何变量或函数都无法从外部看到或访问，除非您自愿公开它们
*   由于正常的词法范围规则，您决定在模块中使用的任何名称都不会与外部名称冲突
*   捕获的变量（在我们的例子中为`name`）保持不变，以便模块可以存储信息并在以后使用

总之，我们必须同意 IIFEs 是一个*穷人的模块*，它们的使用非常普遍。浏览一下网页；你一定会找到它的例子。然而，ES6 引入了一种更通用（更清晰、更容易理解）的模块定义方法，这就是我们将要使用的：下面我们来讨论这个。

# 用现代的方式重做我们的生活模块

模块中的关键概念是，您将拥有单独的文件，每个文件将代表一个模块。有两个互补的概念：进口和出口。模块将从其他模块导入其所需的功能，这些模块必须已导出这些功能才能使用。

首先，让我们看一下上一节中计数器模块的等效部分，然后评论我们可以使用的额外功能：

```
// Source file: src/module_counter.1.js

/* @flow */

let name: string = "";
let count: number = 0;

let get = () => count;
let inc = () => ++count;
let toString = () => `${name}: ${get()}`;

/*
 *Since we cannot initialize anything otherwise,*
 *a common pattern is to provide a "init()" function*
 *to do all necessary initializations.*
*/
const init = (n: string) => {
 name = n;
};

export default { inc, toString, init }; // *everything else is private*
```

我们将如何使用这个模块？让我们先回答一些关于内部方面的解释。

要在应用程序中的其他文件中使用此模块，我们将编写如下内容，使用新的源文件导入模块导出的函数：

```
// Source file: src/module_counter_usage.js
 import myCounter from "module_counter";
/*
   * Initialize the counter appropriately*
*/ myCounter.init("Clicks");

/*
   * The rest would work as before*
*/
myCounter.inc(); // 1
myCounter.inc(); // 2
myCounter.inc(); // 3
myCounter.toString(); // "Clicks: 3"
```

好的，所以使用这个模块来提供计数器毕竟没有什么不同。与 IIFE 版本的主要区别在于，在这里，我们无法进行初始化。提供初始化的一种常见模式是导出一个`init()`函数，该函数将执行所需的任何操作。无论是谁使用该模块，首先必须调用`init()`正确设置。

There's no need to immediately call the `init()` function, as would happen with the IIFE version, and you could delay it until necessary. Also, the `init()` function could be called more times in order to reset the module. These possibilities provide extra functionality.

# 添加初始化检查

如果您愿意，您可以在不初始化的情况下使模块崩溃，从而使`.init()`功能更加强大：

```
// Source file: module_counter.2.js

/* @flow */

let name = "";
let count = 0;

let get = () => count;

let throwNotInit = () => {
 throw new Error("Not initialized");
};
let inc = throwNotInit;
let toString = throwNotInit;

/*
 *Since we cannot initialize anything otherwise,*
 *a common pattern is to provide a "init()" function*
 *to do all necessary initializations. In this case,*
 *"inc()" and "toString()" will just throw an error* 
 *if the module wasn't initialized.*
*/
const init = (n: string) => {
    name = n;
 inc = () => ++count;
 toString = () => `${name}: ${get()}`;
};

export default { inc, toString, init }; // *everything else is private*
```

通过这种方式，我们可以确保正确使用我们的模块。注意，分配一个新函数来替换一个旧函数的想法是函数式编程风格的典型特征；函数是可以传递、返回或存储的第一类对象。

# 使用更多的导入/导出可能性

在上一节中，我们使用所谓的默认导出从模块导出了单个项：每个模块一个。还有另一种导出，*名为*导出，每个模块可以有几个导出。你甚至可以在同一个模块中混合它们，但通常更清楚的是不要将它们混合在一起。例如，假设你需要一个模块来进行距离和重量转换。您的模块可以如下所示：

```
// Source file: src/module_conversions.js

/* @flow */

type conversion = number => number;

const SPEED_OF_LIGHT_IN_VACUUM_IN_MPS = 186282;
const KILOMETERS_PER_MILE = 1.60934;
const GRAMS_PER_POUND = 453.592;
const GRAMS_PER_OUNCE = 28.3495;

const milesToKm: conversion = m => m * KILOMETERS_PER_MILE;
const kmToMiles: conversion = k => k / KILOMETERS_PER_MILE;

const poundsToKg: conversion = p => p * (GRAMS_PER_POUND / 1000);
const kgToPounds: conversion = k => k / (GRAMS_PER_POUND / 1000);

const ouncesToGrams: conversion = o => o * GRAMS_PER_OUNCE;
const gramsToOunces: conversion = g => g / GRAMS_PER_OUNCE;

/*
 *It's usually preferred to include all "export"*
 *statements together, at the end of the file.*
 *You need not have a SINGLE export, however.*
*/
export { milesToKm, kmToMiles };
export { poundsToKg, kgToPounds, gramsToOunces, ouncesToGrams };
export { SPEED_OF_LIGHT_IN_VACUUM_IN_MPS };

```

您可以有任意多个定义，并且可以导出任意定义；在我们的例子中，我们导出了六个函数和一个常量。您不需要将所有内容都打包到一个`export`中；您可以有几个，正如我们已经向您展示的。导出通常在模块末尾分组，以帮助读者快速查找模块导出的所有内容，但有时您可能会在整个代码中找到它们；我们不会那样做的。您也可以在定义内容的同一行中导出内容，如`export const LENGTH_OF_YEAR_IN_DAYS = 365.2422`，但出于一致性考虑，我们也不会使用该样式。

当导入带有命名导出的模块时，您只需说出需要哪些导出。您可以从不同的模块导入；你只需要几个陈述。标准做法是在源文件的开头对所有这些文件进行分组。您还可以重命名一个`import`，就像下面代码中的`poundsToKg`一样，我们将使用它作为`p_to_kg`。实际上，如果您从两个不同的模块中对导入进行了相同的命名，您就会这样做；在我们的特定示例中，它实际上没有意义：

```
// Source file: src/module_conversion_usage.js

/* @flow */

import {
 milesToKm,
 ouncesToGrams,
 poundsToKg as p_to_kg
} from "./module_conversions.js";
console.log(`A miss is as good as ${milesToKm(1)} kilometers.`);

console.log(
    `${ouncesToGrams(1)} grams of protection `,
    `are worth ${p_to_kg(1) * 1000} grams of cure.`
);
```

到目前为止，我们已经在示例中看到了如何导出 JS 元素、函数和常量，但您也可以导出类、对象、数组等等。在下一节中，我们将回到 Flow，并了解如何导出和导入类型。

# 将流类型与模块一起使用

导出数据类型（包括泛型、接口等）与正常导出非常相似，只是必须包含单词`type`。如果要在原始模块的其他位置使用转换类型，请添加以下内容：

```
export type { conversion };
```

相应地，无论您想在何处导入该类型，都会添加如下内容：

```
import type { conversion } from "./module_conversions.js";
```

但是，请注意一个重要的细节：您不能在处理标准 JS 元素的同一句话中导出或导入数据类型：`export`和`export type`是不同的、独立的语句，`import`和`import type`也是如此。

# 确定功能的可用性

为了结束本章，让我介绍两个 web 工具，它们可以帮助您了解您可以安全使用的功能，以及使 transpiler（如本章开头提到的`Babel`）成为必要的功能。

# 怎么做。。。

您的第一个资源将是[https://kangax.github.io/compat-table/](https://kangax.github.io/compat-table/) ，它提供了非常全面和完整的表格，逐项显示 JS 引擎支持的内容。根据您的具体需求，您可能完全不需要传输，但在采取这种措施之前，您一定要小心！

以下屏幕截图显示 Kangax 正在工作：

![](assets/52bf1c0f-fdcd-4da4-a707-e985222f7f50.png)

The Kangax website lets you determine what features are (or are not) provided by browsers, versions of Node, and so on

第二个你应该注意的网络工具是*我可以使用吗。。。*在[处 https://caniuse.com/](https://caniuse.com/) 。在这个站点中，您可以搜索任何功能（无论是 JS、HTML 还是 CSS），您将看到哪些浏览器版本支持或不支持它。一条评论是相关的：这个网站只提供桌面和移动浏览器的信息；例如，您无法查看`Node`中是否支持某个功能。以下截图显示*我可以使用。。。*工作中：

![](assets/1a5da347-88de-44da-aa06-07052b82694f.png)

The *Can I Use...* site lets you find out what browsers support (or don't) a given feature