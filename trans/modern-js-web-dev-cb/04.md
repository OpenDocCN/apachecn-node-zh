# 四、使用Node实现 RESTful 服务

我们将介绍以下配方：

*   用 Express 开发服务器
*   添加中间件
*   获取请求参数
*   提供静态文件
*   添加路由
*   实现安全连接
*   增加安全防护头盔
*   实施 CORS
*   使用 JWT 添加身份验证
*   将其捆绑在一起—构建 REST 服务器

# 介绍

在最后一章中，我们研究了一组重要的基本Node技术。在本章中，我们将使用它们来建立一个带有`Express`的基本服务器，并在此基础上进行构建，直到生成一个适合**面向服务架构**（**SOA**设置的 RESTful 服务器

# 用 Express 开发服务器

虽然您可以使用普通的`Node`并完成所有工作，但今天的`Express`肯定是最常用的`Node`框架，通过提供一系列基本功能，您可以轻松开发服务器。首先，让我们安装它并检查它是否正常工作，然后继续构建服务等。

在本食谱中，我们将首先进行`Express`的基本安装，以便在后面的章节中使用它进行更高级的工作。

You can learn more about `Express` at [https://expressjs.com/](https://expressjs.com/).

# 怎么做。。。

让我们安装`Express`并确保其正常工作。安装基本上很简单，因为它只是另一个`npm`包，所以您只需要一个简单的命令：

```js
npm install express --save
```

You can add a `--verbose` optional parameter to the `npm` command to get a more verbose output and be able to see that things are happening.

接下来，让我们重做上一章中的基本测试服务器，但使用`Express`。而且，是的，对于这样一个简单的功能来说，这是一种过火的做法，但是我们只想检查一下我们是否以正确的方式设置了所有内容！请参阅以下代码：

```js
// Source file: src/hello_world.js

/* @flow */
"use strict";

const express = require("express");

const app = express();

app.get("/", (req, res) => res.send("Server alive, with Express!"));
```

```js
app.listen(8080, () =>
    console.log(
        "Mini server (with Express) ready at http://localhost:8080/!"
    )
);
```

# 它是如何工作的。。。

运行此服务器实际上与我们非常基本的`Node`服务器相同：

```js
> npm run build
> node out/hello_world.js
Mini server (with Express) ready at http://localhost:8080/!
```

我们可以进行与前面相同的测试，并注意以下几点：

*   访问`/`地址返回`Server alive`消息
*   其他路径产生 404（未找到）错误：

```js
> curl 127.0.0.1:8080
Server alive, with Express!

```

尝试访问其他路径（或`/`，但不使用`GET`将返回`404`错误和 HTML 错误屏幕：

![](img/26f05363-d552-4848-9734-5c8e64c40ded.png)

The basic Express configuration shows an error screen for 404 (Not Found) errors

关键线路是`app.get("/", (req, res) => ...)`呼叫。基本上，在创建了应用对象（`app`之后，您可以指定一个路由（在本例中为`/`）、一个 HTTP 方法（例如`.get()`、`.post()`、`.put()`和`.delete()`等等）。

Go to [https://expressjs.com/en/4x/api.html#app.METHOD](https://expressjs.com/en/4x/api.html#app.METHOD) for more on the available methods.

您还可以使用`.all()`作为所有可能方法的总括，以及当用户点击该特定路径时将被调用的函数。在我们的例子中，无论请求（`req`）是什么，响应（`res`）都是恒定的，但显然您希望为实际服务做更多的工作！

It goes without saying that you will surely have more than one route, and possibly process not only `GET` methods. You can certainly add many more routes and methods, and we'll get to more advanced routing in upcoming sections.

另一个有趣的行是`app.listen()`，它指定要侦听的端口，以及服务器启动时将执行的函数；在我们的例子中，它只是一条日志消息

现在我们已经成功地运行了服务器，让我们实现一些其他常见的服务器功能。

# 添加中间件

`Express`将其所有功能建立在一个关键概念上：*中间件*。如果使用普通Node，则必须编写一个大型*请求处理程序*，该处理程序必须处理服务器可能接收到的所有请求。通过使用中间件，`Express`让您能够以一种更具功能性的、管道式的方式将这个过程分解成更小的部分。如果您需要检查安全性、记录请求、处理路由等等，所有这些都将由适当放置的中间件功能完成。

首先，让我们了解`Express`与`Node`有何不同，看看我们如何添加一些自己的基本中间件，然后再继续应用常见功能以满足常见需求。有关更多信息，请参阅下图：

![](img/e8a129e0-6943-46e0-a7e1-9bb702789148.png)

Standard processing, in absence of the Express middleware handling – your code must do all of the processing

在标准处理中（参见上图），`Node`从 internet 客户端获取请求，将它们传递给代码进行处理，获取生成的响应，并将其传递给原始客户端。基本上，您的代码必须处理非常大的函数中的所有内容，处理安全性、加密、路由、错误等。如果将`Express`添加到混合物中，过程会发生一些变化：

![](img/62196a34-5120-48f6-8a5e-5d17adbcfbdb.png)

When Express is added, it handles requests by passing them to a middleware stack to produce the response

在本例中，您设置了一系列将由`Express`按顺序调用的函数，每个函数将处理整个流程的特定方面，从而简化了整体逻辑。此外，您不必直接处理常见问题（例如，CORS 或 zipping，仅举几例），因为有很多`Express`包已经提供了此类功能；您所要做的就是将它们添加到堆栈中的适当位置。

为了更好地了解其工作原理，在本配方中，让我们开发一个非常基本的请求记录器（我们将在[第 5 章](05.html)的*添加 HTTP 日志和 Morgan*部分深入了解它，*测试和调试您的服务器*和一个错误报告器。

# 准备

如果你想添加一些中间件，你必须在你定义的所有函数中按正确的顺序放置它。例如，如果要记录某个内容，可能需要在完成任何处理之前进行记录，因此需要将该定义添加到堆栈的顶部，或者非常靠近它。

中间件函数接收三个参数：传入的 HTTP 请求（我们将其称为`req`，正如我们到目前为止所做的那样）、传出的 HTTP 响应（`res`，以及当您希望处理堆栈中的下一个中间件时必须调用的函数（`next()`。当您的中间件被调用时，它必须发送响应（通过使用`res.send()`、`res.sendFile()`或`res.end()`或调用`next()`，以便堆栈中的以下函数有机会生成响应

Error 函数有点不同，它们在我们刚才列出的三个函数中添加了一个 Error（`err`）参数；在`Express`看来，有四个参数标志着该功能是一个错误处理器。如果一切正常，`Express`跳过错误中间件，但如果发生错误，`Express`将跳过每个函数，直到到达第一个可用的错误函数。

让我们跳到最后，查看完整的中间件示例，如下所示；我们将在下一节中解释其工作原理：

```js
// Source file: src/middleware.js

/* @flow */
"use strict";
const express = require("express");
const app = express();

app.use((req, res, next) => {
    console.log("Logger... ", new Date(), req.method, req.path);
    next();
});

app.use((req, res, next) => {
    if (req.method !== "DELETE") {
        res.send("Server alive, with Express!");
    } else {
        next(new Error("DELETEs are not accepted!"));
    }
});

// eslint-disable-next-line no-unused-vars
app.use((err, req, res, next) => {
    console.error("Error....", err.message);
    res.status(500).send("INTERNAL SERVER ERROR");
});

app.listen(8080, () =>
    console.log(
        "Mini server (with Express) ready at http://localhost:8080/!"
    )
);
```

# 怎么做。。。

让我们从我们的记录器开始。我们希望它适用于每一条路径，这样我们就可以忽略该路径。另一种选择是写`app.use("*", ...)`，意思完全相同；我们还将以它为例。您的逻辑可以做任何事情，因为我们想要记录请求，所以我们可以列出当前的时间戳、`request`方法和请求的路径。之后，这是最重要的事情，因为我们还没有完成对请求的处理，所以必须调用`next()`，否则该请求将处于处理延迟状态，永远不会向客户端发送任何内容：

```js
app.use((req, res, next) => {
    console.log("Logger... ", new Date(), req.method, req.path);
    next();
});
```

由于我们希望有一些错误，让我们定义不接受`DELETE`方法，因此将调用`next()`，但传递一个错误对象；其他请求只会得到一个简单的文本答案。我们的主要请求处理代码如下所示：

```js
app.use((req, res, next) => {
 if (req.method === "DELETE") {
 next(new Error("DELETEs are not accepted!"));
    } else {
        res.send("Server alive, with Express!");
    }
});
```

最后，我们的错误处理代码将记录错误，并返回一个`500`状态：

```js
// eslint-disable-next-line no-unused-vars
app.use((err, req, res, next) => {
    console.error("Error....", err.message);
    res.status(500).send("INTERNAL SERVER ERROR");
});
```

您将注意到需要禁用`no-unused-vars`ESLint 规则。仅通过函数签名识别错误不是一种很好的做法，如果您在堆栈末尾设置错误处理程序，以便没有其他函数可调用，则下一个参数将未使用并导致错误。在即将发布的`Express`版本中，有人谈到要解决这种情况，但目前这一点还没有定论。

The error code we just showed, basic as it is, could be used in practically every Node server you write. We will be using it as is in our examples.

# 它是如何工作的。。。

我们把一切都安排好了；现在，让我们看看我们的代码如何工作：

```js
> npm run build
> node out/middleware.js
```

我们可以使用一些 curl 请求来测试这一点；让我们使用`GET`、`POST`和`DELETE`：

```js
> curl "http://127.0.0.1:8080/some/path/to/get?value=9" 
Server alive, with Express!
> curl -X POST "http://127.0.0.1:8080/a/post/to/a/path" 
Server alive, with Express!
> curl -X DELETE "http://127.0.0.1:8080/try/to/delete?key=22" 
INTERNAL SERVER ERROR
```

记录的输出如下所示：

```js
Logger... 2018-05-08T00:22:20.192Z GET /some/path/to/get
Logger... 2018-05-08T00:22:44.282Z POST /a/post/to/a/path
Logger... 2018-05-08T00:23:01.888Z DELETE /try/to/delete
Error.... DELETEs are not accepted!
```

现在，我们知道了如何编写自己的中间件，但碰巧`Express`提供了许多现成的功能。让我们试一试，看看如何将它们用于几种常见需求。

# 获取请求参数

让我们来看一个基本问题：如何获取请求参数？在我们前面的示例中，在上一章的*处理流以处理请求*部分中，我们是手工完成的，处理请求流以获取正文，并使用解析函数提取参数。然而，`Express`已经提供了一些中间件，您可以在堆栈中需要参数的任何其他函数之前使用，这些参数可以来自主体或 URL 本身。在这个配方中，让我们看看如何访问请求参数，这是一个非常基本的需求。

# 怎么做。。。

让我们看看访问参数需要什么。首先，你需要`body-parser`模块，并询问你想要的选项；下一步我们将讨论：

```js
// Source file: src/get_parameters.js

const bodyParser = require("body-parser");
app.use(bodyParser.urlencoded({ extended: false }));
```

由于您希望在任何处理之前解析参数，`app.use()`行将位于堆栈的顶部。

现在，更详细地讲，`body-parser`模块提供了四个解析器：

*   *一个 URL 编码的主体解析器*，就像我们在这里使用的一样，用来了解使用`extended`true 或 false 的区别。结帐[https://github.com/expressjs/body-parser](https://github.com/expressjs/body-parser) 了解更多信息。
*   *一个 JSON 主体解析器*（如`bodyParser.json()`中所述）通过`application/json`处理带有`Content-Type`的请求。
*   *与`bodyParser.raw()`一样，原始主体解析器*默认处理`application/octet-stream`内容，但可以通过提供`type`选项进行更改。
*   *文本体解析器*与`bodyParser.text()`类似，用于处理`text/plain`内容。

后三个解析器可以提供额外的选项；查看文档了解更多信息。但是，请注意，如果必须处理多部分实体，则不能依赖于实体解析器；参见[https://github.com/expressjs/body-parser](https://github.com/expressjs/body-parser) 寻找一些替代方案，看看什么适合你。

# 它是如何工作的。。。

我们只需要添加几行，一切都安排好了。我们可以通过更改上一节中的记录器或编写如下代码来查看代码的工作情况：

```js
// Source file: src/get_parameters.js

app.use("*", (req, res) => {
    console.log(req.query, req.body);
    res.send("Server alive, with Express!");
});
```

URL 参数由`Express`自动分隔为`req.query`，由`bodyParser`解析`req.body`。我们可以尝试拨打两个服务电话`GET`和`POST`，以涵盖所有情况：

```js
> curl "http://127.0.0.1:8080/birthdays?day=22&month=9&year=1960" 
> curl -X POST --data "name=FK" "http://127.0.0.1:8080/persons" 
```

输出结果如下：

```js
> node out/get_parameters.js
Mini server (with Express) ready at http://localhost:8080/!
{ day: '22', month: '9', year: '1960' } {}
{} { name: 'FK' }
```

在第一种情况下（`GET`），我们可以看到`req.query`是一个具有三个查询参数的对象，而在第二种情况下（`POST`）没有查询参数，但`req.body`提供了我们提供的单个参数（`name`。

这应该会让您相信 Express 基于中间件堆栈的设计的优点，但是让我们再看一些例子，比如使用静态文件、路由、安全性等等。

# 提供静态文件

我们计划创建一组 REST 服务，但很可能您的服务器还必须提供一些静态文件，如图像、PDF 等。原则上，您可以手动为每个静态资产设置特定的路由，然后编写一个函数来读取所需的文件并将其内容流式传输到客户端；在上一章的*处理流以处理请求*部分中，我们做了类似的事情。

然而，这是一项常见且反复的任务，`Express`提供了一个更简单的解决方案；让我们看看如何简单地为静态文件提供服务。

An even better solution would be to have another server, such as nginx, in your stack and have it handle static files. Standard servers are much better at handling this type of simple request, and will leave your Node code free to handle more complex, demanding tasks.

# 怎么做。。。

假设我们希望为应用提供一些标志图标。我做了以下工作：

1.  我创建了一个与输出文件所在的`/out`目录相同级别的`/flags`目录，其中包含一些子目录：`/flags/america/north`、`/flags/america/south`和`/flags/europe`。
2.  我在*GoSquared*旁边放置了一些来自[的免费旗帜图标 https://www.gosquared.com/resources/flag-icons/](https://www.gosquared.com/resources/flag-icons/) 在这些目录中。对于多样性，这些标志可以在`/static`路径访问，但实际上并不存在。
3.  我编写了以下代码；这是早期的基本服务器，只添加了一些代码（粗体）来处理静态文件：

```js
// Source file: src/serve_statics.js

/* @flow */
"use strict";

const express = require("express");
const path = require("path");
const app = express();

app.get("/", (req, res) => res.send("Server alive, with Express!"));

app.use(
 "/static",
 express.static(path.join(__dirname, "../flags"), {
 immutable: true,
 maxAge: "30 days"
 })
);

app.use((err, req, res, next) => {
    console.error("Error....", err.message);
    res.status(500).send("INTERNAL SERVER ERROR");
});

app.listen(8080, () =>
    console.log(
        "Mini Express static server ready at http://localhost:8080/!"
    )
);
```

If you want to read more about serving static files, check out Node's documentation at [https://expressjs.com/en/starter/static-files.html](https://expressjs.com/en/starter/static-files.html).

`app.use()`在本例中，获取一个特殊函数`express.static()`，负责发送给定路径中的文件，并带有一些用于缓存的头；让我们进入细节：

*   `app.use()`的第一个参数是用户将选择的路径的基础；请注意，它不需要存在于实际目录中，正如我们在其他示例中看到的那样。顺便说一句，如果我们想接受所有 HTTP 方法，我们可以编写`app.use()`。
*   `express.static()`的第一个参数指定找到文件的路径。我正在使用`path.join()`函数查找实际路径：`/flags`与`/out`处于同一级别。
*   `express.static()`的第二个参数用于添加选项；在我们的例子中，我将发送一些缓存头，以便浏览器知道文件可以安全缓存 30 天。

The format for the `maxAge` parameter can be in a format understood by the `ms` package ([https://github.com/zeit/ms](https://github.com/zeit/ms)), which is able to convert date and time strings into the equivalent milliseconds, which is standard for JS.

# 它是如何工作的。。。

每当用户指定以`/static`开始的路径时，它将转换为从`/flags`开始的等效路径，如果找到该文件，它将被发回，并包含缓存头。请查看以下屏幕截图，以获取此示例：

![](img/a4a1be1a-646c-43ea-9144-6db7632119b0.png)

A static flag icon, served from a non-existing path, /static, mapped to an actual path

# 还有更多。。。

如果您出于某种特定原因想要发送静态文件，而不使用上一节所示的方法，您可以使用路由和`res.sendFile()`方法，如下代码所示：

```js
// Source file: src/serve_statics_alt.js

/* @flow */
"use strict";

const express = require("express");
const app = express();
const path = require("path");

const flagsPath = path.join(__dirname, "../flags");

app.get("/uruguay", (req, res) =>
 res.sendFile(`${flagsPath}/america/south/UY.png`)
);

app.get("/england", (req, res) =>
 res.sendFile(`${flagsPath}/europe/GB.png`)
);

app.get("/license", (req, res) =>
 res.sendFile(`${flagsPath}/license.txt`)
);

app.use((err, req, res, next) => {
    console.error("Error....", err.message);
    res.status(500).send("INTERNAL SERVER ERROR");
});

app.listen(8080, () =>
    console.log(
        "Mini Express static server ready at http://localhost:8080/!"
    )
);
```

如果您访问[http://127.0.0.1:8080/uruguay](http://127.0.0.1:8080/uruguay/) ，您将获得我祖国的国旗，以及[http://127.0.0.1:8080/license](http://127.0.0.1:8080/license) 将检索我选择的图标集的 MIT 许可证；请参见以下屏幕截图中的后者：

![](img/6e7eb6ab-c3f6-4e04-98ad-790ad85067fc.png)

Testing a different route that sends back a text file

当然，如果要提供大量静态文件，您不会使用这种方法，但是如果只有少数静态文件，那么这种替代解决方案工作得非常好。

You may have noticed that I didn't add headers for caching, but it can certainly be done. Read more on `res.sendFile()` at [https://expressjs.com/en/api.html#res.sendFile](https://expressjs.com/en/api.html#res.sendFile), in particular the `immutable` and `headers` options.

# 添加路由

无论您正在构建哪种类型的服务器（如我们计划的，是 RESTful 服务器，或者任何其他类型的服务器），您都必须处理路由问题，并且`Node`和`Express`一起提供了实现这一点的简单方法

从上一章中的*使用数据库*部分返回到我们的数据库，在 RESTful 方式下，我们应该提供以下路径，考虑到给定的方法：

*   `/countries`（`GET`获取所有国家列表，`POST`创建新国家）
*   `/countries/someCountryId`（`GET`访问国家；`PUT`更新国家；`DELETE`删除国家）
*   `/regions`（`GET`获取所有国家的所有区域，`POST`创建新区域）
*   `/regions/someCountryId`（`GET`获取给定国家的所有地区）
*   `/regions/someCountryId/someRegionId`（`GET`访问区域，`PUT`更新区域，`DELETE`删除区域）
*   `/cities`（`GET`获取所有城市–但我们不会真的允许这样做，因为结果集大小！-再加上`POST`创建一个新城市）
*   `/cities/someCityId`（`GET`访问城市，`PUT`更新城市，`DELETE`删除城市）

您还可以允许使用额外的参数，例如，允许对结果集进行分页，或启用一些筛选，但我们现在关心的是设置路由。您可以在主文件中设置所有必要的路由，正如我们在迄今为止的简短示例中所做的那样，但是随着您开始添加越来越多的路由，需要一些组织来避免最终使用数千行长的主文件。

# 怎么做。。。

多亏了`Express`，我们不需要太多的代码，只需要两行新代码就可以实现我们的路由；请查看以下代码：

```js
// Source file: src/routing.js

/* @flow */
"use strict";

const express = require("express");
const app = express();

const myRouter = require("./router_home.js");
app.use("/", myRouter);

// *eslint-disable-next-line no-unused-vars*
app.use((err, req, res, next) => {
    console.error("Error....", err.message);
    res.status(500).send("INTERNAL SERVER ERROR");
});

app.listen(8080, () =>
    console.log("Routing ready at http://localhost:8080")
);
```

`router_home.js`模块可以有一级路由分支，如下代码所示：

```js
// Source file: src/router_home.js

/* @flow */
"use strict";

const express = require("express");
const routerHome = express.Router();

const routerCountries = require("./router_countries.js");
const routerRegions = require("./router_regions.js");
const routerCities = require("./router_cities.js");

routerHome.use("/countries", routerCountries);
routerHome.use("/regions", routerRegions);
routerHome.use("/cities", routerCities);

module.exports = routerHome;
```

再往下一级，我们会有三个文件指定下一级。例如，各国的路线如下所示。你会注意到一个奇怪的额外路由，`/URUGUAY`，我添加它只是为了告诉你，我们可以拥有比 RESTful 服务器所需要的更多的路由！

```js
// Source file: src/router_countries.js

/* @flow */
"use strict";

const express = require("express");
const routerCountries = express.Router();

routerCountries.get("/", (req, res) => {
    res.send(`All countries... path=${req.originalUrl}`);
});

routerCountries.get("/URUGUAY", (req, res) => {
 res.send(`GET UY (Uruguay)... path=${req.originalUrl}`);
});

routerCountries.get("/:country", (req, res) => {
    res.send(`GET Single country... ${req.params.country}`);
});

module.exports = routerCountries;
```

区域路由文件如以下代码所示，我们将跳过城市路由，因为它与国家路由非常相似：

```js
// Source file: src/router_regions.src

/* @flow */
"use strict";

const express = require("express");
const routerRegions = express.Router();

routerRegions.get("/", (req, res) => {
    res.send(`Region GET ALL... `);
});

routerRegions.get("/:country", (req, res) => {
    res.send(`Region GET ALL FOR Country=${req.params.country}`);
});

routerRegions.get("/:country/:id", (req, res) => {
    res.send(`Region GET ${req.params.country}/${req.params.id}`);
});

routerRegions.delete("/:country/:id", (req, res) => {
    res.send(`Region DELETE... ${req.params.country}/${req.params.id}`);
});

routerRegions.post("/", (req, res) => {
    res.send(`Region POST... `);
});

routerRegions.put("/:country/:id", (req, res) => {
    res.send(`Region PUT... ${req.params.country}/${req.params.id}`);
});

module.exports = routerRegions;
```

You can read more about `Express` routing at [https://expressjs.com/en/starter/basic-routing.html](https://expressjs.com/en/starter/basic-routing.html) and [https://expressjs.com/en/guide/routing.html](https://expressjs.com/en/guide/routing.html).

# 它是如何工作的。。。

当然，我们所谓的*RESTful 服务器*至少就目前而言，完全是一个笑话，因为它只返回恒定的答案，什么也不做，但关键部分实际上都在这里。首先，让我们分析一下它的结构。当您写入`app.use(somePath, aRouter)`时，这意味着以给定路径开始的所有路由都将被提供的路由占用，该路由将负责从给定路径开始的路由。首先，我们从`/`开始编写一个基本路由，然后按路径（`/countries`、`/regions`、`/cities`分解路由，为每个路由编写一个路由。这些后一种路由会在路径中走得更深，直到所有的路径都被绘制出来。

明确地说：当服务器收到一个请求，比如说，`/regions/uy`时，请求首先由我们的主路由（在`routing.js`处）处理，主路由将其传递给家庭路由（`router_home.js`，家庭路由将其传递给最终的路由（`router_regions.js`，最终在那里处理请求

现在，让我们自己进入路线。这里有两种路由：*常量*路由，如`/countries`和*变量*路由，如`/regions/uy/4`，在本例中包含一些变化项，如`uy`和`4`。当您编写一个路由（如`/regions/:country/:id`）时，Express 将选择不同的部分（此处为`:country`和`:id`），并将它们作为`req.params`对象（`req.params.country`和`req.params.id`的属性提供，以便您可以在逻辑中使用它们。

You can also use regular expressions to define a path, but remember the joke: a programmer has a problem; a programmer decides to solve it using regular expressions; a programmer now has *two* problems.

因此，如果我们在前面的路径上实现一些请求，我们将看到正在运行的路由；我们所缺少的只是生成一些有用结果的实际 RESTful 代码，但我们将在本章后面部分讨论：

```js
> curl "http://127.0.0.1:8080/regions" 
Region GET ALL..

> curl "http://127.0.0.1:8080/regions/uy" 
Region GET ALL FOR Country=uy

> curl -X POST "http://127.0.0.1:8080/regions" 
Region POST... 

> curl -X PUT "http://127.0.0.1:8080/regions/uy/4" 
Region PUT... uy/4

```

当然，尝试一些不允许的方法会产生错误；试着对`/regions`进行`DELETE`请求，你就会明白我的意思。我们现在知道如何进行任何类型的路由，但我们仍然必须能够接收 JSON 对象，如果需要，允许 CORS，以及其他一些考虑因素，因此让我们继续工作，并从启用 HTTPS 的安全连接开始。

# 实现安全连接

通过 HTTPS 而不是 HTTP 发送数据是一种良好的安全实践，如果您的服务器必须通过 web 发送敏感、安全的数据，则实际上是强制性的。通过与客户端浏览器建立加密连接可以避免多种攻击，因此让我们看看如何实现与`Node`和`Express`的安全连接

在本食谱中，我们将介绍如何启用 HTTPS，以便我们的服务器变得更加安全

# 怎么做。。。

我们想要启用 HTTPS 连接，所以我们必须做一些工作来安装我们需要的所有东西。

此安装的第一步是为自己获取一个证书，以正确验证您所拥有的站点。购买它超出了本书的范围，因此让我们通过生成自己的自签名证书来解决问题，当然，这些证书并不真正安全，但可以让我们完成所有必需的配置！

让我们假设我们想要建立我们的`www.modernjsbook.com`站点。在 Linux 中工作时，您可以通过执行以下命令并回答一些问题来创建必要的证书文件：

```js
openssl req -newkey rsa:4096 -nodes -keyout modernjsbook.key -out modernjsbook.csr openssl x509 -signkey modernjsbook.key -in modernjsbook.csr -req -days 366 -out modernjsbook.crt

```

完成此操作后，您将得到三个文件：一个**证书签名请求**（**CSR**）、一个密钥（私钥）和一个自签名证书（CRT）文件，如下所示：；在现实生活中，**证书颁发机构**（**CA**将是实际的签名人：

```js
> dir
-rw-r--r-- 1 fkereki users 1801 May 14 22:32 modernjsbook.crt
-rw-r--r-- 1 fkereki users 1651 May 14 22:31 modernjsbook.csr
-rw------- 1 fkereki users 3272 May 14 22:31 modernjsbook.key
```

现在，当您设置服务器时，您必须读入这些文件（为了增加安全性，这些文件应该位于一个安全的只读目录中），并将其内容作为选项传递。我们将使用`fs`模块来实现这一点，就像前面的示例一样，因为只有在加载服务器时才能读取文件，所以可以使用`fs.readFileSync()`。请看下面的代码：

```js
// Source file: src/https_server.js

/* @flow */
"use strict";

const express = require("express");
const app = express();
const https = require("https");

const fs = require("fs");
const path = require("path");

const keysPath = path.join(__dirname, "../../certificates");

const ca = fs.readFileSync(`${keysPath}/modernjsbook.csr`);
const cert = fs.readFileSync(`${keysPath}/modernjsbook.crt`);
const key = fs.readFileSync(`${keysPath}/modernjsbook.key`);

https.createServer({ ca, cert, key }, app).listen(8443);
```

Why port `8443`? The reason has to do with security, and we saw why in the *Checking Node's setup* section of the previous chapter; it's the same motive that we had behind using port `8080` instead of port `80`.

# 它是如何工作的。。。

运行前面的代码就足以获得到服务器的加密连接。（当然，如果您使用自签名证书，最终用户将收到关于缺乏实际安全性的警告，但您将获得有效的证书，不是吗？）我们可以在下面的屏幕截图中看到这一结果，请记住，使用真正的证书，用户不会收到关于您不安全站点的警报！

![](img/0fea9c51-8b9a-48c8-932e-25aba90d2bb0.png)

Installing certificates and using HTTPS instead of HTTP generates a secure server.
Of course, since we made up the certificate by ourselves, Google Chrome doesn't really like the site!

我们还可以强制 HTTP 用户使用 HTTPS，方法是运行第二台*服务器，这次使用 HTTP，并将所有流量重定向到我们的第一台服务器，这是安全的：*

```js
// Source file: src/http_server.js

/* @flow */
"use strict";

const express = require("express");
const app = express();
const http = require("http");

http.createServer(app).listen(8080);

app.use((req, res, next) => {
    if (req.secure) {
        next();
    } else {
 res.redirect(
 `https://${req.headers.host.replace(/8080/, "8443")}${req.url}`
 );
    }
});
```

`Node`服务器只能侦听单个端口，因此您可以将此服务器作为单独的实例运行。现在，如果您尝试使用 HTTP 访问服务器，您将自动重定向，这是一个很好的做法！

添加安全连接很简单；让我们继续研究更多的安全方面。

# 增加安全防护头盔

开箱即用，`Express`是构建 RESTful 服务器或提供任何其他类型服务的非常好的工具。然而，除非您采取一些额外的预防措施，否则 Express 不会应用所有安全最佳实践，这可能会毁了您的服务器。无论如何，并不是所有的东西都丢失了，因为有一些软件包可以帮助您进行这些实践，还有`Helmet`（在[处）https://helmetjs.github.io/](https://helmetjs.github.io/) 是这方面最好的选择之一。

Don't think of `Helmet`—or any other similar package, by the way—as a magic silver bullet that will somehow solve all of your possible present and future security headaches! Use it as a step in the right direction, but you must keep on top of possible menaces and security holes, and not trust any single package to manage everything.

# 怎么做。。。

考虑到它与`Express`一起工作，`Helmet`也是一个中间件。幸运的是，它的安装和设置相当简单。使用`npm`可以处理第一部分：

```js
npm install helmet --save
```

将`Helmet`投入工作只是将其添加到中间件堆栈的顶部：

```js
const helmet = require("helmet");
app.use(helmet());
```

你都准备好了！默认情况下，`Helmet`启用以下安全措施列表，所有这些措施都意味着从您对请求的响应中添加、更改或删除特定的头。有关特定标题或选项的更多文档，请查看[https://helmetjs.github.io/docs/](https://helmetjs.github.io/docs/) ：

| **模块** | **效果** |
| `dnsPrefetchControl` | 将`X-DNS-Prefetch-Control`标题设置为禁用浏览器预取（在用户点击链接之前完成请求），以防止对用户的隐私影响，用户可能正在访问他们实际上没有访问的页面（[）https://helmetjs.github.io/docs/dns-prefetch-control](https://helmetjs.github.io/docs/dns-prefetch-control) 。 |
| `frameguard ` | 设置`X-Frame-Options`标题以防止您的页面显示在 iframe 中，从而避免一些*点击劫持*攻击，这些攻击可能会导致您无意中点击隐藏链接
（[https://helmetjs.github.io/docs/frameguard/](https://helmetjs.github.io/docs/frameguard/) ）。 |
| `hidePoweredBy ` | 删除`X-Powered-By`头（如果存在），这样潜在的攻击者就不会知道是什么技术驱动了服务器，从而使锁定漏洞和利用漏洞变得更加困难（[https://helmetjs.github.io/docs/hide-powered-by](https://helmetjs.github.io/docs/hide-powered-by) |
| `hsts ` | 设置`Strict-Transport-Security`头，以便浏览器继续使用 HTTPS，而不是切换到不安全的 HTTP。
（[https://helmetjs.github.io/docs/hsts/](https://helmetjs.github.io/docs/hsts/) |
| `ieNoOpen ` | 设置`X-Download-Options`标题以防止旧版本的 Internet Explorer 下载页面中不受信任的 HTML（[https://helmetjs.github.io/docs/ienoopen](https://helmetjs.github.io/docs/ienoopen) 。 |
| `noSniff` | 设置`X-Content-Type-Options`头以防止浏览器尝试*嗅探*（猜测）下载文件的 MIME 类型，从而禁用某些攻击（[https://helmetjs.github.io/docs/dont-sniff-mimetype](https://helmetjs.github.io/docs/dont-sniff-mimetype) ）。 |
| `xssFilter` | 设置`X-XSS-Protection`标题以禁用某些形式的**跨端脚本**（**XSS**）攻击，在这些攻击中，您可以通过单击链接（[在页面上无意中运行 JS 代码 https://helmetjs.github.io/docs/xss-filter](https://helmetjs.github.io/docs/xss-filter) ）。 |

您还可以选择启用一些额外的选项，如果它们适用于您的需求。有关如何操作的说明，请查看头盔文档，网址为[https://helmetjs.github.io/docs/](https://helmetjs.github.io/docs/) ：目前版本为 3.12.0 的软件包经常更新，普通的`npm install`可能不足以启用更新的功能。请看下表：

| **模块** | **效果** |
| `contentSecurityPolicy` | 允许您配置`Content-Security-Policy`标题，以指定页面上允许的内容，以及可以从何处下载这些内容（[https://helmetjs.github.io/docs/xss-filter](https://helmetjs.github.io/docs/xss-filter) 。 |
| `expectCt` | 允许您将`Expect-CT`头设置为要求**证书透明度**（**CT**），以检测可能无效的证书或权限（[https://helmetjs.github.io/docs/expect-ct/](https://helmetjs.github.io/docs/expect-ct/) ）。 |
| `hpkp` | 允许您配置`Public-Key-Pins`头，通过检测可能存在的受损证书（[，防止一些可能的*中间人攻击*https://helmetjs.github.io/docs/hpkp/](https://helmetjs.github.io/docs/hpkp/) ）。 |
| `noCache` | 设置多个标题，以防止用户使用文件的旧缓存版本，这些文件可能存在漏洞或错误，尽管有新版本可用（[https://helmetjs.github.io/docs/nocache/](https://helmetjs.github.io/docs/nocache/) ）。 |
| `referrerPolicy` | 允许您设置`Referrer-Policy`头，使浏览器隐藏请求来源的信息，避免一些可能的隐私问题（[https://helmetjs.github.io/docs/referrer-policy](https://helmetjs.github.io/docs/referrer-policy) 。 |

# 它是如何工作的。。。

关于使用`Helmet`已经没有什么可说的了。在您将其添加到中间件堆栈中，并配置要启用或禁用的内容后，可能会提供文档中详细说明的一些选项，`Helmet`将简单地验证任何响应中包含的头是否符合我们在上一节中列出的安全注意事项

让我们快速检查一下。如果您运行我们的`hello_world.js`服务器，[的响应 http://localhost:8080/](http://127.0.0.1:8080) 将包括以下标题：

```js
Connection: keep-alive
Content-Length: 27
Content-Type: text/html; charset=utf-8
Date: Wed, 16 May 2018 01:57:10 GMT
ETag: W/"1b-bpQ4Q2jOe/d4pXTjItXGP42U4V0"
X-Powered-By: Express
```

相同的结果，但运行`helmet_world.js`，本质上是相同的代码，但添加了`Helmet`，显示了更多的标题，如以下粗体代码段所示：

```js
Connection: keep-alive
Content-Length: 27
Content-Type: text/html; charset=utf-8
Date: Wed, 16 May 2018 01:58:50 GMT
ETag: W/"1b-bpQ4Q2jOe/d4pXTjItXGP42U4V0"
Strict-Transport-Security: max-age=15552000; includeSubDomains
X-Content-Type-Options: nosniff
X-DNS-Prefetch-Control: off
X-Download-Options: noopen
X-Frame-Options: SAMEORIGIN
X-XSS-Protection: 1; mode=block
```

如果单独启用一些可选功能，您将获得更多的标题，但区别很明显：我们设法添加了一些基本上为零编码的安全控制！

As with all security measures, it's necessary to follow Helmet's functionality so that you can possibly add or remove some new middleware options, and protect your server against new menaces. 

# 实施 CORS

每当浏览器从服务器请求某些资源时，都会应用一些验证规则。对于这些交互中的许多交互，它们只要求提供信息，不试图在服务器中产生任何类型的更改，没有限制，请求总是被允许的，如以下情况：

*   *CSS 样式*需要通过`<link rel="stylesheet">`标记
*   通过`<img>`标签需要*图像*
*   通过`<script>`标签需要*JS 代码*
*   *媒体*通过`<audio>`或`<media>`标签请求

对于其他类型的请求，**相同来源策略**或**单一来源策略**（**SOP**将请求限制为发送到相同来源的请求（即协议，如`http://`、主机名，如`modernjsbook.com`和端口，如`:8080`），拒绝与一个或多个源 URL 元素不匹配的任何其他请求。例如，这会影响所有 Ajax 请求，这些请求将被适当地拒绝。

但是，如果您愿意接受来自部分或所有服务器的请求，您可以应用**跨源资源共享**（**CORS**来启用此类请求。基本上，CORS 定义了一种交互风格，让服务器决定是否允许跨源请求；与阻止每个请求（正如 SOP 所暗示的）或允许所有请求（一个巨大的安全漏洞！）不同，可以应用规则来决定一种方式或另一种方式。

If you want to read the current specification for CORS, see the Fetch Living Standard document at [https://fetch.spec.whatwg.org/](https://fetch.spec.whatwg.org/), specifically Section 3.2\. A good article about CORS can be found at [https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS).

# 怎么做。。。

让我们开始启用 CORS。基本上，这只是一个处理一些请求的问题，通过检查它们的头中的一些数据，并将其他头发送回浏览器，以便它知道会发生什么。这种类型的流程很容易通过应用中间件来解决，并且已经存在一个用于此的包（`cors`，可以通过以下代码轻松安装：

```js
 npm install cors --save
```

您可以为所有路由启用 CORS，也可以仅为少数路由启用 CORS。第一种方法只需要两行代码（粗体，在下面的代码中），告诉`Express`将中间件应用于所有请求的顶部：

```js
// Source file: src/cors_server.js

/* @flow */
"use strict";

const express = require("express");
const app = express();

const cors = require("cors");
app.use(cors());

app.get("/", (req, res) => res.send("Server alive, with CORS!"));

app.listen(8080, () =>
    console.log("CORS server ready at http://localhost:8080/!")
);
```

您还可以专门为任何给定路线启用它。从本章前面的一个例子中，您可以为获取城市的尝试指定 CORS；这种变化本来是最小的：

```js
routerCities.get("/:id", cors(), (req, res) => {
    res.send(`GET City... ${req.params.id}`);
});
```

最后，一些请求需要进行*飞行前*检查，这意味着浏览器在发送实际请求之前，将发送`OPTIONS`请求，以验证原始请求是否可以接受。为了实现这一点，您应该为任何路由启用 CORS，如以下示例所示，或者一般来说，在中间件堆栈的开头使用一行`app.options('*', cors())`：

```js
routerCities.options("/:id", cors()); 
routerCities.delete("/:id", (req, res) => {
    res.send(`DELETE City... ${req.params.id}`);
});
```

# 它是如何工作的。。。

验证 CORS 是否启用的最简单方法是使用`curl`或类似工具模拟来自不同来源的调用。（当我们开始做一些测试时，我们将在下一章中看到更多这方面的内容。）我们可以通过编写一个小型网页来完成跨域`GET`，添加一个虚拟头来强制 CORS，并检查网络流量，使之更简单。我们的页面本身就是简单的*完全没有虚饰*！

```js
// Source file: src/cors_request.html

<html>
<head></head>
<body>
    <script type="text/javascript">
        const req = new XMLHttpRequest();
        req.open('GET', 'http://www.corsserver.com:8080/', true);
        req.onreadystatechange = () => {
            if (req.readyState === 4) {
                if (req.status >= 200 && req.status < 400) {
                    console.log(req.responseText)
                } else {
                    console.warn("Problems!")
                }
            }
        };
        req.setRequestHeader("dummy", "value");
        req.send();
    </script>
</body>
</html>
```

我们将在`www.corsserver.com:8080`上运行我们的 CORS 服务器（实际上我正在我自己的机器上破解`/etc/hosts`文件，这样服务器实际上就在我的机器上），我们将使用 Chrome 的 Web 服务器来加载和运行我们的页面。查看以下屏幕截图了解执行此操作的结果：

![](img/d38f9da2-1c3f-4e63-8beb-bc4706daf2ce.png)

Performing a simple cross domain GET shows that our server got an OPTIONS request, followed by the GET request afterwards

使用 CORS 比其他替代方案更安全，包括旧的坚固的 JSONP（*JSON 加上填充*，这是一种跨域获取信息的方法），因此必须将其添加到服务器中。然而，正如我们所看到的，它本身很简单，只使用了一点 Express 中间件

# 使用 JWT 添加身份验证

对于任何基于服务器的应用，必须解决的一个挑战是身份验证，因此我们的 RESTful 服务器需要一个解决方案。在传统的网页中，可以使用会话和 cookie，但如果您使用的是 API，则不能保证请求来自浏览器；事实上，它们很可能来自另一台服务器。再加上 HTTP 是无状态的，RESTful 服务也应该是无状态的，我们需要另一种机制，**JSON Web 令牌**（**JWT**是一种常用的解决方案。

JWT is sometimes read aloud as *JOT*; see Section 1 of the RFC at [https://www.rfc-editor.org/info/rfc7519](https://www.rfc-editor.org/info/rfc7519).

JWT 的想法是，客户机将首先与服务器交换有效的凭据（如用户名和密码），然后取回令牌，这将使他们能够访问服务器的资源。令牌是使用密码学方法创建的，比通常的密码长得多，也更模糊。但是，令牌足够小，可以作为主体参数或 HTTP 头发送

Sending the token in the URL as a query parameter is a bad security practice! And, given that the token isn't actually a part of a request, putting it in the body also doesn't fit very well, so opt for a header; the recommended one is `Authorization: Bearer`.

获取令牌后，必须为其提供每个 API 调用，服务器将在继续之前对其进行检查。令牌可能包括有关用户的所有信息，以便服务器不必再次查询数据库以重新验证请求。从这个意义上说，代币的作用类似于在受限制建筑的前台给你的安全通行证；你必须向安全官员证明你的身份一次，但之后你只需出示通行证（通行证将被认可和接受）就可以穿过大楼，而不必一次又一次地通过整个身份验证程序

Check out [https://jwt.io/](https://jwt.io/) for online tools that allow you to work with JWT, and also lots of information about tokens.

我们不会深入了解 JWT 的创建、格式等细节；如果您感兴趣，请阅读文档，因为我们将与图书馆合作，为我们处理所有此类详细信息。（我们可能会记住，令牌包括一个*有效载荷*以及一些与客户端或令牌本身相关的*声明*，如到期或发行日期，如果需要，可能会包括更多信息，但不包括机密数据，因为令牌可以读取。）

在这个方法中，让我们创建一个基本服务器，它将能够首先向有效用户发出 JWT，然后检查 JWT 是否存在特定路由。

# 怎么做。。。

让我们看看如何添加身份验证。为了与 JWT 合作，我们将使用[中的`jsonwebtoken`https://github.com/auth0/node-jsonwebtoken](https://github.com/auth0/node-jsonwebtoken) 。使用以下命令进行安装：

```js
npm install jsonwebtoken --save
```

我们的 JWT 代码示例将比前面的示例更大，并且应该将其分为多个文件。然而，为了让它更清楚，我避免这样做。首先，我们需要做一些声明，关键行用粗体表示：

```js
// Source file: src/jwt_server.js

/* @flow */
"use strict";

const express = require("express");
const app = express();
const jwt = require("jsonwebtoken");
const bodyParser = require("body-parser");

const validateUser = require("./validate_user.js");

const SECRET_JWT_KEY = "modernJSbook";

app.use(bodyParser.urlencoded({ extended: false }));
```

除了`validateUser()`函数和`SECRET_JWT_KEY`字符串之外，几乎所有内容都是标准的。后者将用于对令牌进行签名，并且绝大多数情况下不应该出现在代码本身中！（如果有人在您的源代码中设置了一个密钥，那么就可以从源代码中设置一个密钥。）

至于功能，检查用户是否存在以及他们的密码是否正确很简单，可以通过多种方式实现，例如访问数据库、active directory、服务等。在这里，我们只需要一个硬编码版本，它只接受一个用户。因此，`validate_user.js`源代码非常简单：

```js
// Source file: src/validate_user.js

/* @flow */
"use strict";

/*
 *In real life, validateUser could check a database,*
 *look into an Active Directory, call another service,*
 *etc. -- but for this demo, let's keep it quite*
 *simple and only accept a single, hardcoded user.*
*/

const validateUser = (
    userName: string,
    password: string,
    callback: (?string, ?string) => void) => {
    if (!userName || !password) {
        callback("Missing user/password", null);
    } else if (userName === "fkereki" && password === "modernjsbook") {
        callback(null, "fkereki"); // OK, send userName back
    } else {
        callback("Not valid user", null);
    }
};

module.exports = validateUser;
```

让我们回到服务器上。在初始定义之后，我们可以放置不需要令牌的路由。让我们有一条`/public`路线，还有一条`/gettoken`路线，以便稍后获得 JWT。在后者中，我们将通过前面代码中显示的`validateUser()`函数来查看`POST`是否包含`user`和`password`值，以及它们是否是有效用户。任何问题都意味着将发送一个`401`状态，而如果用户正确，将创建一个令牌，在一小时后过期：

```js
// Source file: src/jwt_server.js

app.get("/public", (req, res) => {
    res.send("the /public endpoint needs no token!");
});

app.post("/gettoken", (req, res) => {
    validateUser(req.body.user, req.body.password, (idErr, userid) => {
 if (idErr !== null) {
 res.status(401).send(idErr);
 } else {
 jwt.sign(
 { userid },
 SECRET_JWT_KEY,
 { algorithm: "HS256", expiresIn: "1h" },
 (err, token) => res.status(200).send(token)
 );
 }
    });
});
```

既然已经排除了未受保护的路由，那么让我们添加一些中间件来验证是否存在令牌。根据 JWT RFC，我们希望包含一个`Authorization: Bearer somejwttoken`标题，并且必须接受。如果没有这样的标题，或者格式不正确，将发送 401 状态。如果令牌存在，但已过期或存在任何其他问题，则将发送 403 状态。最后，如果没有问题，`userid`字段将从有效负载中提取，并附加到请求对象，以便将来的代码能够使用它：

```js
// Source file: src/jwt_server.js

app.use((req, res, next) => {
    // First check for the Authorization header
    const authHeader = req.headers.authorization;
 if (!authHeader || !authHeader.startsWith("Bearer ")) {
        return res.status(401).send("No token specified");
    }

    // Now validate the token itself
    const token = authHeader.split(" ")[1];
    jwt.verify(token, SECRET_JWT_KEY, (err, decoded) => {
        if (err) {
            // Token bad formed, or expired, or other problem
            return res.status(403).send("Token expired or not valid");
        } else {
            // Token OK; get the user id from it
            req.userid = decoded.userid;
            // Keep processing the request
            next();
        }
    });
});
```

现在，让我们有一些受保护的路由（事实上，只有一条，`/private`，仅此示例），然后进行错误检查并设置整个服务器：

```js
// Source file: src/jwt_server.js app.get("/private", (req, res) => {
 res.send("the /private endpoint needs JWT, but it was provided: OK!");
});

// eslint-disable-next-line no-unused-vars
app.use((err, req, res, next) => {
    console.error("Error....", err.message);
    res.status(500).send("INTERNAL SERVER ERROR");
});

app.listen(8080, () =>
    console.log("Mini JWT server ready, at http://localhost:8080/!")
);
```

我们完了！让我们看看这一切是如何结合在一起的。

# 它是如何工作的。。。

我们可以从测试`/public`和`/private`路由开始，无需任何令牌。前者不会导致任何问题，但后者将被我们的令牌测试代码捕获并拒绝：

```js
> curl "http://localhost:8080/public" 
the /public endpoint needs no token!

> curl "http://localhost:8080/private" 
No token specified

```

现在，让我们试着得到一个代币。请查看以下代码：

```js
> curl http://localhost:8080/gettoken -X POST -d "user=fkereki&password=modernjsbook" 
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyaWQiOiJma2VyZWtpIiwiaWF0IjoxNTI2ODM5MDEwLCJleHAiOjE1MjY4NDI2MTB9.cTwpL-x7kszn7C9OUXhHlkTGhb8Aa7oOGwNf_nhALCs

```

Another way of testing this would be going to [https://jwt.io/](https://jwt.io/) and creating a JWT, including `userid:"fkereki"` in the payload, and using `modernJSbook` as the secret key. You would have to calculate the expiration date (`exp`) by yourself, though.

在[检查令牌 https://jwt.io](https://jwt.io) 显示以下有效载荷：

```js
{
  "userid": "fkereki",
  "iat": 1526839010,
  "exp": 1526842610
}
```

`iat`属性显示 JWT 是在 2018 年 5 月 20 日下午 2:00 左右发行的，`exp`属性显示令牌将在一小时（3600 秒）后过期。如果我们现在对`/private`重复 curl 请求，但添加了适当的头，那么它将被接受。然而，如果你等待（至少一个小时！），结果会不同；JWT 检查中间件将检测过期的令牌，并将产生 403 错误：

```js
> curl "http://localhost:8080/private" -H "Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyaWQiOiJma2VyZWtpIiwiaWF0IjoxNTI2ODM5MDEwLCJleHAiOjE1MjY4NDI2MTB9.cTwpL-x7kszn7C9OUXhHlkTGhb8Aa7oOGwNf_nhALCs"
the /private endpoint needs JWT, but it was provided: OK!

```

有了这段代码，我们现在有了一种向 RESTful 服务器添加身份验证的方法。如果您愿意，您可以进一步添加特定的授权规则，以便某些用户可以访问某些功能，而其他用户将受到限制。现在，让我们尝试将所有内容结合起来，为自己构建一个小型 REST 服务集。

# 将其捆绑在一起—构建 REST 服务器

在这个食谱中，让我们至少为我们的世界数据库编写一个完整的 RESTful 服务器的一部分，我们在上一章的*中开始使用数据库*部分，根据我们在本章前面的*添加路由*部分中看到的路由方案。我们将专注于处理区域，但只是为了简洁；国家和城市在编码方面非常相似，本书提供了完整的代码。

我们的 REST 服务将发送 JSON 应答，并需要令牌进行授权。我们将启用 CORS，以便我们可以从不同的网页访问它们。我们将处理的路线如下：

*   `GET /regions`将提供所有国家的所有地区
*   `GET /regions/:country`将返回给定国家的所有地区
*   `GET /regions/:country/:region`将返回单个区域
*   `DELETE /regions/:country/:region`将让我们删除给定区域
*   `POST /regions/:country`将允许我们创建一个新区域
*   `PUT /regions/:country/:region`将允许我们创建或更新给定区域

与国家和城市打交道非常相似，只有几个例外：

*   由于结果集的大小，我们不会接受`GET``/cities`提供全球所有城市的请求；只允许使用`GET``/cities/:city`。另一种选择是接受请求，但发回`405`状态代码`Method not allowed`。
*   由于国家代码不能随意分配，我们不允许`POST /countries`。相反，`PUT``/countries/:country`将被要求添加一个新国家，以及更新一个现有国家。

每种类型的请求都将生成相应的 HTTP 状态代码；我们将在以下章节中看到这一点。另外，`GET`请求将发送 JSON 结果，`POST`请求将发送新创建实体的位置；稍后将对此进行详细介绍

# 怎么做。。。

让我们看看如何编写服务器。我们将从一些基本代码开始，跳过前面已经看到的部分，例如 CORS 和 JWT 处理：

```js
// Source file: src/restful_server.js

/* @flow */
"use strict";
const express = require("express");
const app = express();
const bodyParser = require("body-parser");
const dbConn = require("./restful_db.js");
app.get("/", (req, res) => res.send("Secure server!"));

/*
    Add here the logic for CORS
*/

/*
    Add here the logic for providing a JWT at /gettoken
    and the logic for validating a JWT, as shown earlier
*/
```

处理路由是相当标准的。由于路由简单且数量少，我们可以将它们放在同一个源文件中；否则，我们会为不同的路由设置单独的文件。路由的处理程序肯定会放在另一个文件（`"restful_regions.js"`）中，以避免隐藏主服务器代码。请注意，国家和地区代码（如果存在）是 URL 的一部分；每当需要区域的名称时，它都会出现在主体参数中：

```js
// Source file: src/restful_server.js

const {
    getRegion,
    deleteRegion,
    postRegion,
    putRegion
} = require("./restful_regions.js");

app.get("/regions", (req, res) => getRegion(res, dbConn));

app.get("/regions/:country", (req, res) =>
    getRegion(res, dbConn, req.params.country)
);

app.get("/regions/:country/:region", (req, res) =>
    getRegion(res, dbConn, req.params.country, req.params.region)
);

app.delete("/regions/:country/:region", (req, res) =>
    deleteRegion(res, dbConn, req.params.country, req.params.region)
);

app.post("/regions/:country", (req, res) =>
    postRegion(res, dbConn, req.params.country, req.body.name)
);

app.put("/regions/:country/:region", (req, res) =>
    putRegion(
        res,
        dbConn,
        req.params.country,
        req.params.region,
        req.body.name
    )
);
```

最后，让我们看一些我们已经看到的完成服务器、错误处理和设置服务器本身的代码：

```js
// Source file: src/restful_server.js

// eslint-disable-next-line no-unused-vars
app.use((err, req, res, next) => {
    console.error("Error....", err.message);
    res.status(500).send("INTERNAL SERVER ERROR");
});

/*
   Add here the logic for HTTPS, finishing with: 

    https.createServer({ ca, cert, key }, app);
*/

app.listen(8080, () =>
    console.log("Routing ready at http://localhost:8080")
);
```

让我们继续，看看它是如何工作的。我们将在下一节中显示处理路由的代码。

# 它是如何工作的。。。

因为我们有四种请求，所以让我们适当地拆分对服务器代码的研究。

# 处理得到

正如我们之前看到的，有三种可能的处理途径：

*   `/regions`获取所有国家的所有区域
*   `/regions/UY`在本例中获取给定国家的所有地区，乌拉圭（`UY`
*   `/regions/UY/11`在这里获取一个国家的特定区域，即乌拉圭的区域 11

我们可以用类似的方式处理这三种情况，只要改变我们将要做的`SQL SELECT`。但是，处理结果需要特殊情况，我们将在下面的代码中注意到：

```js
// Source file: src/restful_regions.js

const getRegion = async (
    res: any,
    dbConn: any,
    country: ?string,
    region: ?string
) => {
    try {
        res.set("Connection", "close");

        let sqlQuery = "";
        let regions;
        if (country == null) {
            sqlQuery = `
                SELECT rr.* 
                FROM regions rr 
                JOIN countries cc 
                ON cc.countryCode=rr.countryCode
                ORDER BY cc.countryCode, rr.regionCode
            `;
            regions = await dbConn.query(sqlQuery);
        } else if (region == null) {
            sqlQuery = `
                SELECT 1
                FROM countries
                WHERE countryCode=?
            `;

            const countries = await dbConn.query(sqlQuery, [country]);
            if (countries.length === 0) {
                res.status(404).send("Country not found");
                return;
            }

            sqlQuery = `
                SELECT rr.* 
                FROM regions rr 
                JOIN countries cc 
                ON cc.countryCode=rr.countryCode
                WHERE rr.countryCode=?
                ORDER BY rr.regionCode
            `;
            regions = await dbConn.query(sqlQuery, [country]);
        } else {
            sqlQuery = `
                SELECT rr.* 
                FROM regions rr 
                JOIN countries cc 
                ON cc.countryCode=rr.countryCode
                WHERE rr.countryCode=? 
                AND rr.regionCode=?
            `;
            regions = await dbConn.query(sqlQuery, [country, region]);
        }

        if (regions.length > 0 || region === null) {
            res.status(200)
                .set("Content-Type", "application/json")
                .send(JSON.stringify(regions));
        } else {
            res.status(404).send("Not found");
        }
    } catch (e) {
        res.status(500).send("Server error");
    }
};
```

我们在前面代码中提到的特殊情况是要求类似于`/regions/XYZZY`的内容，并提供了错误的国家代码。在这种情况下，我们可以发送一个`404`，而不是发送一个空集（这可能意味着该国家确实存在，因为它似乎没有任何地区），因此第二个`if`语句（国家提供，地区不存在）在继续之前进行特殊检查。

我们可以通过几个例子看到这段代码。在没有其他参数的情况下获取`/regions`将提供更大的输出（22MB），因此添加参数以允许过滤或分页可能符合以下顺序：

I removed the HTTPS, CORS, and mainly the JWT code from the server to make the examples simpler to follow. Doing this meant that I haven't received extra headers, and have avoided having to provide a JWT in each call. Yes, I cheated a bit, but the source code provided with the book includes everything, so don't worry about it!

```js
> curl localhost:8080/regions/
[{"countryCode":"AD", "regionCode":"2", "regionName":"Canillo"}, {"countryCode":"AD", "regionCode":"3", "regionName":"Encamp"}, {"countryCode":"AD", "regionCode":"4", "regionName":"La Massana"},
.
.
.
{"countryCode":"ZW", "regionCode":"7", "regionName":"Matabeleland South"}, {"countryCode":"ZW", "regionCode":"8", "regionName":"Masvingo"}, {"countryCode":"ZW", "regionCode":"9", "regionName":"Bulawayo"}]
```

对特定国家（如`/regions/UY`）的请求产生的答案与我们之前收到的答案非常相似，但只包括国家`UY`（乌拉圭）中的地区，对单个地区的请求得到一个对象：

```js
> curl localhost:8080/regions/uy/10 
[{"countryCode":"UY","regionCode":"10","regionName":"Montevideo"}]

```

最后，我们可以尝试一个错误；查看以下屏幕截图并注意 404 状态：

![](img/28a633c1-96fa-402a-9210-15273201047a.png)

Asking our RESTful server for regions in a non-existent country produces a 404 error

# 处理删除

删除一个地区很简单，只是您必须事先检查该地区是否有任何城市。我们可以通过实施级联删除来解决这个问题，这样当您删除一个区域时，它的所有城市也会被删除，或者我们可以直接禁止删除。在我们的案例中，我选择了后者，但可以说前者也是有效的，并且不需要非常复杂的逻辑：

Why are we checking for cities by ourselves, instead of letting the DB server do it by using foreign keys? The reason is simple: I wanted to show some code that went a bit beyond a single SQL statement. The very same argument could be done for cascade deletions, which you could implement with a hand-crafted SQL sentence, or by setting up special rules in your database. And, let me state that for an actual application, letting the DB do the work would actually be preferable!

```js
// Source file: src/restful_regions.js

const deleteRegion = async (
    res: any,
    dbConn: any,
    country: string,
    region: string
) => {
    try {
        res.set("Connection", "close");

        const sqlCities = `
            SELECT 1 FROM cities 
            WHERE countryCode=? 
            AND regionCode=? 
            LIMIT 1 
        `;
        const cities = await dbConn.query(sqlCities, [country, region]);
        if (cities.length > 0) {
            res.status(405).send("Cannot delete a region with cities");
            return;
        }

        const deleteRegion = `
                DELETE FROM regions 
                WHERE countryCode=? 
                AND regionCode=?
            `;

        const result = await dbConn.query(deleteRegion, [country, region]);
        if (result.info.affectedRows > 0) {
            res.status(204).send();
        } else {
            res.status(404).send("Region not found");
        }
    } catch (e) {
        res.status(500).send("Server error");
    }
};
```

我们可以用类似的方法来测试这一点。删除没有城市的区域有效，但尝试为有城市的区域或不存在的区域执行此操作失败：

```js
> curl localhost:8080/regions/uy/23 -X DELETE --verbose 
*   Trying 127.0.0.1... 
* TCP_NODELAY set 
* Connected to localhost (127.0.0.1) port 8080 (#0) 
> DELETE /regions/uy/23 HTTP/1.1 
*.* .
.
< HTTP/1.1 204 No Content

> curl localhost:8080/regions/uy/10 -X DELETE --verbose
* Trying 127.0.0.1...
* TCP_NODELAY set
* Connected to localhost (127.0.0.1) port 8080 (#0)
> DELETE /regions/uy/10 HTTP/1.1
> Host: localhost:8080
> User-Agent: curl/7.59.0
> Accept: */*
> 
< HTTP/1.1 405 Method Not Allowed
*.* .
.
Cannot delete a region with cities

> curl localhost:8080/regions/uy/99 --verbose
* Trying 127.0.0.1...
* TCP_NODELAY set
* Connected to localhost (127.0.0.1) port 8080 (#0)
> GET /regions/uy/99 HTTP/1.1
> Host: localhost:8080
> User-Agent: curl/7.59.0
> Accept: */*
> 
< HTTP/1.1 404 Not Found
*.* .
.
Not found

```

请参阅可能返回的不同状态代码：

*   204，如果删除区域时没有问题，并且在这种情况下，不会发送文本响应
*   404，如果请求的区域不存在
*   405，如果无法接受请求（因为这些地区有城市）

当然，您可能会更改服务的工作方式，例如，如果提供了某个参数，则提供级联删除操作，如`http://some.server/regions/uy/23?cascade=true`。此外，对于某些服务，此操作甚至可以在不要求的情况下进行；用户可能有一组首选项，无论何时删除用户，您都应该删除他们的首选项。这将取决于所需的服务语义。

# 看跌期权

`PUT`请求意味着要更新现有资源。在我们的例子中，一个先决条件是指定的区域必须存在；否则，`404`错误将是适当的。如果该区域存在，那么我们可以更新它并发送一个`204`状态。如果`MySQL`检测到该区域没有发生任何变化，它会让您知道`UPDATE`没有发生任何变化；您可以发送一个`204`（如我所选择）或`409`错误，但无论如何，您都可以确定该地区有您想要的数据。我们还必须做一些参数检查；在这种情况下，只是为了确保给出了名称，但数据验证逻辑可能要复杂得多：

```js
// Source file: src/restful_regions.js

const putRegion = async (
    res: any,
    dbConn: any,
    country: string,
    region: string,
    name: string
) => {
    res.set("Connection", "close");

    if (!name) {
        res.status(400).send("Missing name");
        return;
    }

    try {
        const sqlUpdateRegion = `
            UPDATE regions
            SET regionName=?
            WHERE countryCode=? 
            AND regionCode=? 
        `;

        const result = await dbConn.query(sqlUpdateRegion, [
            name,
            country,
            region
        ]);

        if (result.info.affectedRows > 0) {
            res.status(204).send();
        } else {
            res.status(409).send("Region not updated");
        }
    } catch (e) {
        res.status(500).send("Server error");
    }
};
```

这很容易测试，因为只有两种情况（区域存在或不存在），加上一个健全性检查，以防名称丢失。让我们先将缺少的瓷砖添加到区域中；与之前一样，由于 204 状态代码，将不会收到任何内容：

```js
> curl localhost:8080/regions/uy/16 -X PUT -d "name=San Jose" --verbose 
*   Trying 127.0.0.1... 
* TCP_NODELAY set 
* Connected to localhost (127.0.0.1) port 8080 (#0) 
> PUT /regions/uy/16 HTTP/1.1 
.
.
.
< HTTP/1.1 204 No Content
```

这两种错误情况（不存在区域、缺少名称）会很快得到处理。前者由`MySQL`检测，后者由初始`if`语句捕获：

```js
> curl localhost:8080/regions/uy/xyzzy -X PUT -d "name=Colossal Cave" --verbose 
*   Trying 127.0.0.1... 
* TCP_NODELAY set 
* Connected to localhost (127.0.0.1) port 8080 (#0) 
> PUT /regions/uy/xyzzy HTTP/1.1 
*.* .
.
< HTTP/1.1 409 Conflict 
*.* .
.
Region not updated

> curl localhost:8080/regions/uy/10 -X PUT --verbose 
*   Trying 127.0.0.1... 
* TCP_NODELAY set 
* Connected to localhost (127.0.0.1) port 8080 (#0) 
> PUT /regions/uy/10 HTTP/1.1 
*.* .
.
< HTTP/1.1 400 Bad Request 
*.* .
.
Missing name

```

处理`PUT`几乎是最简单的情况；让我们通过仔细查看最复杂的请求`POST`来完成对服务器的研究。

# 经办岗位

最后，处理`POST`请求有点复杂，因为你要说你想向哪个集合（在本例中是一个国家的集合）添加新资源，逻辑要做所有事情，包括分配一个 ID。这意味着我们的代码要长一点，因为我们将添加查找未使用区域代码的需要。还有另一个区别：当创建资源时，新资源的 URI 应该在`Location`头中返回，因此这将是另一个额外的要求。

最后，我们将再次进行一些数据验证，如`PUT`请求：

```js
// Source file: src/restful_regions.js

const postRegion = async (
    res: any,
    dbConn: any,
    country: string,
    name: string
) => {
    res.set("Connection", "close");

    if (!name) {
        res.status(400).send("Missing name");
        return;
    }

    try {
        const sqlCountry = `
            SELECT 1 
            FROM countries
            WHERE countryCode=? 
        `;
        const countries = await dbConn.query(sqlCountry, [country]);
        if (countries.length === 0) {
            res.status(403).send("Country must exist");
            return;
        }

        const sqlGetId = `
            SELECT MAX(CAST(regionCode AS INTEGER)) AS maxr 
            FROM regions
            WHERE countryCode=? 
        `;
        const regions = await dbConn.query(sqlGetId, [country]);
        const newId =
            regions.length === 0 ? 1 : 1 + Number(regions[0].maxr);

        const sqlAddRegion = `
            INSERT INTO regions SET 
            countryCode=?,
            regionCode=?,
            regionName=?
        `;

        const result = await dbConn.query(sqlAddRegion, [
            country,
            newId,
            name
        ]);
        if (result.info.affectedRows > 0) {
            res.status(201)
                .header("Location", `/regions/${country}/${newId}`)
                .send("Region created");
        } else {
            res.status(409).send("Region not created");
        }
    } catch (e) {
        res.status(500).send("Server error");
    }
};
```

这是需要最多查询的逻辑。我们必须（1）检查该国家是否存在，（2）确定该国家的最大区域 ID，然后（3）插入新区域并向用户返回 201 状态。我们可以用类似于`PUT`的方法来测试这一点，所以让我们看一个简单的例子：

```js
> curl localhost:8080/regions/ar -X POST -d "name=NEW REGION" --verbose 
*   Trying 127.0.0.1... 
* TCP_NODELAY set 
* Connected to localhost (127.0.0.1) port 8080 (#0) 
> POST /regions/ar HTTP/1.1 
*.
.
.*
< HTTP/1.1 201 Created 
< X-Powered-By: Express 
< Location: /regions/ar/25 
.
.
.
Region created

> curl localhost:8080/regions/ar/25 
[{"countryCode":"ar","regionCode":"25","regionName":"NEW REGION"}]
```

阿根廷有 24 个省，在`regions`表中的编号从 1 到 24，因此如果我们添加一个新省，它应该是 25，答案中的`Location`标题证明了这一点。（我们只返回路由，没有服务器和端口，但我们可以轻松添加这些数据。）执行`GET`确认`POST`成功。

# 还有更多。。。

我们已经用`Express`建立了一个基本的 RESTful 服务器，但是对于一本自己的书来说，还有更多！让我们通过快速浏览一下你想为自己的项目考虑的一些想法和工具来完成这一章。

# 接受 JSON 数据

我们在示例中使用了`POST`参数，但也可以接收、解析和处理 JSON 输入。（这可以使调用 REST 服务变得更容易，因为在前端，您很可能能够为请求生成具有所需参数的对象。）使用`express.json()`作为中间件，请求主体将包含来自 JSON 参数的数据

Go to [http://expressjs.com/en/4x/api.html#express.json](http://expressjs.com/en/4x/api.html#express.json) for more information on this.

# 为部分更新添加修补程序方法

PUT 方法使您更新一个完整的实体，但有时您只想影响几个字段，在这种情况下，您可以允许使用`PATCH`方法。`PATCH`与`PUT`类似，但只允许更新某些属性。添加对该方法的支持并不复杂，并且与`PUT`逻辑非常相似，因此您可以提供一个功能更强大的服务器，而只需相对较少的额外编码。

You can read more about PATCH at [https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/PATCH](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/PATCH) and if you care about its specification, at [https://datatracker.ietf.org/doc/rfc5789/](https://datatracker.ietf.org/doc/rfc5789/).

# 使用 Restify 代替 Express

虽然 Po.t0t 是一个非常流行和广泛使用的包，可以用来构建任何类型的服务器，但是如果您只需要一个 REST 服务器而没有其他功能，您可以考虑使用其他包，如 OutT1。这种更改的优点与包的方向有关，包提供了与`Express`类似的功能，但需要更少的代码才能完成 RESTful 部署。`Restify`的一些知名用户是`npm`和 Netflix，但名单要长得多。

You can read more about `Restify` at [http://restify.com/](http://restify.com/).

# 允许筛选、排序和分页

因为 REST 基本上是一种样式，而不是服务规范，所以有些方面没有被指定，对于它们的实现您有一定的回旋余地。三个常见的需求是*过滤*（因此您不会得到所有实体，而只会得到满足某些条件的实体），*排序*（以便以某种顺序包含实体），以及*分页*（因为一次显示数百或数千个实体是不现实的）。当然，这三个要求是相互影响的；如果进行排序和筛选，则分页应应用于已排序的筛选数据。

所有这些要求都可以通过添加一些查询参数（或可能的标题）来处理，但您必须稍微研究一下，以了解什么是最适合您的方法：

*   *过滤*可以使用`filter=price[lt]220`等格式指定，这将指定给定属性（`price`）必须小于（`lt`）值（`200`。也可以构建更复杂的表达式，包括逻辑运算符，如`and`、`or`和`not`，以及可选的括号，但代价是在服务器上进行更复杂的解析和解释。
*   *排序*可以通过`sortby=price,name`等参数指定，先按`price`排序，再按`name`排序。您可以添加其他选项以允许升序或降序排序。
*   *分页*可以通过使用`limit`和`offset`参数来完成，其解释与 SQL`SELECT`语句中使用的解释相同（参见[https://dev.mysql.com/doc/refman/8.0/en/select.html](https://dev.mysql.com/doc/refman/8.0/en/select.html) 了解更多信息）或指定页面大小和页码。

将这些选项的处理添加到 REST 服务器将使其功能更加强大，并使客户端能够发送更具体、优化的请求。您可能还需要一个扩展；能够选择额外的相关实体，请继续阅读。

# 使用 GraphQL 代替 REST

REST 服务是标准且易于使用的，但可能会带来一些开销，主要是当您不需要单个实体，还需要一些相关实体时；例如，您如何获得一个国家及其所有地区？在我们目前的设计中，您必须单独调用并加入结果，或者自己扩展路由。例如，您可以为`/regions/uy?include=cities`执行此操作，以便服务器将添加到`UY`中的每个区域—一个包含其城市的阵列。虽然此解决方案可能适用于我们正在使用的小示例，但对于更大、更复杂的数据库，表之间以多种方式相互关联，它很容易失控。

然而，还有另一种选择。`GraphQL`是 Facebook 开发的数据查询语言，它允许您在客户端定义所需数据的结构；服务器会做任何需要做的事情来准确地生成这些内容。`GraphQL`通过以下引用构建一个复杂的结构，并以最小的延迟发送，您可以通过一个请求获得许多相关资源。您还可以获得一些工具来帮助您定义数据模式和执行联机查询

让我们看一个非常简短的例子，摘自 GraphQL 自己站点的文档，位于[http://graphql.org/learn/queries/](http://graphql.org/learn/queries/) 。给定一个*星球大战*电影的数据库，您可以编写以下查询，以从几部电影中获取英雄，并为每部电影提供名称、他们出现在其中的电影列表以及他们所有朋友的姓名：

```js
{
    leftComparison: hero(episode: EMPIRE) {
        ...comparisonFields
    }
    rightComparison: hero(episode: JEDI) {
        ...comparisonFields
    }
}

fragment comparisonFields on Character {
    name
    appearsIn
    friends {
        name
    }
}
```

此查询的结果如下所示。请注意，对象结构在查询中如何遵循您的规范，重复的字段或外键访问都是由`GraphQL`服务器在单个请求中解决的：

```js
{
    data: {
        leftComparison: {
            name: "Luke Skywalker",
            appearsIn: ["NEWHOPE", "EMPIRE", "JEDI"],
            friends: [
                {
                    name: "Han Solo"
                },
                {
                    name: "Leia Organa"
                },
                {
                    name: "C-3PO"
                },
                {
                    name: "R2-D2"
                }
            ]
        },
        rightComparison: {
            name: "R2-D2",
            appearsIn: ["NEWHOPE", "EMPIRE", "JEDI"],
            friends: [
                {
                    name: "Luke Skywalker"
                },
                {
                    name: "Han Solo"
                },
                {
                    name: "Leia Organa"
                }
            ]
        }
    }
}
```

虽然完全超出了本章的范围（毕竟，我们想要一个 RESTful 服务器），`GraphQL`对于需要使用复杂的链接结构的应用来说是一个非常有效的替代方案，否则将需要太多的处理和通信时间。

To learn more about `GraphQL`, check out the official site at [https://graphql.org/](https://graphql.org/). 

# 实现基于微服务的体系结构

现在您可以按照本章中的结构开发服务器了，在 SOA 中工作可能会演变成一个微服务组织，在这个组织中，服务器不是一个可以提供多种服务的单一代码块，而是作为一组不同的小型服务器组织起来，松散耦合，通过轻量级协议连接，每个协议都有一个单独的职责。服务可以由不同的组创建，甚至使用不同的语言或库，这些组只依赖于遵循给定的接口，以便其他服务可以根据需要自由地与它们交互。

这种结构基于独立的较小部分，极大地有助于可伸缩性、模块化，甚至开发和测试。如果需要改变，其影响将更小，持续交付和部署等战略将变得可行。开发微服务本身是很容易的，实现这一点的必要技术主要是我们在本章中看到的技术。只需要将请求从一个微服务器添加到另一个微服务器，以收集所有必需的信息。

A couple of good starting points on the benefits of a microservice-based architecture are the articles by Martin Fowler at [https://martinfowler.com/microservices/](https://martinfowler.com/microservices/) and by Chris Richardson at [http://microservices.io/patterns/microservices.html](http://microservices.io/patterns/microservices.html).