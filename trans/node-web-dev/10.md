# 部署 Node.js 应用程序

既然 Notes 应用程序已经相当完整，现在就应该考虑如何将其部署到真正的服务器上。我们已经创建了一个协作注释概念的最小实现，它运行得相当好。为了发展，笔记必须离开我们的笔记本电脑，生活在真正的服务器上。我们的目标是研究 Node.js 应用程序的部署方法。

在本章中，我们将介绍以下主题：

*   传统的 LSB 兼容 Node.js 部署
*   利用 PM2 提高可靠性
*   部署到**虚拟专用服务器**（**VPS**提供商
*   使用 Docker 部署微服务（我们要部署四种不同的服务）
*   部署到 Docker 宿主提供程序

第一个任务是复制上一章的源代码。建议您创建一个新目录`chap10`，作为`chap09`目录的同级目录，并将`chap09`到`chap10`之间的所有内容进行复制。

# 注意应用程序体系结构和部署注意事项

在部署 Notes 应用程序之前，我们需要检查它的体系结构。要部署 Notes 应用程序，我们必须了解我们计划做什么。我们已将服务分为两组，如下图所示：

![](Images/adde3721-02fc-45e1-84c8-cc887877bafd.png)

用户身份验证服务器应该是系统中更安全的部分。在我们的笔记本电脑上，我们无法围绕该服务创建预想的保护墙，但我们即将实施这种保护。

增强安全性的一个策略是尽可能少地公开端口。这减少了所谓的攻击面，简化了我们强化应用程序以防止安全漏洞的工作。对于 Notes 应用程序，我们只需要公开一个端口，即用户访问应用程序的 HTTP 服务。其他端口（MySQL 服务器的两个端口和用户身份验证服务端口）应该隐藏。

在内部，Notes 应用程序需要访问 Notes 数据库和用户身份验证服务。该服务反过来需要访问用户身份验证数据库。按照目前的设想，Notes 应用程序之外的任何服务都不需要访问数据库或身份验证服务。

此分段的实现需要两个或三个子网，具体取决于您希望到达的长度。第一个是 FrontNet，它包含 Notes 应用程序及其数据库。第二个 AuthNet 包含身份验证服务及其数据库。第三个可能的子网将包含 Notes 和身份验证服务。子网配置必须限制可以访问子网的主机，并在子网之间创建安全墙。

# 传统的 Linux Node.js 服务部署

传统的 Linux/Unix 服务器应用程序部署使用**初始化脚本**来管理后台进程。它们将在系统每次启动时启动，并在系统停止时完全关闭。虽然它是一个简单的模型，但它的具体细节在不同的**操作系统**（**操作系统**）之间差异很大。

一种常见的方法是`init`进程使用`/etc/init.d`目录中的 shell 脚本管理后台进程。其他操作系统使用其他流程管理器，如`upstart`或`launchd`

Node.js 项目本身不包含任何脚本来管理任何操作系统上的服务器进程。js 更像是一个构建工具包，包含构建服务器的各个部分，而本身并不是一个完整的抛光服务器框架。基于 Node.js 实现一个完整的 web 服务意味着创建脚本以与操作系统上的流程管理集成。这取决于我们开发这些脚本。

Web 服务必须：

*   可靠：例如，在服务器进程崩溃时自动重启
*   可管理：意味着它与系统管理实践很好地集成
*   可观察：意味着管理员必须能够从服务获取状态和活动信息

为了演示所涉及的内容，让我们使用 PM2 实现 Notes 的后台服务器进程管理。PM2 检测系统类型，并能自动与过程管理系统集成。它将创建一个 LSB 风格的初始化脚本（[http://wiki.debian.org/LSBInitScripts](http://wiki.debian.org/LSBInitScripts) ），或服务器上流程管理系统要求的其他脚本

对于这个部署，我们将设置一个 Ubuntu 17.10 服务器。您应该从主机提供商处提供一台**虚拟专用服务器**（**VPS**，并在那里进行所有安装和配置。在阅读本章所需的时间内，从一家主要提供商租用一台小型机器实例只需花费几美元。

您也可以在笔记本电脑上使用**VirtualBox**完成本节中的任务。只需在 VirtualBox 中将 Debian 或 Ubuntu 作为虚拟机安装，然后按照本节中的说明进行操作。它与使用远程 VPS 主机提供商不同，但不需要租用服务器。

Notes 和用户身份验证服务都将与一个 MySQL 实例一起位于该服务器上。虽然我们的目标是通过两个 MySQL 实例在 FrontNet 和 AuthNet 之间实现强大的分离，但目前我们不会这样做。

# 先决条件–配置数据库

Linux 包管理系统不允许我们安装两个 MySQL 实例。相反，我们在同一个 MySQL 实例中通过使用具有不同用户名和访问权限的独立数据库来实现分离。

第一步是确保在服务器上安装 MySQL。对于 Ubuntu，**数字海洋**有一个相当好的教程：[https://www.digitalocean.com/community/tutorials/how-to-install-mysql-on-ubuntu-14-04](https://www.digitalocean.com/community/tutorials/how-to-install-mysql-on-ubuntu-14-04) 。虽然该教程的 Ubuntu 版本很旧，但说明仍然足够准确。

MySQL 服务器必须支持来自`localhost`的 TCP 连接。编辑配置文件`/etc/mysql/my.cnf`，使其具有以下行：

```js
bind-address = 127.0.0.1
```

这将限制 MySQL 服务器与服务器上进程的连接。一个歹徒必须闯入服务器才能访问你的数据库。现在数据库服务器可用了，让我们设置两个数据库。

在`chap10/notes/models`目录中，创建一个名为`mysql-create-db.sql`的文件，其中包含以下内容：

```js
CREATE DATABASE notes;
CREATE USER 'notes'@'localhost' IDENTIFIED BY 'notes';
GRANT ALL PRIVILEGES ON notes.* TO 'notes'@'localhost' WITH GRANT OPTION;  
```

在`chap10/users`目录中，创建一个名为`mysql-create-db.sql`的文件，其中包含以下内容：

```js
CREATE DATABASE userauth;
CREATE USER 'userauth'@'localhost' IDENTIFIED BY 'userauth';
GRANT ALL PRIVILEGES ON userauth.* TO 'userauth'@'localhost' WITH GRANT OPTION;  
```

我们无法在服务器上运行这些脚本，因为 Notes 应用程序尚未复制到服务器。完成后，我们将按以下方式运行脚本：

```js
$ mysql -u root -p <chap10/users/mysql-create-db.sql
$ mysql -u root -p <chap10/notes/models/mysql-create-db.sql  
```

这将创建两个数据库，`notes`和`userauth`，以及相关的用户名和密码。每个用户只能访问其关联的数据库。稍后，我们将使用 YAML 配置文件设置 Notes 和用户身份验证服务，以访问这些数据库。

# 在 Ubuntu 上安装 Node.js

根据 Node.js 文档（[https://nodejs.org/en/download/package-manager/](https://nodejs.org/en/download/package-manager/) ），Debian 或 Ubuntu Linux 发行版的推荐安装方法如下：

```js
$ curl -sL https://deb.nodesource.com/setup_10.x | sudo -E bash -
$ sudo apt-get update
$ sudo apt-get install -y nodejs build-essential  
```

我们以前见过这个，所以在 URL 中替换 Node.js 所需的版本号。以这种方式安装意味着，随着 Node.js 新版本的发布，可以通过正常的包管理过程轻松完成升级

# 在服务器上设置 Notes 和用户身份验证

在将 Notes 和用户身份验证代码复制到此服务器之前，让我们先编写一些代码，为移动做准备。我们知道 Notes 和身份验证服务必须使用前面给出的用户名和密码访问`localhost`上的 MySQL 实例。

使用到目前为止我们采用的方法，这意味着为`Sequelize`参数创建一对 YAML 文件，并更改`package.json`文件中的环境变量以匹配。

创建一个包含以下内容的`chap10/notes/models/sequelize-server-mysql.yaml`文件：

```js
dbname: notes 
username: notes 
password: notes12345
params: 
    host: localhost 
    port: 3306 
    dialect: mysql 
```

在测试过程中发现，MySQL 服务器不接受像`notes`这样的简单密码，需要更长的密码。在`chap10/notes/package.json`中，将以下行添加到`scripts`部分：

```js
"on-server": "SEQUELIZE_CONNECT=models/sequelize-server-mysql.yaml NOTES_MODEL=sequelize USER_SERVICE_URL=http://localhost:3333 PORT=3000 node --experimental-modules ./app",  
```

然后创建一个包含以下代码的`chap10/users/sequelize-server-mysql.yaml`文件：

```js
dbname: userauth 
username: userauth 
password: userauth 
params: 
    host: localhost 
    port: 3306 
    dialect: mysql 
```

这些配置文件中显示的密码显然不会通过任何安全审核。

在`chap10/users/package.json`中，将以下行添加到`scripts`部分：

```js
"on-server": "PORT=3333 SEQUELIZE_CONNECT=sequelize-server-mysql.yaml node --experimental-modules ./user-server", 
```

这将配置身份验证服务以访问刚刚创建的数据库。

现在，我们需要在服务器上选择一个位置来安装应用程序代码：

```js
# ls /opt  
```

这个空目录看起来和其他目录一样好。只需将`chap10/notes`和`chap10/users`上传到您喜欢的位置。上传前，删除两个目录中的`node_modules`目录。这既是为了节省上传时间，也是因为安装在笔记本电脑上的任何本机代码模块都与服务器不兼容。在笔记本电脑上，您可以运行如下命令：

```js
$ rsync --archive --verbose ./ root@159.89.145.190:/opt/
```

使用分配给正在使用的服务器的实际 IP 地址或域名。

您应该以以下内容结束：

```js
# ls /opt
notes  users  
```

然后，在每个目录中运行以下命令：

```js
# rm -rf node_modules
# npm install  
```

We're running these commands as `root` rather than a user ID that can use the `sudo` command. The machine offered by the chosen hosting provider (DigitalOcean) is configured so users log in as `root`. Other VPS hosting providers will provide machines where you log in as a regular user and then use `sudo` to perform privileged operations. As you read these instructions, pay attention to the command prompt we show. We've followed the convention where `$` is used for commands run as a regular user and `#` is used for commands run as `root`. If you're running as a regular user, and need to run a `root` command, then run the command with `sudo`.

最简单的方法是删除整个`node_modules`目录，然后让`npm install`完成它的工作。请记住，我们通过以下方式设置`PATH`环境变量：

```js
# export PATH=./node_modules/.bin:${PATH}  
```

您可以将其放置在服务器上的登录脚本（`.``bashrc`、`.cshrc`等）中，以便自动启用

最后，您现在可以运行前面编写的 SQL 脚本来设置数据库实例：

```js
# mysql -u root -p <users/mysql-create-db.sql
# mysql -u root -p <notes/models/mysql-create-db.sql  
```

然后，您应该能够手动启动服务，以检查一切是否正常工作。MySQL 实例已经过测试，所以我们只需要启动用户认证和 Notes 服务：

```js
# cd /opt/users
# DEBUG=users:* npm run on-server

> user-auth-server@0.0.1 on-server /opt/users
> PORT=3333 SEQUELIZE_CONNECT=sequelize-server-mysql.yaml node --experimental-modules ./user-server

(node:9844) ExperimentalWarning: The ESM module loader is experimental.

```

然后在另一个终端会话上登录服务器并运行以下操作：

```js
# cd /opt/users/
# PORT=3333 node users-add.js 
Created { id: 1, username: 'me', password: 'w0rd', provider: 'local',
 familyName: 'Einarrsdottir', givenName: 'Ashildr', middleName: '',
 emails: '[]', photos: '[]',
 updatedAt: '2018-02-02T00:43:16.923Z', createdAt: '2018-02-02T00:43:16.923Z' }
# PORT=3333 node users-list.js 
List [ { id: 'me', username: 'me', provider: 'local',
 familyName: 'Einarrsdottir', givenName: 'Ashildr', middleName: '',
 emails: '[]', photos: '[]' } ]
```

前面的命令测试后端用户身份验证服务是否正常工作，并为我们提供一个可用于登录的用户帐户。`users-list`命令表明它是有效的。

您可能会得到一个错误：

```js
 users:error /create-user Error: Please install mysql2 package manually

```

这是在`Sequelize`内部生成的。`mysql2`驱动程序是另一种 MySQL 驱动程序，用纯 JavaScript 实现，并支持在`async`函数中返回平滑使用的承诺。如果您确实收到此消息，请继续安装软件包，并记住将此依赖项添加到您的`package.json`。

现在，我们可以启动 Notes 服务：

```js
# cd ../notes
# npm run on-server

> notes@0.0.0 on-server /opt/notes
> SEQUELIZE_CONNECT=models/sequelize-server-mysql.yaml NOTES_MODEL=sequelize USER_SERVICE_URL=http://localhost:3333 PORT=3000 node --experimental-modules ./app

(node:9932) ExperimentalWarning: The ESM module loader is experimental.
```

然后，我们可以使用 web 浏览器连接到应用程序。由于您可能没有与此服务器关联的域名，因此可以通过服务器的 IP 地址访问 Notes，例如`http://159.89.145.190:3000/`。

In these examples, we're using the IP address of the VPS used to test the instructions in this section. The IP address you use will, of course, be different.

到现在为止，您已经知道验证笔记的演练正在进行。创建一些注释，打开一些浏览器窗口，查看实时通知是否有效，等等。一旦您对 Notes 在服务器上工作感到满意，请停止进程并转到下一节，我们将在服务器启动时将其设置为运行。

# 调整 Twitter 身份验证以在服务器上工作

我们之前为 Notes 设置的 Twitter 应用程序无法工作，因为服务器的身份验证 URL 不正确。现在，我们可以使用之前创建的用户配置文件登录。如果您想看到 OAuth 与 Twitter 一起工作，请转到`apps.twitter.com`并重新配置应用程序以使用服务器的 IP 地址。

通过托管在笔记本电脑以外的地方，Twitter`callbackURL`必须指向正确的位置。默认值为`http://localhost:3000`用于我们的笔记本电脑。但是我们现在需要使用服务器的 IP 地址。在`notes/package.json,`中，将以下环境变量添加到`on-server`脚本中：

```js
TWITTER_CALLBACK_HOST=http://159.89.145.190:3000 
```

使用分配给正在使用的服务器的实际 IP 地址或域名。在实际部署中，我们将在此处使用域名

# 设置 PM2 以管理 Node.js 流程

有许多方法可以管理服务器进程，确保在进程崩溃时重新启动，等等。我们将使用**PM2**（[http://pm2.keymetrics.io/](http://pm2.keymetrics.io/) ），因为它针对 Node.js 流程进行了优化。它将流程管理和监视捆绑到一个应用程序中。

让我们创建一个目录`init`，在其中使用 PM2。PM2 网站建议您全局安装该工具，但作为 12 因素应用程序模型的学员，我们认识到最好使用显式声明的依赖项，避免全局非托管依赖项。

创建一个包含以下内容的`package.json`文件：

```js
{
  "name": "pm2deploy",
  "version": "1.0.0",
  "scripts": {
    "start": "pm2 start ecosystem.json",
    "stop": "pm2 stop ecosystem.json",
    "restart": "pm2 restart ecosystem.json",
    "status": "pm2 status",
    "save": "pm2 save",
    "startup": "pm2 startup"
  },
  "dependencies": {
    "pm2": "^2.9.3"
  }
}

```

照常使用`npm install`安装 PM2。

在正常的 PM2 使用中，我们使用`pm2 start script-name.js`启动脚本。我们可以制作一个`/etc/init`脚本来实现这一点，但 PM2 还支持一个名为`ecosystem.json`的文件，该文件可用于管理一组进程。我们有两个过程要一起管理，面向用户的 Notes 应用程序和后端的用户身份验证服务。

创建一个名为`ecosystem.json`的文件，其中包含以下内容：

```js
{
  "apps" : [
    {
      "name": "User Authentication",
      "script": "user-server.mjs",
      "cwd": "/opt/users",
      "node_args": "--experimental-modules",
      "env": {
        "PORT": "3333",
        "SEQUELIZE_CONNECT": "sequelize-server-mysql.yaml"
      },
      "env_production": { "NODE_ENV": "production" }
    },
    {
      "name": "Notes",
      "script": "app.mjs",
      "cwd": "/opt/notes",
      "node_args": "--experimental-modules",
      "env": {
        "PORT": "3000",
        "SEQUELIZE_CONNECT": "models/sequelize-server-mysql.yaml",
        "NOTES_MODEL": "sequelize",
        "USER_SERVICE_URL": "http://localhost:3333",
        "TWITTER_CONSUMER_KEY": "..",
        "TWITTER_CONSUMER_SECRET": "..",
        "TWITTER_CALLBACK_HOST": "http://45.55.37.74:3000"
      },
      "env_production": { "NODE_ENV": "production" }
    }
  ]
}

```

该文件描述了包含这两个服务的目录、运行每个服务的脚本、命令行选项以及要使用的环境变量。这与`package.json`脚本中的信息相同，但表述得更清楚。为服务器的 IP 地址调整`TWITTER_CALLBACK_HOST`。有关文件，请参见[http://pm2.keymetrics.io/docs/usage/application-declaration/](http://pm2.keymetrics.io/docs/usage/application-declaration/) 。

然后我们用`npm run start`启动服务，屏幕上显示如下：

![](Images/f0269a0b-7ecc-446f-9585-c871a32ac132.png)

您可以再次将浏览器导航到服务器的 URL，如`http://159.89.145.190:3000`，并检查 Notes 是否正常工作。启动后，一些有用的命令如下所示：

```js
# pm2 list
# pm2 describe 1
# pm2 logs 1  
```

这些命令允许您查询服务的状态。

`pm2 monit`命令提供了系统活动的伪图形监视器。有关文件，请参见[http://pm2.keymetrics.io/docs/usage/monitoring/](http://pm2.keymetrics.io/docs/usage/monitoring/) 。

`pm2 logs`命令解决了我们在别处提出的应用程序日志管理问题。活动日志应视为事件流，并应适当捕获和管理。使用 PM2，可以自动捕获、查看输出，并旋转和清除日志文件。参见[http://pm2.keymetrics.io/docs/usage/log-management/](http://pm2.keymetrics.io/docs/usage/log-management/) 用于文件编制。

如果我们重新启动服务器，这些进程不会从服务器开始。我们如何处理？这非常简单，因为 PM2 可以为我们生成一个`init`脚本：

```js
# pm2 save
[PM2] Saving current process list...
[PM2] Successfully saved in /root/.pm2/dump.pm2

# pm2 startup
[PM2] Init System found: systemd
Platform systemd
Template
[Unit]
Description=PM2 process manager
Documentation=https://pm2.keymetrics.io/
After=network.target

... more output is printed
```

`pm2 save`命令保存当前状态。此时运行的任何服务都将由生成的启动脚本保存和管理

下一步是使用`pm startup`命令生成启动脚本。PM2 支持在多个操作系统上生成启动脚本，但以这种方式运行时，它会自动检测系统类型并生成正确的启动脚本。它还安装启动脚本，并启动它运行。参见[中的文档 http://pm2.keymetrics.io/docs/usage/startup/](http://pm2.keymetrics.io/docs/usage/startup/) 了解更多信息。

如果仔细查看输出，将打印一些有用的命令。详细信息因操作系统而异，因为每个操作系统都有自己的用于管理后台进程的命令。在这种情况下，安装准备使用`systemctl`命令，通过此输出验证：

```js
Command list 
[ 'systemctl enable pm2-root', 
  'systemctl start pm2-root', 
  'systemctl daemon-reload', 
  'systemctl status pm2-root' ] 
[PM2] Writing init configuration in /etc/systemd/system/pm2-root.service 
[PM2] Making script booting at startup... 
...
[DONE]  
>>> Executing systemctl start pm2-root 
[DONE]  
>>> Executing systemctl daemon-reload 
[DONE]  
>>> Executing systemctl status pm2-root

```

您可以自行运行这些命令：

```js
# systemctl status pm2-root 
● pm2-root.service - PM2 process manager 
 Loaded: loaded (/etc/systemd/system/pm2-root.service; enabled; vendor preset: enabled) 
 Active: active (running) since Fri 2018-02-02 22:27:45 UTC; 29min ago 
 Docs: https://pm2.keymetrics.io/ 
 Process: 738 ExecStart=/opt/init/node_modules/pm2/bin/pm2 resurrect (code=exited, status=0/SUCCESS) 
 Main PID: 873 (PM2 v2.9.3: God) 
 Tasks: 30 (limit: 4915) 
 Memory: 171.6M 
 CPU: 11.528s 
 CGroup: /system.slice/pm2-root.service 
 ├─873 PM2 v2.9.3: God Daemon (/root/.pm2) 
 ├─895 node /opt/users/user-server.mjs 
 └─904 node /opt/notes/app.mjs

```

要验证 PM2 是否按照播发的方式启动服务，请重新启动服务器，然后使用 PM2 检查状态：

![](Images/f0dc3a61-6892-4324-b0e7-8bf34c9b535b.png)

首先要注意的是，在最初登录到`root`帐户时，`pm2 status`命令不可用。我们在`/opt/init`本地安装了 PM2，该命令仅在该目录中可用。

转到该目录后，我们现在可以运行命令并查看状态。记住在`TWITTER_CALLBACK_HOST`环境变量中设置正确的 IP 地址或域名。否则，使用 Twitter 登录将失败。

我们现在有一个相当好的管理系统下的 Notes 应用程序。我们可以轻松地在服务器上更新其代码并重新启动服务。如果服务崩溃，PM2 将自动重启。日志文件会自动保存以供我们阅读。

PM2 还支持在笔记本电脑上从源位置进行部署，我们可以将其推送到暂存或生产环境。为了支持这一点，我们必须将部署信息添加到`ecosystem.json`文件中，然后运行`pm2 deploy`命令将代码推送到服务器。详见 PM2 网站：[http://pm2.keymetrics.io/docs/usage/deployment/](http://pm2.keymetrics.io/docs/usage/deployment/) 。

虽然 PM2 在管理服务器进程方面做得很好，但我们开发的系统不足以提供互联网规模的服务。如果 Notes 应用程序被病毒攻击，突然我们需要在地球上部署一百万台服务器，会怎么样？像这样一次部署和维护一台服务器是不可扩展的。

我们在开始时也跳过了架构决策的实现。将用户身份验证数据放在同一台服务器上存在安全风险。我们希望在更严格的安全性下，将这些数据部署到不同的服务器上。

在下一节中，我们将探索一个新的系统 Docker，它解决了这些问题以及更多问题。

# Node.js 与 Docker 的微服务部署

码头工人（[http://docker.com](http://docker.com) 是软件行业的新亮点。人们的兴趣像疯了一样迅速发展，催生了许多项目，这些项目的名称往往包含集装箱周围的双关语。

它被描述为*一个面向开发人员和系统管理员的分布式应用程序开放平台*。它是围绕 Linux 容器化技术设计的，重点描述 Linux 任何变体上的软件配置。

Docker 在软件容器中自动化应用程序部署。Linux 容器的基本概念可以追溯到 20 世纪 70 年代的第一次实现，以及其他系统，如 Solaris Zones。Docker 实现基于 Linux cGroup、内核名称空间和支持联合的文件系统创建了一个软件隔离和虚拟化层，这些文件系统融合在一起，使 Docker 成为现实。这是一个沉重的极客讲话，所以让我们尝试一个更简单的解释。

Docker 容器是 Docker 映像的运行实例。映像是一个给定的 Linux 操作系统和应用程序配置，由开发人员根据他们的想法设计。开发者使用**Dockerfile**描述图像。Dockerfile 是一个相当简单的脚本，它向 Docker 展示了如何构建图像。Docker 映像被设计为复制到任何服务器，其中映像被实例化为 Docker 容器。

一个正在运行的容器会让您感觉自己置身于一个在虚拟机上运行的虚拟服务器中。但 Docker 集装箱化与 VirtualBox 等虚拟机系统有很大不同。容器中运行的进程实际上是在主机操作系统上运行的。容器化技术（cgroup、内核名称空间等）产生了在 Dockerfile 中指定的 Linux 变体上运行的假象，即使主机操作系统完全不同。你的主机操作系统可以是 Ubuntu，容器操作系统可以是 Fedora 或 OpenSUSE；Docker 让一切都顺利

相比之下，使用虚拟机软件（VirtualBox 和 VMWare 等），您使用的感觉就像是一台真正的计算机。有一个虚拟 BIOS 和虚拟化系统硬件，您必须安装一个成熟的来宾操作系统。您必须遵循计算机所有权的每一个惯例，包括如果它是一个封闭源代码系统（如 Windows），则确保许可证的安全

虽然 Docker 主要针对 x86 版本的 Linux，但它可以在几种基于 ARM 的操作系统以及其他处理器上使用。您甚至可以在单板计算机上运行 Docker，例如 Raspberry Pis，用于面向硬件的物联网项目。诸如 Resin.IO 之类的操作系统经过优化，可以单独运行 Docker 容器。

Docker 生态系统包含许多工具，它们的数量正在迅速增加。出于我们的目的，我们将重点关注以下三种特定工具：

*   **Docker engine**：这是协调一切的核心执行系统。它在 Linux 主机系统上运行，公开了一个基于网络的 API，客户端应用程序使用该 API 发出 Docker 请求，例如构建、部署和运行容器。
*   **Docker machine**：这是一个客户端应用程序，围绕在主机上配置 Docker 引擎实例执行功能。
*   **Docker compose**：这有助于您在单个文件中定义多容器应用程序，并定义其所有依赖项。

有了 Docker 生态系统，您可以创建一整套子网和服务来实现您的梦想应用程序。这个世界可以在你的笔记本电脑上运行，也可以部署到遍布全球的云托管设施网络上。歹徒可以攻击的表面区域由开发商严格定义。多容器应用程序甚至会强烈限制服务之间的访问，以至于那些设法闯入容器的歹徒会发现很难从容器中跳出。

使用 Docker，我们将首先在笔记本电脑上设计上图所示的系统。然后，我们将该系统迁移到服务器上的 Docker 实例。

# 在笔记本电脑上安装 Docker

学习如何在笔记本电脑上安装 Docker 的最佳场所是 Docker 文档网站。我们要找的是 Docker**社区版**（**CE**）。有 Docker**企业版**（**EE**），有更多功能和一些支付支持费的机会：

*   macOS 安装–[https://docs.docker.com/docker-for-mac/install/](https://docs.docker.com/docker-for-mac/install/)
*   Windows 安装–[https://docs.docker.com/docker-for-windows/install/](https://docs.docker.com/docker-for-windows/install/)
*   Ubuntu 安装–[https://docs.docker.com/install/linux/docker-ce/ubuntu/](https://docs.docker.com/install/linux/docker-ce/ubuntu/)
*   其他几个发行版也有相关说明。一些有用的安装后 Linux 说明位于[https://docs.docker.com/install/linux/linux-postinstall/](https://docs.docker.com/install/linux/linux-postinstall/)

因为 Docker 在 Linux 上运行，所以它不会在 macOS 或 Windows 上本机运行。在任一操作系统上安装都需要在虚拟机中安装 Linux，然后在该虚拟 Linux 机中运行 Docker 工具。你必须自己动手安装的日子早已一去不复返了。Docker 团队为 Mac 和 Windows 开发了易于使用的 Docker 应用程序，从而简化了这一过程。Docker for Windows 和 Docker for Mac 捆绑包打包了 Docker 工具和轻量级虚拟机软件。结果是非常轻量级的，Docker 容器可以在后台运行，影响很小

您可以找到 Docker Toolbox 的参考资料，作为在 macOS 上安装 Docker 的方法。该应用程序早已过时，取而代之的是 Docker for Windows 和 Docker for Mac。

# 使用 Docker for Windows/macOS 启动 Docker

启动 Docker for Windows 或 Mac 非常简单。您只需找到并双击应用程序图标。它会像任何其他本机应用程序一样启动。启动时，它管理一个虚拟机（不是 VirtualBox），其中有一个运行 Docker 引擎的 Linux 实例。在 macOS 上，会显示一个菜单栏图标，您可以用它控制`Docker.app`，在 Windows 上，系统托盘中会显示一个图标

有一些设置可以让 Docker 在您每次启动笔记本电脑时自动启动。

在这两个方面，CPU 都必须支持**虚拟化**。Docker for Windows 和 Docker for Mac 内部捆绑了一个超轻量的虚拟机监控程序，这反过来又需要 CPU 的虚拟化支持

对于 Windows，这可能需要 BIOS 配置。参见[https://docs.docker.com/docker-for-windows/troubleshoot/#virtualization-必须启用](https://docs.docker.com/docker-for-windows/troubleshoot/#virtualization-must-be-enabled)。

对于 Mac 而言，这需要 2010 年或更高版本的硬件，以及 Intel 对**内存管理单元**（MMU）虚拟化的硬件支持，包括**扩展页表**（**EPT**）和无限制模式。您可以通过运行`sysctl kern.hv_support`来检查此支持。它还需要 macOS 10.11 或更高版本。

# 踢码头工人的轮胎

安装完成后，我们可以使用本地 Docker 实例来创建 Docker 容器，运行一些命令，并学习如何使用这个惊人的系统。

正如在许多软件旅程中一样，这一次从说`Hello World`开始：

```js
$ docker run hello-world 
Unable to find image 'hello-world:latest' locally 
latest: Pulling from library/hello-world 
ca4f61b1923c: Pull complete 
Digest: sha256:66ef312bbac49c39a89aa9bcc3cb4f3c9e7de3788c944158df3ee0176d32b751 
Status: Downloaded newer image for hello-world:latest 

Hello from Docker! 
This message shows that your installation appears to be working correctly. 

To generate this message, Docker took the following steps: 
 1\. The Docker client contacted the Docker daemon. 
 2\. The Docker daemon pulled the "hello-world" image from the Docker Hub. 
 (amd64) 
 3\. The Docker daemon created a new container from that image which runs the 
 executable that produces the output you are currently reading. 
 4\. The Docker daemon streamed that output to the Docker client, which sent it 
 to your terminal. 

To try something more ambitious, you can run an Ubuntu container with: 
 $ docker run -it ubuntu bash 

Share images, automate workflows, and more with a free Docker ID: 
 https://cloud.docker.com/ 

For more examples and ideas, visit: 
 https://docs.docker.com/engine/userguide/

```

`docker run`命令下载命令行上命名的 Docker 映像，从该映像初始化 Docker 容器，然后运行该容器。在这种情况下，名为`hello-world`的图像不在本地计算机上，必须下载并初始化。完成后，`hello-world`容器被执行并打印出这些指令。

您可以查询您的计算机，查看`hello-world`容器已执行并完成时，它仍然存在：

![](Images/cc937772-57f6-4ded-adb8-f35cd52fc8a6.png)

`docker ps`命令列出正在运行的 Docker 容器。【T1 显示的是容器，但现在已经不存在了，【T3 显示的是】这些容器已经不存在了。我们还看到这台计算机安装了一个 Nextcloud 实例及其相关数据库。

使用完容器后，可以使用以下命令进行清理：

```js
$ docker rm boring_lumiere
boring_lumiere 
```

名称`boring_lumiere`是 Docker 自动生成的容器名称。虽然图像名称为`hello-world`，但这不是容器名称。Docker 生成了容器名称，因此容器的标识符比容器 ID 列中显示的十六进制 ID 更方便用户。创建容器时，很容易指定您喜欢的任何容器名称。

# 为用户身份验证服务创建 AuthNet

随着所有这些理论在我们脑海中旋转，是时候做一些实际的事情了。让我们从设置用户身份验证服务开始。在前面显示的图中，这将是标记为 AuthNet 的框，其中包含一个 MySQL 实例和身份验证服务器。

# Docker 的 MySQL 容器

要查找公开可用的 Docker 图像，请转到[https://hub.docker.com/](https://hub.docker.com/) 和搜索。您会发现许多 Docker 图像已准备就绪。例如，Nextcloud 及其相关数据库在我们启动轮胎时显示在`hello-world`应用程序旁边。两个团队都可以从各自的项目中使用`docker run nextcloud`和【更多】容器。安装 Nextcloud 及其相关数据库以及许多其他打包应用程序（如 GitLab）的过程与构建 AuthNet 的过程非常相似，因此您将要学习的技能非常实用。

仅 MySQL 就有 11000 多个容器可用。幸运的是，MySQL 团队提供的两个容器非常流行且易于使用。`mysql/mysql-server`映像更容易配置，所以让我们使用它

可以指定 Docker 映像名称，以及通常为软件版本号的*标记*。在本例中，我们将使用`mysql/mysql-server:5.7`，其中`mysql/mysql-server`是容器名称，`5.7`是标签。MySQL 5.7 是当前的 GA 版本。下载图片如下：

```js
$ docker pull mysql/mysql-server:5.7
5.7: Pulling from mysql/mysql-server
4040fe120662: Pull complete 
d049aa45d358: Pull complete 
a6c7ed00840d: Pull complete 
853789d8032e: Pull complete 
Digest: sha256:1b4c7c24df07fa89cdb7fe1c2eb94fbd2c7bd84ac14bd1779e3dec79f75f37c5
Status: Downloaded newer image for mysql/mysql-server:5.7
```

这一共下载了四张图片，因为这张图片是建立在其他三张图片之上的。稍后，我们将在学习如何构建 Dockerfile 时看到它是如何工作的

可以使用此图像启动容器，如下所示：

```js
$ docker run --name=mysql --env MYSQL_ROOT_PASSWORD=f00bar  mysql/mysql-server:5.7 
[Entrypoint] MySQL Docker Image 5.7.21-1.1.4 
[Entrypoint] Initializing database 
[Entrypoint] Database initialized 
... 
[Entrypoint] ignoring /docker-entrypoint-initdb.d/* 
[Entrypoint] Server shut down 
[Entrypoint] MySQL init process done. Ready for start up. 
[Entrypoint] Starting MySQL 5.7.21-1.1.4

```

我们在前台启动了这项服务。容器名称为`mysql`。我们设置了一个环境变量，它依次（根据图像文档）初始化`root`密码，如图所示。在另一个窗口中，我们可以进入容器并运行 MySQL 客户端，如下所示：

```js
$ docker exec -it mysql mysql -u root -p 
Enter password:  
Welcome to the MySQL monitor.  Commands end with ; or \g. 
Your MySQL connection id is 4 
Server version: 5.7.21 MySQL Community Server (GPL) 

Copyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved. 

Oracle is a registered trademark of Oracle Corporation and/or its 
affiliates. Other names may be trademarks of their respective 
owners. 

Type 'help;' or '\h' for help. Type '\c' to clear the current input statement. 

mysql> show databases; 
+--------------------+ 
| Database           | 
+--------------------+ 
| information_schema | 
| mysql              | 
| performance_schema | 
| sys                | 
+--------------------+ 
4 rows in set (0.00 sec) 

mysql> 
```

**`docker exec`**命令允许您在容器内运行程序。`-it`选项表示命令在指定的终端上以交互方式运行。将`bash`替换为`mysql`，您将拥有一个交互式`bash`命令 shell。

此`mysql`命令实例正在容器内运行。容器默认配置为不公开任何外部端口，并且有一个默认的`my.cnf`文件。

数据库文件被锁定在容器内。一旦删除该容器，数据库就会消失。Docker 容器应该是短暂的，可以根据需要创建和销毁，而数据库应该是永久的，生命周期有时以几十年为单位。

换句话说，我们可以轻松安装和启动 MySQL 实例，这很酷。但也有一些不足之处：

*   从其他软件访问数据库
*   将数据库文件存储在容器外部以延长使用寿命
*   自定义配置，因为数据库管理员喜欢调整设置
*   它需要与用户身份验证服务一起连接到 AuthNet

在继续之前，让我们先清理一下。在终端窗口中，键入：

```js
$ docker stop mysql 
mysql $ docker rm mysql
mysql

```

这将关闭并清理容器。而且，为了重申前面提到的观点，该容器中的数据库消失了。如果该数据库包含关键信息，您就失去了它，没有机会恢复数据。

# 初始化 AuthNet

Docker 支持在容器之间创建虚拟桥接网络。请记住，Docker 容器具有已安装 Linux 操作系统的许多功能。每个容器都可以有自己的 IP 地址和公开的端口。Docker 支持创建虚拟以太网段，称为**桥接网络**。这些网络仅存在于主机内，默认情况下，主机外的任何东西都无法访问这些网络。

因此，Docker 桥网络的访问受到严格限制。连接到网桥网络的任何 Docker 容器都可以与连接到该网络的其他容器通信。容器通过主机名相互查找，Docker 包含一个嵌入式 DNS 服务器来设置所需的主机名。该 DNS 服务器配置为不需要域名中的点，这意味着每个容器的 DNS/主机名只是容器名称，而不是像`container-name.service`这样的东西。使用主机名标识容器的策略是 Docker 的服务发现实现。

创建一个名为`authnet`的目录，作为`users`和`notes`目录的同级目录。我们将在该目录中使用 AuthNet。

创建一个文件`buildauthnet.sh`，其中包含以下内容：

```js
docker network create --driver bridge authnet
```

键入以下内容：

```js
$ sh -x buildauthnet.sh
+ docker network create --driver bridge authnet 
3021e2069278c2acb08d94a2d31507a43f089db1c02eecc97792414b498eb785
```

这将创建一个 Docker 桥网络。

# Windows 上的脚本执行

在 Windows 上执行脚本是不同的，因为它使用 PowerShell 而不是`bash`，以及大量其他注意事项。为此，以及随后的脚本将进行这些更改。

Powershell 脚本文件名必须以`.ps1`扩展名结尾。对于大多数脚本，这就是所需的全部内容，因为脚本非常简单。要执行脚本，只需在 Powershell 窗口中键入`.\scriptname.ps1`。换句话说，在 Windows 上，刚才显示的脚本必须命名为`buildauthnet.ps1`，并作为`.\buildauthnet.ps1`执行。

要执行脚本，您可能需要更改 Powershell 执行策略：

```js
PS C:\Users\david\chap10\authnet> Get-ExecutionPolicy
Restricted
PS C:\Users\david\chap10\authnet> Set-ExecutionPolicy Unrestricted
```

显然，此更改有安全方面的考虑，因此在完成后将执行策略更改回原处。

Windows 上更简单的方法是将这些命令粘贴到 PowerShell 窗口中

# 链接 Docker 容器

在 Docker 的早期，我们被告知使用`--link`选项链接容器。通过该选项，Docker 将在`/etc/hosts`中创建条目，以便一个容器可以通过其主机名引用另一个容器。该选项还安排了对链接容器之间的 TCP 端口和卷的访问。这允许创建多容器服务，使用专用 TCP 端口进行通信，不向容器外的进程公开任何内容。

今天，我们被告知，`--link`选项是一项传统功能，我们应该使用`bridge`网络。在本章中，我们将只关注`bridge`网络的使用。

您可以按如下方式列出网络：

```js
$ docker network ls 
NETWORK ID          NAME                DRIVER              SCOPE 
3021e2069278        authnet             bridge              local

```

使用此命令查看有关网络的详细信息：

```js
$ docker network inspect authnet
 ... much JSON output

```

目前，这不会显示任何连接到`authnet`的容器。输出显示网络名称、该网络的 IP 范围、默认网关以及其他有用的网络配置信息。因为没有任何东西连接到网络，所以让我们开始构建所需的容器。

# db userauth 容器

现在我们有了一个网络，我们可以开始将容器连接到该网络。然后我们将探索容器，看看它们有多私有。

创建一个脚本`startdb.sh`，包含：

```js
docker run --name db-userauth --env MYSQL_RANDOM_ROOT_PASSWORD=true \ 
    --env MYSQL_USER=userauth --env MYSQL_PASSWORD=userauth \ 
    --env MYSQL_DATABASE=userauth \ 
    --volume `pwd`/my.cnf:/etc/my.cnf \
    --volume `pwd`/../userauth-data:/var/lib/mysql \ 
    --network authnet mysql/mysql-server:5.7

```

在 Windows 上，您需要将脚本命名为`startdb.ps1`，并将文本全部放在一行上，而不是用反斜杠扩展行。并且，`/var/lib/mysql`上安装的卷必须单独创建。请改用以下命令：

```js
docker volume create db-userauth-volume

docker run --name db-userauth --env MYSQL_RANDOM_ROOT_PASSWORD=true --env MYSQL_USER=userauth --env MYSQL_PASSWORD=userauth --env MYSQL_DATABASE=userauth --volume $PSScriptRoot\my.cnf:/etc/my.cnf --volume db-userauth-volume:/var/lib/mysql --network authnet mysql/mysql-server:5.7
```

运行时，容器将被命名为`db-userauth`。为了提供一点安全性，`root`密码已经随机分配。我们定义了一个名为`userauth`的数据库，由名为`userauth`的用户使用密码`userauth`访问。这并不完全安全，所以请随意选择更好的名称和密码。容器连接到`authnet`网络。

我们必须讨论两个选项。在 Dockerese 中，卷是容器内的东西，可以从容器外装入。在本例中，我们将在主机文件系统中定义一个卷`userauth-data`，作为`/var/lib/mysql`装入容器中。而且，我们正在定义一个本地的`my.cnf`文件，用作容器内的`/etc/my.cnf`。

对于 Windows 版本，`--volume`挂载有两个更改。我们将`/etc/my.cnf`的装载指定为`$PSScriptRoot\my.cnf:/etc/my.cnf`，因为这是您在 Powershell 中引用本地文件的方式

对于`/var/lib/mysql,`我们引用了一个单独创建的卷。卷是使用`volume create`命令创建的，使用该命令无法控制卷的位置。重要的是，卷位于容器外部，以便数据库文件在该容器的销毁/创建周期中生存

总的来说，这些设置意味着数据库文件和配置文件位于容器外部，因此将在一个特定容器的生命周期之外存在。要获取`my.cnf`，您必须在不使用`--volume `pwd`/my.cnf:/etc/my.cnf`选项的情况下运行容器一次，以便将默认`my.cnf`文件复制到`authnet`目录中。

在不使用该选项的情况下运行脚本一次：

```js
$ sh startdb.sh 
... much output
[Entrypoint] GENERATED ROOT PASSWORD: UMyh@q]@j4qijyj@wK4s4SkePIkq
... much output

```

输出与我们前面看到的类似，但对于给出随机密码的换行符：

```js
$ docker network inspect authnet
```

这将告诉您`db-userauth`容器已连接到`authnet`：

```js
$ docker exec -it db-userauth mysql -u userauth -p 
Enter password:  
Welcome to the MySQL monitor.  Commands end with ; or \g.
   ... much output mysql> show databases; 
+--------------------+ 
| Database           | 
+--------------------+ 
| information_schema | 
| userauth           | 
+--------------------+ 
2 rows in set (0.00 sec) 

mysql> use userauth; 
Database changed 
mysql> show tables; 
Empty set (0.00 sec)

```

我们看到我们的数据库已经创建，它是空的。但我们这样做是为了抓取`my.cnf`文件：

```js
$ docker cp db-userauth:/etc/my.cnf . 
$ ls 
my.cnf  mysql-data  startdb.sh 

```

`docker cp`命令用于将文件复制到容器中或从容器中复制出来。如果您使用过`scp`，语法会很熟悉。

一旦你有了`my.cnf`文件，你可能会想要做一大堆的设置更改。第一个具体修改是注释掉一行读数`socket=/var/lib/mysql/mysql.sock`，第二个具体修改是添加一行读数`bind-address = 0.0.0.0`。这些更改的目的是将 MySQL 服务配置为在 TCP 端口而不是 Unix 域套接字上侦听。这使得可以从容器外部与 MySQL 服务通信。结果将是：

```js
# socket=/var/lib/mysql/mysql.sock 
bind-address = 0.0.0.0
```

现在停止`db-userauth`服务，并移除容器，就像我们之前做的那样。编辑`startdb`脚本，使线路挂载`/etc/my.cnf`进入容器，然后重启容器：

```js
$ docker stop db-userauth 
db-userauth
$ docker rm db-userauth   
db-userauth $ sh ./startdb.sh 
[Entrypoint] MySQL Docker Image 5.7.21-1.1.4 
[Entrypoint] Starting MySQL 5.7.21-1.1.4

```

现在，如果我们检查`authnet`网络，我们会看到以下内容：

```js
$ docker network inspect authnet 
        "Name": "authnet",
         ...
                    "Subnet": "172.18.0.0/16", 
                    "Gateway": "172.18.0.1"
        ... 
 "Containers": { 
 "Name": "db-userauth", 
 "MacAddress": "02:42:ac:12:00:02", 
 "IPv4Address": "172.18.0.2/16",
   ...
```

换句话说，`authnet`网络有网络号`172.18.0.0/16`，并且`db-userauth`容器被分配了`172.18.0.2`。这种详细程度很少重要，但在我们第一次到第二次仔细检查设置时非常有用，以便我们了解我们正在处理的问题：

```js
# cat /etc/resolv.conf 
search attlocal.net 
nameserver 127.0.0.11 
options ndots:0

```

如前所述，Docker bridge 网络设置中运行着 DNS 服务器，域名解析配置为使用`nodots`。因此 Docker 容器名称是容器的 DNS 主机名：

```js
# mysql -h db-userauth -u userauth -p 
Enter password: 
Welcome to the MySQL monitor.  Commands end with ; or \g. 
Your MySQL connection id is 33 
Server version: 5.7.21 MySQL Community Server (GPL)

```

使用容器名称作为主机名访问 MySQL 服务器。

# 验证服务的 Dockerfile

在`users`目录中，创建一个名为`Dockerfile`的文件，其中包含以下内容：

```js
FROM node:10

ENV DEBUG="users:*" 
ENV PORT="3333" 
ENV SEQUELIZE_CONNECT="sequelize-docker-mysql.yaml" 
ENV REST_LISTEN="0.0.0.0" 

RUN mkdir -p /userauth
COPY package.json sequelize-docker-mysql.yaml *.mjs *.js /userauth/
WORKDIR /userauth
RUN apt-get update -y \
 && apt-get -y install curl python build-essential git ca-certificates \
 && npm install --unsafe-perm 

EXPOSE 3333 
CMD npm run docker 
```

DockerFile 描述了服务器上应用程序的安装。参见[https://docs.docker.com/engine/reference/builder/](https://docs.docker.com/engine/reference/builder/) 用于文件编制。它们在 Docker 容器映像中记录位的组装，Docker 文件中的指令用于构建 Docker 映像

`FROM`命令指定一个预先存在的图像，从中导出给定的图像。我们刚才谈过,；您可以从现有映像开始构建 Docker 容器。正式的 Node.js Docker 映像（[https://hub.docker.com/_/node/ 我们使用的](https://hub.docker.com/_/node/)是从`debian:jessie`派生出来的。因此，Debian 提供了容器中可用的命令，我们使用`apt-get`来安装更多的软件包。我们使用 Node.js 10，因为它支持 ES6 模块和我们一直使用的其他功能。

`ENV`命令定义环境变量。在本例中，我们使用的环境变量与用户身份验证服务中定义的环境变量相同，只是我们有一个新的`REST_LISTEN`变量。我们很快就会看一看。

`RUN`命令是我们运行构建容器所需的 shell 命令的地方。第一件事是创建一个包含服务源代码的`/userauth`目录。`COPY`命令将文件复制到该目录中。然后我们需要运行一个`npm install`，这样我们才能运行服务。但首先我们使用`WORKDIR`命令将当前工作目录移动到`/userauth`中，以便`npm install`在正确的位置运行。我们还安装了必要的 Debian 软件包，以便可以安装任何本机代码 Node.js 软件包。

由于 Docker build 缓存，建议您始终在同一命令行中组合`apt-get update`和`apt-get install`，如下所示。重建图像时，Docker 从第一个更改的行开始。通过将这两者结合在一起，您可以确保在更改要安装的软件包列表时随时执行`apt-get update`。有关完整的讨论，请参见[中的文档 https://docs.docker.com/develop/develop-images/dockerfile_best-practices/](https://docs.docker.com/develop/develop-images/dockerfile_best-practices/) 。

本命令末尾为`npm install --unsafe-perm`。这里的问题是，这些命令是作为`root`运行的。通常，当`npm`作为`root`运行时，它会将其用户 ID 更改为非特权用户。但是，这可能会导致失败，`--unsafe-perm`选项会阻止更改用户 ID。

`EXPOSE`命令通知 Docker 容器侦听指定的 TCP 端口。这不会暴露容器之外的端口。

最后，CMD 命令记录了执行容器时要启动的进程。`RUN`命令是在构建容器时执行的，而 CMD 表示容器启动时执行的内容。

我们可以在容器中安装 PM2，然后使用 PM2 命令启动服务。但 Docker 能够实现相同的功能，因为它支持在服务进程终止时自动重新启动容器。稍后我们将看到如何执行此操作。

# 为 Docker 配置身份验证服务

我们正在为`SEQUELIZE_CONNECT`使用不同的文件。创建一个名为`users/sequelize-docker-mysql.yaml`的新文件，其中包含以下内容：

```js
dbname: userauth 
username: userauth 
password: userauth 
params: 
    host: db-userauth 
    port: 3306 
    dialect: mysql 
```

区别在于，我们使用`db-userauth`代替`localhost`作为数据库主机。早些时候，我们研究了`db-userauth`容器，并确定这是容器的主机名。通过在此文件中使用`db-userauth`，身份验证服务将使用容器中的数据库。

现在我们需要处理名为`REST_LISTEN`的环境变量。以前，身份验证服务器只侦听了`http://localhost:3333`。我们这样做是为了安全，也就是说，限制哪些进程可以连接到服务。在 Docker 下，我们需要从其容器外部连接到此服务，以便其他容器可以连接到此服务。因此，它必须监听本地主机外部的连接。在`users-server.mjs`中，我们需要做以下更改：

```js
server.listen(process.env.PORT, 
  process.env.REST_LISTEN ? process.env.REST_LISTEN : "localhost", 
  () => { log(server.name +' listening at '+ server.url); }); 
```

也就是说，如果`REST_LISTEN`变量存在，REST 服务器将被告知听它所说的任何内容，否则服务将听`localhost`。通过 Dockerfile 中的环境变量，身份验证服务将监听世界（`0.0.0.0`。我们是不是把谨慎抛在脑后，放弃了保存所有这些用户身份信息的神圣信任？不，耐心点。我们将简要介绍如何将此服务及其数据库连接到`AuthNet`，并阻止任何其他进程访问`AuthNet`。

# 构建和运行身份验证服务 Docker 容器

在`users/package.json`中，在`scripts`部分添加以下行：

```js
"docker": "node --experimental-modules ./user-server",
"docker-build": "docker build -t node-web-development/userauth ."
```

之前，我们已经将配置环境变量放入了`package.json`。在这种情况下，配置环境变量位于 Dockerfile 中。这意味着我们需要一种运行服务器的方法，除了 Dockerfile 中的环境变量外，不使用其他环境变量。通过这个`scripts`条目，我们可以执行`npm run docker`，然后 Dockerfile 环境变量将提供所有配置。

我们可以按如下方式构建身份验证服务：

```js
$ npm run docker-build

> user-auth-server@0.0.1 docker-build /Users/david/chap10/users
> docker build -t node-web-development/userauth .

Sending build context to Docker daemon 33.8MB
Step 1/11 : FROM node:9.5
 ---> a696309517c6
Step 2/11 : ENV DEBUG="users:*"
 ---> Using cache
 ---> f8cc103432e8
Step 3/11 : ENV PORT="3333"
 ---> Using cache
 ---> 39b24b8b554e
... more output
```

`docker build`命令从 Dockerfile 构建容器。如前所述，该过程从`FROM`命令中定义的图像开始。然后，构建一步一步地进行，输出会在执行时逐字显示每个步骤。

然后创建一个脚本`authnet/startserver.sh`，或在 Windows 上调用它`startserver.ps1`，其中包含以下命令：

```js
docker run -it --name userauth --net=authnet node-web-development/userauth
```

这将启动新建的容器，命名为`userauth`，并将其附加到`authnet`：

```js
$ sh -x startserver.sh 
+ docker run -it --name userauth --net=authnet node-web-development/userauth

> user-auth-server@0.0.1 docker /userauth
> node --experimental-modules ./user-server

(node:17) ExperimentalWarning: The ESM module loader is experimental.
 users:service User-Auth-Service listening at http://0.0.0.0:3333 +0ms

```

这将启动用户身份验证服务。在 Windows 上，将其启动为`.\startserver.ps1`。您应该记得它是一个 REST 服务，因此通过`users-add.js`和其他脚本来运行它。但是，由于我们没有从服务公开公共端口，因此必须从容器内部运行这些脚本。

我们确定容器是否以两种方式之一公开公共端口。最简单的方法是运行`docker ps -a`并查看容器列表详细信息。有一列标记为 PORTS，对于`userauth`我们可以看到`3333/tcp`。这是 Dockerfile 中 EXPOSE 命令的副作用。如果该端口被暴露，它将在端口列中显示为`0.0.0.0:3333->3333/tcp`。记住`userauth`容器的目标，以及`authnet`的总体目标是，出于安全考虑，它不会公开访问。

# 探索 Authnet

让我们探讨一下我们刚刚创建的内容：

```js
$ docker network inspect authnet  
```

这将打印出一个大型 JSON 对象，描述网络及其连接的容器，我们之前已经看过了。如果一切顺利，我们将看到现在有两个容器连接到`authnet`，而之前只有一个容器。

让我们进入`userauth`容器，四处看看：

```js
$ docker exec -it userauth bash
root@a29d833287bf:/userauth# ls 
node_modules                 user-server.mjs  users-list.js 
package-lock.json            users-add.js     users-sequelize.mjs 
package.json                 users-delete.js 
sequelize-docker-mysql.yaml  users-find.js

```

`/userauth`目录位于容器内，并且正是使用`COPY`命令放置在容器中的文件，加上`node_modules:`中安装的文件

```js
root@a29d833287bf:/userauth# PORT=3333 node users-list.js 
List [] 
root@a29d833287bf:/userauth# PORT=3333 node users-add.js 
Created { id: 1, username: 'me', password: 'w0rd', provider: 'local', 
 familyName: 'Einarrsdottir', givenName: 'Ashildr', 
 middleName: '', emails: '[]', photos: '[]', 
 updatedAt: '2018-02-05T01:54:53.320Z', createdAt: '2018-02-
 05T01:54:53.320Z' } 
root@a29d833287bf:/userauth# PORT=3333 node users-list.js 
List [ { id: 'me', username: 'me', provider: 'local', 
 familyName: 'Einarrsdottir', givenName: 'Ashildr', middleName: '', 
 emails: '[]', photos: '[]' } ]

```

我们将用户添加到身份验证服务的测试有效：

```js
root@a29d833287bf:/userauth# ps -eafw 
UID        PID  PPID  C STIME TTY          TIME CMD 
root         1     0  0 01:52 pts/0    00:00:00 /bin/sh -c npm run docker 
root         9     1  0 01:52 pts/0    00:00:00 npm 
root        19     9  0 01:52 pts/0    00:00:00 sh -c node --experimental-modules ./user-server 
root        20    19  0 01:52 pts/0    00:00:01 node --experimental-modules ./user-server 
root        30     0  0 01:54 pts/1    00:00:00 bash 
root        70    30  0 01:57 pts/1    00:00:00 ps -eafw 
root@a29d833287bf:/userauth# ping db-userauth 
PING db-userauth (172.18.0.2): 56 data bytes 
64 bytes from 172.18.0.2: icmp_seq=0 ttl=64 time=0.105 ms 
64 bytes from 172.18.0.2: icmp_seq=1 ttl=64 time=0.077 ms 
^C--- db-userauth ping statistics --- 
2 packets transmitted, 2 packets received, 0% packet loss 
round-trip min/avg/max/stddev = 0.077/0.091/0.105/0.000 ms 
root@a29d833287bf:/userauth# ping userauth 
PING userauth (172.18.0.3): 56 data bytes 
64 bytes from 172.18.0.3: icmp_seq=0 ttl=64 time=0.132 ms 
64 bytes from 172.18.0.3: icmp_seq=1 ttl=64 time=0.095 ms 
^C--- userauth ping statistics --- 
2 packets transmitted, 2 packets received, 0% packet loss

```

过程列表是一个有趣的研究对象。过程 PID 1 是 Dockerfile 中的`npm run docker`命令。进程从那里进入运行实际服务器的`node`进程。

一个`ping`命令证明这两个容器可以作为与容器名称匹配的主机名使用。

然后，您可以登录到`db-userauth`容器并检查数据库：

```js
$ docker exec -it db-userauth bash 
bash-4.2# mysql -u userauth -p 
Enter password:  
Welcome to the MySQL monitor.  Commands end with ; or \g.
 ... mysql> use userauth 

Database changed 
mysql> show tables; 
+--------------------+ 
| Tables_in_userauth | 
+--------------------+ 
| Users              | 
+--------------------+ 
1 row in set (0.00 sec) 

mysql> select * from Users; 
+----+----------+----------+----------+---------------+-----------+--...
| id | username | password | provider | familyName    | givenName |  ...
+----+----------+----------+----------+---------------+-----------+--...
|  1 | me       | w0rd     | local    | Einarrsdottir | Ashildr   |  ...
+----+----------+----------+----------+---------------+-----------+--...
1 row in set (0.00 sec)

```

我们已经成功地将用户身份验证服务停靠在两个容器`db-userauth`和`userauth`中。我们在一个正在运行的容器的内部进行了探测，发现了一些有趣的东西。但是，我们的用户需要出色的 Notes 应用程序才能运行，我们不能坐享其成。

# 为 Notes 应用程序创建 FrontNet

我们在 Docker 容器中设置了系统的后半部分，以及连接后端容器的专用网桥网络。我们现在需要建立另一个专用网桥网络`frontnet`，并将系统的另一半连接到该网络。

创建一个目录`frontnet`，在这里我们将开发用于构建和运行该网络的工具。在该目录中，创建一个文件`buildfrontnet.sh`，或在 Windows 上创建一个文件`buildfrontnet.ps1`，其中包含：

```js
docker network create --driver bridge frontnet
```

让我们继续创建`frontnet`桥接网络：

```js
$ sh -x buildfrontnet.sh 
+ docker network create --driver bridge frontnet
f3df227d4bfff57bc7aed1e096a2ad16f6cebce4938315a54d9386a42d1ae3ed
$ docker network ls
NETWORK ID NAME DRIVER SCOPE
3021e2069278 authnet bridge local
f3df227d4bff frontnet bridge local  
```

我们将从这里开始，类似于`authnet`是如何创建的。但是，我们可以更快地工作，因为我们已经复习了基础知识。

# Notes 应用程序的 MySQL 容器

从`authnet`目录中，将`my.cnf`和`startdb.sh`文件复制到`frontnet`目录中。`my.cnf`文件可能未经修改即可使用，但我们需要对`startdb.sh`文件进行一些更改：

```js
docker run --name db-notes --env MYSQL_RANDOM_ROOT_PASSWORD=true \
 --env MYSQL_USER=notes --env MYSQL_PASSWORD=notes12345 \
 --env MYSQL_DATABASE=notes \
 --volume `pwd`/my.cnf:/etc/my.cnf \
 --volume `pwd`/../notes-data:/var/lib/mysql \
 --network frontnet mysql/mysql-server:5.7
```

在 Windows 上，将包含以下内容的文件命名为`startdb.ps1`：

```js
docker volume create notes-data-volume

docker run --name db-notes --env MYSQL_RANDOM_ROOT_PASSWORD=true --env MYSQL_USER=notes --env MYSQL_PASSWORD=notes12345 --env MYSQL_DATABASE=notes --volume $PSScriptRoot\my.cnf:/etc/my.cnf --volume notes-data-volume:/var/lib/mysql --network frontnet mysql/mysql-server:5.7
```

The changes are simple substitutions to transliterate from `userauth` to `notes`. And then run it:

```js
$ mkdir ../notes-data
$ sh -x startdb.sh 
+ pwd
+ pwd
+ docker run --name db-notes --env MYSQL_RANDOM_ROOT_PASSWORD=true --env MYSQL_USER=notes --env MYSQL_PASSWORD=notes12345 --env MYSQL_DATABASE=notes --volume /home/david/nodewebdev/node-web-development-code-4th-edition/chap10/frontnet/my.cnf:/etc/my.cnf --volume /home/david/nodewebdev/node-web-development-code-4th-edition/chap10/frontnet/../notes-data:/var/lib/mysql --network frontnet mysql/mysql-server:5.7
[Entrypoint] MySQL Docker Image 5.7.21-1.1.4
[Entrypoint] Initializing database
[Entrypoint] Database initialized
[Entrypoint] GENERATED ROOT PASSWORD: 3kZ@q4hBItYGYj3Mes!AdiP83Nol
[Entrypoint] ignoring /docker-entrypoint-initdb.d/*
[Entrypoint] Server shut down
[Entrypoint] MySQL init process done. Ready for start up.
[Entrypoint] Starting MySQL 5.7.21-1.1.4
```

对于 Windows，只需运行`.\startdb.ps1`。

该数据库将在`frontnet`上的`db-notes`域名上可用。因为它连接到`frontnet`，所以连接到`authnet`的容器无法访问它。

```js
$ docker exec -it userauth bash 
root@0a2009334b79:/userauth# ping db-notes 
ping: unknown host

```

由于`db-notes`位于不同的网段上，我们实现了分离。

# 停靠 Notes 应用程序

在`notes`目录中，创建一个名为`Dockerfile`的文件，其中包含以下内容：

```js
FROM node:10 

ENV DEBUG="notes:*,messages:*" 
ENV SEQUELIZE_CONNECT="models/sequelize-docker-mysql.yaml" 
ENV NOTES_MODEL="sequelize" 
ENV USER_SERVICE_URL="http://userauth:3333" 
ENV PORT="3000" 
ENV NOTES_SESSIONS_DIR="/sessions" 
# ENV TWITTER_CONSUMER_KEY="..."
# ENV TWITTER_CONSUMER_SECRET="..."
# Use this line when the Twitter Callback URL
# has to be other than localhost:3000
# ENV TWITTER_CALLBACK_HOST=http://45.55.37.74:3000 

RUN mkdir -p /notesapp /notesapp/minty /notesapp/partials /notesapp/public /notesapp/routes /notesapp/theme /notesapp/views
COPY minty/ /notesapp/minty/
COPY models/*.mjs models/sequelize-docker-mysql.yaml /notesapp/models/
COPY partials/ /notesapp/partials/
COPY public/ /notesapp/public/
COPY routes/ /notesapp/routes/
COPY theme/ /notesapp/theme/
COPY views/ /notesapp/views/
COPY app.mjs package.json /notesapp/

WORKDIR /notesapp
RUN apt-get update -y \
 && apt-get -y install curl python build-essential git ca-certificates \
 && npm install --unsafe-perm

# Uncomment to build the theme directory
# WORKDIR /notesapp/theme
# RUN npm run download && npm run build && npm run clean

WORKDIR /notesapp

VOLUME /sessions 
EXPOSE 3000 
CMD node --experimental-modules ./app
```

这类似于我们用于身份验证服务的 Dockerfile。我们使用的是来自 TyoT0 的环境变量，再加上一个新的变量，这里有一些新的技巧，所以让我们来看一看。

最明显的变化是`COPY`命令的数量。考虑到必须安装的文件子目录的数量，Notes 应用程序要复杂得多。我们首先创建 Notes 应用程序部署树的顶级目录。然后，我们一个接一个地将每个子目录复制到容器文件系统中相应的子目录中。

在`COPY`命令中，目标目录上的尾随斜杠很重要。为什么？因为文件上说后面的斜杠很重要。

最大的问题是：为什么要使用这样的多个`COPY`命令？这本来是非常简单的：

```js
COPY . /notesapp
```

但是，重要的是避免将`node_modules`目录复制到容器中。容器`node_modules`必须构建在容器内部，因为容器操作系统几乎肯定与主机操作系统不同。必须为正确的操作系统构建任何本机代码模块。这种限制导致了将特定文件简洁地复制到目标的问题。

我们已经开发了一个构建 Bootstrap 4 主题的过程，这是我们在[第 6 章](06.html)中开发的，*实现了移动第一范式*。如果要构建 Bootstrap 4 主题，只需在 Dockerfile 中取消注释相应的行即可。这些行将工作目录移动到`/notesapp/theme`，然后运行脚本来构建主题。主题构建完成后，需要在`theme/package.json`中使用新脚本删除`theme/node_modules`目录：

```js
 "scripts": {
    ...
    "clean": "rm -rf bootstrap-4.0.0/node_modules"
    ...
}
```

我们还有一个新的`SEQUELIZE_CONNECT`文件。创建包含以下内容的`models/sequelize-docker-mysql.yaml`：

```js
dbname: notes 
username: notes 
password: notes12345
params: 
    host: db-notes 
    port: 3306 
    dialect: mysql 
```

这将使用命名的数据库、用户名和密码访问`db-notes`域名上的数据库服务器

请注意，`USER_SERVICE_URL`变量不再访问`localhost`处的身份验证服务，而是访问`userauth`处的身份验证服务。`userauth`域名目前仅由 AuthNet 上的 DNS 服务器发布，但 Notes 服务在 FrontNet 上。这意味着我们必须将`userauth`容器连接到 FrontNet 网桥网络，以便其名称在那里也为人所知。我们马上就到。

在第 8 章*中，我们讨论了保护 Twitter 提供的 API 密钥的必要性。*

 *我们不想在源代码中提交密钥，但它们必须放在某个地方。Dockerfile 中有占位符，用于指定`TWITTER_CONSUMER_KEY`和`TWITTER_CONSUMER_SECRET`。

`TWITTER_CALLBACK_HOST`的值需要反映 Notes 部署的位置。现在，它仍然在您的笔记本电脑上，但到本章结束时，它将部署到服务器上，届时，它将需要服务器的 IP 地址或域名。

一个新变量是`NOTES_SESSIONS_DIR`和匹配的`VOLUME`声明。如果要运行多个 Notes 实例，它们可以通过共享此卷来共享会话数据。

支持`NOTES_SESSIONS_DIR`变量需要对`app.mjs`进行一次更改：

```js
const sessionStore  = new FileStore({ 
    path: process.env.NOTES_SESSIONS_DIR ?             
          process.env.NOTES_SESSIONS_DIR : "sessions" 
}); 
```

我们可以使用环境变量来定义存储会话数据的位置，而不是硬编码的目录名。或者，对于不同的服务器（如 REDIS），也有`sessionStore`实现，可以在不同主机系统上的容器之间共享会话数据。

在`notes/package.json,`中添加以下脚本：

```js
"scripts": {
    ...
    "docker": "node --experimental-modules ./app",
    "docker-build": "docker build -t node-web-development/notes ."
    ...
}
```

至于身份验证服务器，这允许我们构建容器，然后在容器内运行服务

现在我们可以构建容器映像：

```js
$ npm run docker-build

> notes@0.0.0 docker-build /Users/david/chap10/notes
> docker build -t node-web-development/notes .

Sending build context to Docker daemon 76.27MB
Step 1/22 : FROM node:9.5
 ---> a696309517c6
Step 2/22 : ENV DEBUG="notes:*,messages:*"
 ---> Using cache
 ---> 8628ecad9fa4
```

接下来，在`frontnet`目录中创建一个名为`startserver.sh`的文件，或者在 Windows 上创建一个名为`startserver.ps1`的文件：

```js
docker run -it --name notes --net=frontnet -p 3000:3000 node-web-development/notes
```

与身份验证服务不同，Notes 应用程序容器必须向公众导出端口。否则，公众将永远无法享受我们正在建设的这一美妙的创造。`-p`选项是我们指示 Docker 公开端口的方式

第一个数字是从容器发布的 TCP 端口号，第二个数字是容器内的 TCP 端口号。一般来说，此选项将容器内的端口映射到公众可以访问的端口。

然后按如下方式运行它：

```js
$ sh -x startserver.sh 
+ docker run -it --name notes --net=frontnet -p 3000:3000 node-web-development/notes
(node:6) ExperimentalWarning: The ESM module loader is experimental.
 notes:debug-INDEX Listening on port 3000 +0ms
```

在 Windows 上，运行`.\startserver.ps1`。

此时，我们可以将浏览器连接到`http://localhost:3000`并开始使用 Notes 应用程序。但我们很快就会遇到一个问题：

![](Images/1ed9672c-8138-43ae-9613-fc7bb66b1d1a.png)

用户体验团队会对这个丑陋的错误消息大喊大叫，所以把它放到您的待办事项列表中，生成一个更漂亮的错误屏幕。例如，一群鸟把鲸鱼从海里拉出来是很受欢迎的。

此错误意味着 Notes 无法访问名为`userauth`的主机上的任何内容。该主机确实存在，因为容器正在运行，但它不在`frontnet`上，并且无法从`notes`容器访问。即：

```js
$ docker exec -it notes bash 
root@125a196c3fd5:/notesapp# ping userauth 
ping: unknown host 
root@125a196c3fd5:/notesapp# ping db-notes 
PING db-notes (172.19.0.2): 56 data bytes 
64 bytes from 172.19.0.2: icmp_seq=0 ttl=64 time=0.136 ms 
^C--- db-notes ping statistics --- 
1 packets transmitted, 1 packets received, 0% packet loss 
round-trip min/avg/max/stddev = 0.136/0.136/0.136/0.000 ms 
root@125a196c3fd5:/notesapp# 

```

如果检查 FrontNet 和 AuthNet，您将看到附加到每个的容器不重叠：

```js
$ docker network inspect frontnet
$ docker network inspect authnet
```

在本章开头的架构图中，我们展示了`notes`和`userauth`容器之间的连接。需要连接，以便`notes`可以验证其用户。但这种联系还不存在。

不幸的是，对`startserver.sh`（`startserver.ps1`的简单更改不起作用：

```js
docker run -it --name notes --net=authnet --net=frontnet -p 3000:3000 node-web-development/notes
```

虽然在启动容器时指定多个`--net`选项在概念上很简单，但 Docker 不支持这一点。它以静默方式接受如图所示的命令，但仅将容器连接到选项中提到的最后一个网络。相反，Docker 要求您采取第二步将容器连接到第二个网络：

```js
$ docker network connect authnet notes
```

在没有其他更改的情况下，Notes 应用程序现在将允许您登录并开始添加和编辑 Notes

有一个突出的建筑问题正盯着我们。我们是将`userauth`服务连接到`frontnet`还是将`notes`服务连接到`authnet`？要验证任一方向都解决了问题，请运行以下命令：

```js
$ docker network disconnect authnet notes 
$ docker network connect frontnet userauth

```

第一次，我们将`notes`连接到`authnet`，然后我们将其从`authnet`断开，然后将`userauth`连接到`frontnet`。这意味着我们尝试了两种组合，正如预期的那样，在这两种情况下`notes`和`userauth`都能够沟通。

这是一个安全专家的问题，因为考虑的是任何入侵者可用的攻击向量。假设 Notes 有一个安全漏洞，允许入侵者访问。我们如何限制通过那个洞可以到达的东西

主要观察到，通过将`notes`连接到`authnet`，`notes`不仅可以访问`userauth`，还可以访问`db-userauth`：

```js
$ docker network disconnect frontnet userauth
$ docker network connect authnet notes
$ docker exec -it notes bash
root@7fce818e9a4d:/notesapp# ping userauth
PING userauth (172.18.0.3): 56 data bytes
64 bytes from 172.18.0.3: icmp_seq=0 ttl=64 time=0.103 ms
^C--- userauth ping statistics ---
1 packets transmitted, 1 packets received, 0% packet loss
round-trip min/avg/max/stddev = 0.103/0.103/0.103/0.000 ms
root@7fce818e9a4d:/notesapp# ping db-userauth
PING db-userauth (172.18.0.2): 56 data bytes
64 bytes from 172.18.0.2: icmp_seq=0 ttl=64 time=0.201 ms
^C--- db-userauth ping statistics ---
1 packets transmitted, 1 packets received, 0% packet loss
round-trip min/avg/max/stddev = 0.201/0.201/0.201/0.000 ms
root@7fce818e9a4d:/notesapp# 
```

此序列将`notes`重新连接到`authnet`，并演示访问`userauth`和`db-userauth`容器的能力。因此，成功的入侵者可以访问`db-userauth`数据库，这是我们想要防止的结果。我们最初的图表显示`notes`和`db-userauth`之间没有这种联系。

考虑到我们使用 Docker 的目标是限制攻击向量，我们对两种容器/网络连接设置有明确的区别。在`frontnet`上附加`userauth`限制了可以访问`db-userauth`的容器数量。入侵者要访问用户信息数据库，必须先闯入`notes`，然后再闯入`userauth`。除非，也就是说，我们的业余安全审计尝试是有缺陷的。

# 控制 MySQL 数据卷的位置

`db-userauth`和`db-notes`DockerFile 包含`VOLUME /var/lib/mysql`，当我们启动容器时，我们给出了`--volume`选项，为该容器目录分配了一个主机目录：

```js
docker run --name db-notes \
  ...
  --volume `pwd`/../notes-data:/var/lib/mysql \
  ...
```

我们可以很容易地看到它连接了一个主机目录，因此它出现在该位置的容器中。使用`ls`等工具简单地检查主机目录，就会发现文件是在该目录中创建的，该目录对应于一个 MySQL 数据库。

`VOLUME`指令指示 Docker 在容器外部创建一个目录，并映射该目录，以便将其装载在容器内部的命名路径上。`VOLUME`指令本身并不控制主机上的目录名。如果没有给出`--volume`选项，Docker 仍然安排将所述目录的内容保存在容器外部。这很有用，至少数据在容器外部是可用的，但是您没有控制位置。

如果我们在不使用`/var/lib/mysql`的`--volume`选项的情况下重新启动`db-notes`容器，我们可以检查容器以发现 Docker 将卷放在何处：

```js
$ docker inspect --format '{{json .Mounts}}' db-notes
[{"Type":"bind",
"Source":"/Users/david/chap10/frontnet/my.cnf","Destination":"/etc/my.cnf",
"Mode":"","RW":true,"Propagation":"rprivate"},{"Type":"volume","Name":"39f9a80b49e3ecdebc7789de7b7dd2366c400ee7fbfedd6e4df18f7e60bad409",
"Source":"/var/lib/docker/volumes/39f9a80b49e3ecdebc7789de7b7dd2366c400ee7fbfedd6e4df18f7e60bad409/_data","Destination":"/var/lib/mysql",
"Driver":"local","Mode":"","RW":true,"Propagation":""}]
```

这并不完全是一个用户友好的路径名，但是您可以窥探到该目录并看到 MySQL 数据库确实存储在那里。为卷使用用户友好的路径名的最简单方法是使用前面显示的`--volume`选项。

我们的另一个优势是可以轻松切换数据库。例如，我们可以使用预先准备好的测试数据库来测试笔记，这些数据库中充满了用斯瓦希里语（`notes-data-swahili`）、罗马尼亚语（`notes-data-romanian`）、德语（`notes-data-german`）和英语（`notes-data-english`）编写的笔记。每个测试数据库都可以存储在指定的目录中，针对特定语言的测试就像使用不同的`--volume`选项运行 notes 容器一样简单

在任何情况下，如果您使用`--volume`选项重新启动`notes`容器，您可以检查容器并查看目录是否装载在您指定的目录上：

```js
$ docker inspect --format '{{json .Mounts}}' db-notes 
[{"Type":"bind",
"Source":"/Users/david/chap10/frontnet/my.cnf","Destination":"/etc/my.cnf",
"Mode":"","RW":true,"Propagation":"rprivate"},
{"Type":"bind",
"Source":"/Users/david/chap10/notes-data","Destination":"/var/lib/mysql",
"Mode":"","RW":true,"Propagation":"rprivate"}]

```

通过`--volume`选项，我们控制了容器目录对应的主机目录的位置。

最后要注意的是，控制这些目录的位置可以更容易地对这些数据进行备份和执行其他管理操作。

# Docker 部署后台服务

使用我们目前编写的脚本，Docker 容器在前台运行。这使得调试服务更容易，因为您看到了错误。对于生产部署，我们需要将 Docker 容器与终端分离，这两个属性很容易实现。

只需改变这种模式：

```js
$ docker run -it ...
```

对于这种模式：

```js
$ docker run --detach --restart always ...
```

`-it`选项是导致 Docker 容器在前台运行的原因。使用这些选项会导致 Docker 容器与您的终端分离运行，如果服务进程终止，容器将自动重新启动。

# 使用 Docker compose 部署到云端

我们可以为我们创建的软件服务创建封装的实例化，这很酷。但承诺是使用停靠的应用程序在云服务上部署。换句话说，我们需要学习所有这些知识，并将其应用于在具有相当高安全性的公共 internet 服务器上部署 Notes 的任务中。

我们已经证明，使用 Docker，Notes 可以分解为四个容器，它们彼此之间以及与外部世界之间具有高度的隔离

还有另一个明显的问题：我们在上一节中的流程部分是手动的，部分是自动的。我们创建了脚本来启动系统的每个部分，根据十二因素应用程序模型，这是一个很好的实践。但是，我们并没有自动执行整个过程来提供 Notes 和身份验证服务。此解决方案也不能扩展到一台机器之外。

让我们从最后一个问题开始，首先是可伸缩性。在 Docker 生态系统中，有几个**Docker orchestrator**服务可用。编排器在一组机器上自动部署和管理 Docker 容器。Docker 编排器的一些示例包括 Docker Swarm（内置于 Docker CLI 中）、Kubernetes、CoreOS Fleet 和 Apache Mesos。这些功能强大的系统能够根据需要自动增加/减少资源，将容器从一台主机移动到另一台主机，等等。随着您需求的增长，我们提到这些系统供您进一步学习。

Docker compose（[https://docs.docker.com/compose/overview/](https://docs.docker.com/compose/overview/) 将解决我们发现的其他问题。它让我们可以轻松地定义和运行几个 Docker 容器，作为一个完整的应用程序。它使用 YAML 文件`docker-compose.yml`来描述容器、它们的依赖关系、虚拟网络和卷。虽然我们将使用它来描述在单个主机上的部署，但 Docker compose 可用于多机部署，特别是与 Docker Swarm 结合使用时。理解 Docker compose 将为理解/使用其他工具（如 Swarm 或 Kubernetes）提供基础。

码头装卸机（[https://docs.docker.com/machine/overview/](https://docs.docker.com/machine/overview/) 是一个用于在本地或远程虚拟主机上安装 Docker Engine 以及管理这些主机上 Docker 容器的工具。我们将使用它在云托管服务上配置服务器，并将容器推送到该服务器中。它还可用于在 VirtualBox 实例中为笔记本电脑提供虚拟主机。

继续之前，确保安装了 Docker compose 和 Docker machine。如果您已经安装了 Docker for Windows 或 Docker for Mac，则这两种软件都会与其他软件一起安装。在 Linux 上，必须按照前面给出的链接上的说明分别安装这两个组件。

# Docker 编写文件

让我们首先创建一个目录`compose`，作为`users`和`notes`目录的同级目录。在该目录中，创建一个名为`docker-compose.yml`的文件：

```js
version: '3'
services:

  db-userauth:
    image: "mysql/mysql-server:5.7"
    container_name: db-userauth
    command: [ "mysqld", "--character-set-server=utf8mb4", 
              "--collation-server=utf8mb4_unicode_ci",
              "--bind-address=0.0.0.0" ]
    expose:
      - "3306"
    networks:
      - authnet
    volumes:
      - db-userauth-data:/var/lib/mysql
      - ../authnet/my.cnf:/etc/my.cnf
    environment:
      MYSQL_RANDOM_ROOT_PASSWORD: "true"
      MYSQL_USER: userauth
      MYSQL_PASSWORD: userauth
      MYSQL_DATABASE: userauth
    restart: always

  userauth:
    build: ../users
    container_name: userauth
    depends_on:
      - db-userauth
    networks:
      - authnet
      - frontnet
    restart: always

  db-notes:
    image: "mysql/mysql-server:5.7"
    container_name: db-notes
    command: [ "mysqld", "--character-set-server=utf8mb4", 
              "--collation-server=utf8mb4_unicode_ci",
              "--bind-address=0.0.0.0" ]
    expose:
      - "3306"
    networks:
      - frontnet
    volumes:
      - db-notes-data:/var/lib/mysql
      - ../frontnet/my.cnf:/etc/my.cnf
    environment:
      MYSQL_RANDOM_ROOT_PASSWORD: "true"
      MYSQL_USER: notes
      MYSQL_PASSWORD: notes12345
      MYSQL_DATABASE: notes
    restart: always

  notes:
    build: ../notes
    container_name: notes
    restart: always
    depends_on:
      - db-notes
    networks:
      - frontnet
    ports:
      - "3000:3000"
    restart: always

networks:
  frontnet:
    driver: bridge
  authnet:
    driver: bridge

volumes: 
  db-userauth-data: 
  db-notes-data:
```

这是对整个 Notes 部署的描述。它具有相当高的抽象级别，大致相当于我们迄今为止使用的命令行工具上的选项。更多详细信息位于 DockerFile 中，DockerFile 是从该 compose 文件引用的。

`version`行表示这是一个版本 3 的撰写文件。版本号由`docker-compose`命令检查，因此可以正确解释其内容。完整的文档值得在[上阅读 https://docs.docker.com/compose/compose-file/](https://docs.docker.com/compose/compose-file/) 。

这里使用了三个主要部分：**服务**、**卷**和**网络**。服务部分描述正在使用的容器，网络部分描述网络，卷部分描述卷。每个部分的内容都与我们前面运行的命令的意图/目的相匹配。我们已经处理过的信息都在这里，只是重新排列了一下

有两个数据库容器，`db-userauth`和`db-notes`。两者都使用`image`标记引用 Dockerhub 图像。对于数据库，我们没有创建 Dockerfile，而是直接从 Dockerhub 映像构建。在撰写文件中也会发生同样的情况。

对于`userauth`和`notes`容器，我们创建了一个 Dockerfile。包含该文件的目录由`build`标记引用。为了构建容器，`docker-compose`在命名目录中查找名为`Dockerfile`的文件。`build`标签有更多选项，这些选项在官方文档中讨论。

`container_name`属性等同于`--name`属性，并为容器指定一个用户友好的名称。为了进行 Docker 风格的服务发现，必须指定容器名称才能指定容器主机名。

`command`标记覆盖 Dockerfile 中的`CMD`标记。我们已经为两个数据库容器指定了这个，所以我们可以指示 MySQL 绑定到 IP 地址`0.0.0.0`。尽管我们没有为数据库容器创建 Dockerfile，但 MySQL 维护人员还是创建了一个 Dockerfile

`networks`属性列出此容器必须连接到的网络，它与`--net`参数完全等效。即使`docker`命令不支持多个`--net`选项，我们也可以在 compose 文件中列出多个网络。在这种情况下，网络是桥接网络。正如我们前面所做的那样，网络本身必须单独创建，并且在一个组合文件中，这在*网络*部分中完成。

我们系统中的每个网络都是一个`bridge`网络。这一事实在撰写文件中有描述。

`expose`属性声明从容器中公开哪些端口，并与`EXPOSE`标记等效。但是，公开的端口不会在主机外部发布。`ports`属性声明要发布的端口。在 ports 声明中，我们有两个端口号：第一个是已发布的端口号，第二个是容器内的端口号。这与前面使用的`-p`选项完全相同。

`notes`容器有几个环境变量，例如`TWITTER_CONSUMER_KEY`和`TWITTER_CONSUMER_SECRET`，您可能更愿意将它们存储在此文件中，而不是存储在 Dockerfile 中

`depends_on`属性允许我们控制启动顺序。依赖于另一个容器的容器将等待启动，直到依赖的容器正在运行。

`volumes`属性描述容器目录到`host`目录的映射。在本例中，我们定义了两个卷名，`db-userauth-data`和`db-notes-data`，然后将它们用于卷映射。要浏览卷，请从以下命令开始：

```js
$ docker volume ls 
DRIVER              VOLUME NAME 
... 
local               compose_db-notes-data 
local               compose_db-userauth-data 
...

```

卷名与 compose 文件中的卷名相同，但前面加了`compose*_*`。

您可以使用`docker`命令行检查卷位置：

```js
$ docker volume inspect compose_db-notes-data
$ docker volume inspect compose_db-userauth-data  
```

如果更好，您可以在`compose`文件中指定路径名：

```js
db-auth: 
  .. 
  volumes: 
    # - db-userauth-data:/var/lib/mysql 
    - ../userauth-data:/var/lib/mysql 

db-notes: 
  .. 
  volumes: 
    # - db-notes-data:/var/lib/mysql 
    - ../notes-data:/var/lib/mysql 
```

这与我们之前所做的配置相同。它使用 MySQL 数据文件的`userauth-data`和`notes-data`目录作为各自的数据库容器。

`environment`标记描述容器将接收的环境变量。与前面一样，应该使用环境变量来注入配置数据

`restart`属性控制容器死亡时发生的情况。当容器启动时，它运行在`CMD`指令中命名的程序，当该程序退出时，容器退出。但是，如果该程序打算永远运行*，Docker 难道不知道应该重新启动该过程吗？我们可以使用后台流程主管，如 Supervisord 或 PM2。但是，我们也可以使用 Docker`restart`选项。*

 *`restart`属性可以采用以下四个值之一：

*   `no`-不要重新启动
*   `on-failure:count`-最多重启*N*次
*   `always`-始终重新启动
*   `unless-stopped`-启动容器，除非容器已明确停止

# 使用 Docker compose 运行 Notes 应用程序

在 Windows 上，我们可以原封不动地运行本节中的命令。

在将其部署到服务器之前，让我们使用`docker-compose`在笔记本电脑上运行它：

```js
$ docker stop db-notes userauth db-auth notesapp
db-notes
userauth
db-auth
notesapp
$ docker rm db-notes userauth db-auth notesapp
db-notes
userauth
db-auth
notesapp  
```

我们首先需要停止并删除现有的容器。由于 compose 文件希望启动与我们先前构建的容器同名的容器，因此我们还必须删除现有容器：

```js
$ docker-compose build
Building db-auth
.. lots of output
$ docker-compose up
Creating db-auth
Recreating compose_db-notes_1
Recreating compose_userauth_1
Recreating compose_notesapp_1
Attaching to db-auth, db-notes, userauth, notesapp 
```

完成后，我们可以构建容器`docker-compose build`，然后启动它们运行`docker-compose up`。

第一个测试是在`userauth`中执行一个 shell 来运行我们的用户数据库脚本：

```js
$ docker exec -it userauth bash
root@9972adbbdbb3:/userauth# PORT=3333 node users-add.js 
Created { id: 2,
 username: 'me', password: 'w0rd', provider: 'local',
 familyName: 'Einarrsdottir', givenName: 'Ashildr', middleName: '',
 emails: '[]', photos: '[]',
 updatedAt: '2018-02-07T02:24:04.257Z', createdAt: '2018-02-07T02:24:04.257Z' }
root@9972adbbdbb3:/userauth# 
```

既然我们已经证明了身份验证服务可以工作，顺便说一句，我们已经创建了一个用户帐户，那么您应该能够浏览 Notes 应用程序并运行它。

您还可以尝试 ping 不同的容器，以确保正确创建了应用程序网络拓扑。

If you use Docker command-line tools to explore the running containers and networks, you'll see they have new names. The new names are similar to the old names, but prefixed with the string `compose_`. This is a side effect of using Docker compose.

默认情况下，`docker-compose`连接到容器，以便在终端上打印日志输出。所有四个容器的输出将混合在一起。谢天谢地，每行前面都有容器名称。

完成系统测试后，只需在终端上键入*CTRL*+*C*：

```js
^CGracefully stopping... (press Ctrl+C again to force) 
Stopping db-userauth ... done 
Stopping userauth    ... done 
Stopping db-notes    ... done 
Stopping notes       ... done

```

为避免集装箱与码头相连时运行，请使用`-d`选项。这表示要从终端分离并在后台运行。

另一种关闭 compose 文件中描述的系统的方法是使用`docker-compose down`命令

`up`命令构建、重新创建和启动容器。构建步骤可以使用`docker-compose build`命令单独处理。同样，可以使用`docker-compose start`和`docker-compose-stop`命令分别处理容器的启动和停止。

在所有情况下，您的命令 shell 都应该位于包含`docker-compose.yml`文件的目录中。这是此文件的默认名称。可以使用`-f`选项覆盖此选项，以指定不同的文件名。

# 使用 Docker compose 部署到云主机

我们已经在笔记本电脑上验证了 compose 文件描述的服务是否按预期工作。启动容器现在是自动化的，解决了我们前面提到的一个问题。现在是了解如何部署到云托管提供商的时候了。这就是我们转向 Docker 机器的地方。

Docker machine 可用于在笔记本电脑上的 VirtualBox 主机内配置 Docker 实例。我们要做的是在 DigitalOcean 上配置 Docker 系统。`docker-machine`命令附带了支持一长串云托管提供商的驱动程序。只需替换不同的驱动程序，就可以很容易地为其他提供商调整此处显示的说明。

注册 DigitalOcean 帐户后，单击仪表板中的 API 链接。我们需要一个 API 令牌来授予`docker-machine`访问该帐户的权限。完成创建令牌的过程并保存给定的令牌字符串。Docker 网站在[有一个教程 https://docs.docker.com/machine/examples/ocean/](https://docs.docker.com/machine/examples/ocean/) 。

在手边有令牌的情况下，键入以下内容：

```js
$ docker-machine create --driver digitalocean --digitalocean-size 2gb \
 --digitalocean-access-token TOKEN-FROM-PROVIDER \
 sandbox
Running pre-create checks...
Creating machine...
(sandbox) Creating SSH key...
(sandbox) Creating Digital Ocean droplet...
(sandbox) Waiting for IP address to be assigned to the Droplet...
Waiting for machine to be running, this may take a few minutes...
Detecting operating system of created instance...
Waiting for SSH to be available...
Detecting the provisioner...
Provisioning with ubuntu(systemd)...
Installing Docker...
Copying certs to the local machine directory...
Copying certs to the remote machine...
Setting Docker configuration on the remote daemon...
Checking connection to Docker...
Docker is up and running!
To see how to connect your Docker Client to the Docker Engine running on this virtual machine, run: docker-machine env sandbox
```

正如我们前面所说，`digitalocean`驱动程序与数字海洋一起使用。Docker 网站在[上有一个驱动程序列表 https://docs.docker.com/machine/drivers/](https://docs.docker.com/machine/drivers/) 。

这里有很多关于设置的信息。最重要的是结尾的信息。一系列环境变量用于告知`docker`命令在何处连接到 Docker 引擎实例。正如消息所说，运行：`docker-machine env sandbox`：

```js
$ docker-machine env sandbox
export DOCKER_TLS_VERIFY="1"
export DOCKER_HOST="tcp://45.55.37.74:2376"
export DOCKER_CERT_PATH="/home/david/.docker/machine/machines/sandbox"
export DOCKER_MACHINE_NAME="sandbox"
# Run this command to configure your shell: 
# eval $(docker-machine env sandbox)
```

这是用于访问我们刚刚创建的 Docker 主机的环境变量。您还应该转到云主机提供商仪表板，查看主机是否已创建。此命令还为我们提供了一些要遵循的说明：

```js
$ eval $(docker-machine env sandbox) 
$ docker-machine ls 
NAME      ACTIVE   DRIVER         STATE     URL                      SWARM   DOCKER        ERRORS 
sandbox   *        digitalocean   Running   tcp://45.55.37.74:2376           v18.01.0-ce    

```

这表明我们有一个 Docker 引擎实例在所选云托管提供商的主机上运行。

此时一个有趣的测试是在这个终端上运行`docker ps -a`，然后在没有这些环境变量的另一个终端上运行。这应该表明云主机根本没有容器，而您的本地计算机可能有一些容器（取决于您当前运行的容器）：

```js
$ docker run hello-world 
Unable to find image 'hello-world:latest' locally 
latest: Pulling from library/hello-world 
ca4f61b1923c: Pull complete  
Digest: sha256:66ef312bbac49c39a89aa9bcc3cb4f3c9e7de3788c944158df3ee0176d32b751 
Status: Downloaded newer image for hello-world:latest 
 ... $ docker images 
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE 
hello-world         latest              f2a91732366c        2 months ago        1.85kB

```

这里，我们已经验证了可以在远程主机上启动容器。

下一步是为新机器构建容器。由于我们已将环境变量切换为指向新服务器，因此这些命令会导致在那里而不是在笔记本电脑内部执行操作：

```js
$ docker-compose build
db-userauth uses an image, skipping
db-notes uses an image, skipping
Building notes
Step 1/22 : FROM node:9.5
9.5: Pulling from library/node
f49cf87b52c1: Pull complete
7b491c575b06: Pull complete
b313b08bab3b: Pull complete
51d6678c3f0e: Pull complete
...
```

因为我们改变了环境变量，构建发生在`sandbox`机器上，而不是像以前一样发生在我们的笔记本电脑上。

这将需要一段时间，因为远程计算机上的 Docker 映像缓存为空。此外，构建`notesapp`和`userauth`容器会将整个源代码树复制到服务器，并在服务器上运行所有构建步骤。

如果默认内存大小为 500 MB，则生成可能会失败，这是编写本文时 DigitalOcean 上的默认内存大小。如果是这样，首先要尝试将主机上的内存大小调整到至少 2GB。

远程启动计算机上的容器生成完成后：

```js
$ docker-compose up 
Creating notes ... done
Recreating db-userauth ... done
Recreating db-notes ... done
Creating notes ... 
Attaching to db-userauth, db-notes, userauth, notes
```

一旦容器启动，您应该像我们之前所做的那样测试`userauth`容器。不幸的是，第一次执行此操作时，该命令将失败。问题在于`docker-compose.yml`中的这些行：

```js
 - ../authnet/my.cnf:/etc/my.cnf
...
 - ../frontnet/my.cnf:/etc/my.cnf
```

在这种情况下，构建发生在远程机器上，`docker-machine`命令不会将命名文件复制到服务器上。因此，当 Docker 尝试启动容器时，它无法启动，因为无法满足卷装载，因为文件根本不在那里。因此，这意味着对`docker-compose.yml`进行一些手术，并添加两个新的 DockerFile。

首先，对`docker-compose.yml`进行以下更改：

```js
 ...
  db-userauth:
    build: ../authnet
    container_name: db-userauth
    networks:
      - authnet
    volumes:
      - db-userauth-data:/var/lib/mysql
    restart: always
  ...
 db-notes:
    build: ../frontnet
    container_name: db-notes
    networks:
      - frontnet
    volumes:
      - db-notes-data:/var/lib/mysql
    restart: always
```

我们现在不是从 Docker 映像构建数据库容器，而是从一对 Docker 文件构建它们。现在我们必须创建这两个 DockerFile。

在`authnet`中，创建一个名为`Dockerfile`的文件，其中包含以下内容：

```js
FROM mysql/mysql-server:5.7
EXPOSE 3306
COPY my.cnf /etc/
ENV MYSQL_RANDOM_ROOT_PASSWORD="true"
ENV MYSQL_USER=userauth
ENV MYSQL_PASSWORD=userauth
ENV MYSQL_DATABASE=userauth
CMD [ "mysqld", "--character-set-server=utf8mb4", \
  "--collation-server=utf8mb4_unicode_ci", "--bind-address=0.0.0.0" ]
```

这复制了`docker-compose.yml`中的`db-userauth`描述中的某些设置。重要的是我们现在使用的是`COPY`文件，而不是卷装载。

在`frontnet`中，创建一个包含以下内容的`Dockerfile`：

```js
FROM mysql/mysql-server:5.7
EXPOSE 3306
COPY my.cnf /etc/
ENV MYSQL_RANDOM_ROOT_PASSWORD="true"
ENV MYSQL_USER=notes
ENV MYSQL_PASSWORD=notes12345
ENV MYSQL_DATABASE=notes
CMD [ "mysqld", "--character-set-server=utf8mb4", \
  "--collation-server=utf8mb4_unicode_ci", "--bind-address=0.0.0.0" ]
```

这是相同的，但有一些关键值发生了变化。

进行这些更改后，我们现在可以构建容器并启动它们：

```js
$ docker-compose build
... much output
$ docker-compose up --force-recreate
... much output
```

现在我们已经有了一个工作的构建，并且可以启动容器，让我们检查它们并验证一切正常。

在`userauth`中执行一个 shell 来测试和设置用户数据库：

```js
$ docker exec -it userauth bash
root@931dd2a267b4:/userauth# PORT=3333 node users-list.js 
List [ { id: 'me', username: 'me', provider: 'local',
 familyName: 'Einarrsdottir', givenName: 'Ashildr', middleName: '',
 emails: '[]', photos: '[]' } ] 
```

如前所述，这将验证`userauth`服务是否有效，远程容器是否已设置，以及我们是否可以继续使用 Notes 应用程序。

问题是：要使用的 URL 是什么？服务不在`localhost`上，因为它在远程服务器上。我们没有分配域名，但有服务器的 IP 地址。

运行以下命令：

```js
$ docker-machine ip sandbox
45.55.37.74
```

Docker 告诉您 IP 地址，您应该将其用作 URL 的基础。因此，在您的浏览器中，访问`http://IP-ADDRESS:3000`

将 Notes 部署到远程服务器后，您应该查看我们前面介绍的所有内容。桥接网络应该存在，如前所示，在容器之间具有相同的有限访问。唯一的公共通道应该是`notes`集装箱上的`3000`端口

记住为您的服务器适当地设置`TWITTER_CALLBACK_HOST`环境变量。

因为我们的数据库容器装载了一个卷来存储数据，所以让我们看看该卷在服务器上的位置：

```js
$ docker volume ls
DRIVER VOLUME NAME
local compose_db-notes-data
local compose_db-userauth-data
```

这些是预期的体积，每个容器一个：

```js
$ docker volume inspect compose_db-notes-data
[
 {
 "CreatedAt": "2018-02-07T06:30:06Z",
 "Driver": "local",
 "Labels": {
 "com.docker.compose.project": "compose",
 "com.docker.compose.volume": "db-notes-data"
 },
 "Mountpoint": "/var/lib/docker/volumes/compose_db-notes-
 data/_data",
 "Name": "compose_db-notes-data",
 "Options": {},
 "Scope": "local"
 }
]
```

这些是目录，但它们不在我们的笔记本电脑上。相反，它们位于远程服务器上。访问这些目录意味着登录远程服务器查看：

```js
$ docker-machine ssh sandbox
Welcome to Ubuntu 16.04.3 LTS (GNU/Linux 4.4.0-112-generic x86_64)

 * Documentation: https://help.ubuntu.com
 * Management: https://landscape.canonical.com
 * Support: https://ubuntu.com/advantage

 Get cloud support with Ubuntu Advantage Cloud Guest:
 http://www.ubuntu.com/business/services/cloud

4 packages can be updated.
0 updates are security updates.

Last login: Wed Feb 7 04:00:29 2018 from 108.213.68.139
root@sandbox:~#
```

从这一点上，您可以检查与这些卷对应的目录，并看到它们确实包含 MySQL 配置和数据文件：

```js
root@sandbox:~# ls /var/lib/docker/volumes/compose_db-notes-data/_data 
auto.cnf         client-key.pem  ib_logfile1  mysql.sock.lock     public_key.pem 
ca-key.pem       ib_buffer_pool  ibtmp1       notes               server-cert.pem 
ca.pem           ibdata1         mysql        performance_schema  server-key.pem 
client-cert.pem  ib_logfile0     mysql.sock   private_key.pem     sys

```

您还将发现 Docker 命令行工具可以工作。流程列表特别有趣：

![](Images/4bdaa9e9-97c1-4ed2-985e-a317e4fe1d1f.png)

仔细看一下，您会看到一个与系统中的每个容器相对应的流程。这些进程正在主机操作系统中运行。Docker 围绕这些进程创建配置/包含层，以创建进程在不同操作系统下运行的外观，并使用容器屏幕截图中指定的各种系统/网络配置文件

Docker 与 VirtualBox 等虚拟化方法相比的优势在于 Docker 非常轻量级。我们在这里看到了为什么 Docker 是轻量级的：没有虚拟化层，只有一个容器化过程（`docker-containerd-shim`。

一旦您确信 Notes 正在远程服务器上工作，您可以按如下方式关闭并删除它：

```js
$ docker-compose stop
Stopping notesapp ... done
Stopping userauth ... done
Stopping db-notes ... done
Stopping db-auth ... done
```

这会立即关闭所有容器：

```js
$ docker-machine stop sandbox
Stopping "sandbox"...
Machine "sandbox" was stopped.
```

这将关闭远程机器。云托管提供商仪表板将显示水滴已停止。

此时，如果愿意，还可以继续删除 Docker machine 实例：

```js
$ docker-machine rm sandbox
About to remove sandbox
Are you sure? (y/n): y
Successfully removed sandbox  
```

而且，如果您确实确定要删除该机器，则前面的命令将执行此操作。一旦执行此操作，计算机将从云主机提供商仪表板中删除。

# 总结

本章经历了一段相当长的旅程。我们从一个仅存在于笔记本电脑上的应用程序，到探索将 Node.js 应用程序部署到生产服务器的两种方法。

我们首先回顾了 Notes 应用程序体系结构及其对部署的影响。这使您能够了解服务器部署必须执行的操作。

然后学习了使用 init 脚本在 Linux 上部署服务的传统方法。PM2 是在这样的环境中管理后台进程的有用工具。您还学习了如何使用虚拟机托管服务配置远程服务器。

然后，您进行了一次长途旅行，来到了 Docker 之地，这是一个用于在机器上部署服务的令人兴奋的新系统。您学习了如何编写 Docker 文件，以便 Docker 知道如何构建服务映像。您学习了在笔记本电脑或远程服务器上部署 Docker 映像的几种方法。您还学习了如何使用 Docker compose 描述多容器应用程序。

你差不多准备好收尾这本书了。一路上你学到了很多；最后还有两件事要讲。

在下一章中，我们将学习单元测试和功能测试。虽然测试驱动开发的一个核心原则是在编写应用程序之前编写单元测试，但我们采用了另一种方式，并将关于单元测试的一章放在本书的末尾。这并不是说单元测试不重要，因为它非常重要

在最后一章中，我们将探讨如何强化我们的应用程序和应用程序基础结构，以抵御攻击者。**