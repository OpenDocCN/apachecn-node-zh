# 单元测试和功能测试

单元测试已经成为良好软件开发实践的主要部分。它是一种测试源代码各个单元以确保正常运行的方法。理论上，每个单元都是应用程序中最小的可测试部分。在 No.js 应用程序中，您可以将每个模块视为一个单元。

在单元测试中，每个单元都被单独测试，将被测试单元尽可能与应用程序的其他部分隔离开来。如果测试失败，您可能希望它是由于代码中的错误，而不是由于代码碰巧使用的包中的错误。一种常见的技术是使用模拟对象或模拟数据将应用程序的各个部分彼此隔离。

另一方面，功能测试并不尝试测试单个组件，而是测试整个系统。由质量保证团队**或**质量保证团队进行。两种测试模型都需要对应用程序进行完全认证。一个类比可能是，单元测试类似于确保句子中的每个单词拼写正确，而功能测试则确保包含该句子的段落具有良好的结构。

在本章中，我们将介绍：

*   作为软件测试基础的断言
*   Mocha 单元测试框架和 Chai 断言库
*   使用测试查找 bug 并修复 bug
*   使用 Docker 管理测试基础架构
*   测试 REST 后端服务
*   使用 Puppeter 在真实 web 浏览器中进行 UI 测试
*   使用元素 ID 属性提高 UI 可测试性

# Assert–测试方法的基础

Node.js 有一个有用的内置测试工具，`assert`模块。它的功能类似于其他语言中的断言库。也就是说，它是测试条件的函数集合，如果条件指示错误，`assert`函数抛出异常。

最简单的说，测试套件是一系列的`assert`调用，用于验证被测试对象的行为。例如，测试套件可以实例化用户身份验证服务，然后进行 API 调用，使用`assert`方法验证结果，然后进行另一个 API 调用，验证其结果，等等。

考虑这样一个代码片段，您可以将其保存在名为“{ ToR.T0}”的文件中：

```js
const fs = require('fs'); 

exports.deleteFile = function(fname, callback) { 
  fs.stat(fname, (err, stats) => { 
    if (err) callback(new Error(`the file ${fname} does not exist`)); 
    else { 
      fs.unlink(fname, err2 => { 
        if (err) callback(new Error(`could not delete ${fname}`)); 
        else callback(); 
      }); 
    } 
  }); 
}; 
```

首先要注意的是，它包含了几层异步回调函数。这带来了两个挑战：

*   从回调的深处捕获错误，以确保测试场景失败
*   检测从未调用回调的情况

以下是使用`assert`进行测试的示例。创建一个名为`test-deleteFile.js`的文件，其中包含以下内容：

```js
const fs = require('fs'); 
const assert = require('assert'); 
const df = require('./deleteFile'); 

df.deleteFile("no-such-file", (err) => { 
    assert.throws( 
        function() { if (err) throw err; }, 
        function(error) { 
            if ((error instanceof Error) 
             && /does not exist/.test(error)) { 
               return true; 
            } else return false; 
        }, 
        "unexpected error" 
    ); 
}); 
```

这就是所谓的负面测试场景，因为它测试请求删除不存在的文件是否会引发错误。

如果您正在寻找一种快速的测试方法，`assert`模块在使用这种方法时会很有用。如果它运行且未打印任何消息，则测试通过。但是，它是否捕获了从未调用过的`deleteFile`回调实例？

```js
$ node test-deleteFile.js 
```

`assert`模块被许多测试框架用作编写测试用例的核心工具。测试框架所做的是创建一个熟悉的测试套件和测试用例结构来封装测试代码。

Node.js 中提供了多种类型的断言库。在本章后面，我们将使用 Chai 断言库（[http://chaijs.com/](http://chaijs.com/) ），您可以在三种不同的断言样式（应该、期望和断言）之间进行选择。

# 测试 Notes 模型

让我们从为 Notes 应用程序编写的数据模型开始单元测试之旅。因为这是单元测试，所以模型应该与 Notes 应用程序的其余部分分开测试。

对于大多数 Notes 模型，隔离它们的依赖关系意味着创建一个模拟数据库。您是要测试数据模型还是底层数据库？模拟数据库意味着创建一个虚假的数据库实现，这看起来不像是对我们时间的有效利用。您可以争辩说，测试数据模型实际上是测试代码与数据库之间的交互，模拟数据库意味着不测试该交互，因此我们应该针对生产中使用的数据库引擎测试代码。

考虑到这一思路，我们将跳过模拟数据库，而是对包含测试数据的数据库运行测试。为了简化启动测试数据库，我们将使用 Docker 启动和停止为测试而设置的 Notes 应用程序堆栈版本。

# 摩卡和柴-选择的测试工具

如果您还没有这样做，请复制要在本章中使用的源代码树。例如，如果您有一个名为`chap10`的目录，请创建一个名为`chap11`的目录，其中包含`chap10`中的所有内容。

在`notes`目录中，创建一个名为`test`的新目录。

摩卡咖啡（[http://mochajs.org/](http://mochajs.org/) 是 Node.js 可用的众多测试框架之一。正如您将很快看到的，它帮助我们编写测试用例和测试套件，并提供测试结果报告机制。之所以选择它，是因为它支持承诺。它非常适合前面提到的库。而且，我们需要使用 CommonJS 编写的测试套件中的 ES6 模块，因此我们必须使用`esm`模块。

您可以找到对早期`@std/esm`模块的引用。该模块已被弃用，取而代之的是`esm`。

在`notes/test`目录中，键入此项以安装摩卡、柴和`esm`：

```js
$ npm init
... answer the questions to create package.json
$ npm install mocha@5.x chai@4.1.x esm --save
```

# Notes 模型测试套件

因为我们有几个 Notes 模型，所以测试套件应该针对任何模型运行。我们可以使用我们开发的 Notes 模型 API 编写测试，并且应该使用环境变量来声明要测试的模型。

因为我们已经使用 ES6 模块编写了 Notes 应用程序，所以需要克服一个小挑战。Mocha 只支持在 CommonJS 模块中运行测试，Node.js（截至本文撰写时）不支持从 CommonJS 模块加载 ES6 模块。ES6 模块可以使用`import`加载 CommonJS 模块，但 CommonJS 模块不能使用`require`加载 ES6 模块。这背后有各种技术原因，底线是我们在这方面受到限制。

因为 Mocha 要求测试是 CommonJS 模块，所以我们必须将 ES6 模块加载到 CommonJS 模块中。存在一个模块`esm`，允许这种组合工作。如果您回头看，我们在上一节中安装了该模块。让我们看看如何使用它。

在`test`目录中，创建一个名为`test-model.js`的文件，其中包含此文件作为测试套件的外壳：

```js
'use strict'; 

require = require("esm")(module,{"esm":"js"});
const assert = require('chai').assert; 
const model = require('../models/notes');

describe("Model Test", function() { 
  .. 
}); 
```

此处显示的`require('esm')`语句启用了对加载 ES6 模块的支持。它将标准的`require`功能替换为`esm`模块中的一个功能。最后的参数列表使该功能能够在 CommonJS 模块中加载 ES6 模块。完成此操作后，CommonJS 模块可以加载一个 ES6 模块，后面的几行代码就证明了这一点。

Chai 库支持三种类型的断言。我们这里使用的是`assert`样式，但是如果您愿意，可以很容易地使用不同的样式。柴支持的其他样式参见[http://chaijs.com/guide/styles/](http://chaijs.com/guide/styles/) 。

Chai 的断言包括一长串有用的断言函数，请参见[http://chaijs.com/api/assert/](http://chaijs.com/api/assert/) 。

必须使用`NOTES_MODEL`环境变量选择要测试的 Notes 模型。对于同时参考环境变量的模型，我们还需要提供该配置。

使用摩卡，测试套件包含在`describe`块中。第一个参数是描述性文本，用于定制测试结果的表示形式。

我们可以在执行测试时动态创建一个测试数据库，而不是维护一个单独的测试数据库。Mocha 有所谓的钩子，是在测试用例执行之前或之后执行的函数。钩子函数允许您，测试套件的作者，为测试套件设置和删除所需的条件，以使其按需要运行。例如，要创建具有已知测试内容的测试数据库，请执行以下操作：

```js
describe("Model Test", function() { 
  beforeEach(async function() {
    try {
      const keyz = await model.keylist();
      for (let key of keyz) {
        await model.destroy(key);
      }
      await model.create("n1", "Note 1", "Note 1");
      await model.create("n2", "Note 2", "Note 2");
      await model.create("n3", "Note 3", "Note 3");
    } catch (e) {
      console.error(e);
      throw e;
    }
  });
    .. 
}); 
```

这定义了一个`beforeEach`钩子，它在每个测试用例之前执行。其他挂钩为`before`、`after`、`beforeEach`和`afterEach`。每个钩子在每个测试用例执行之前或之后被触发。

这是每次测试前的清理/准备步骤。它使用我们的 notesapi 首先从数据库中删除所有注释（如果有的话），然后创建一组具有已知特征的新注释。这项技术通过确保我们知道要测试的条件来简化测试。

我们还测试了`model.keylist`和`model.create`方法的副作用。

在 Mocha 中，一系列测试用例用`describe`块封装，并用`it`块编写。`describe`块用于描述这组测试，`it`块用于检查被测试对象的特定方面的断言。您可以将`describe`块嵌套到任意深度：

```js
  describe("check keylist", function() {
    it("should have three entries", async function() {
      const keyz = await model.keylist();
      assert.exists(keyz);
      assert.isArray(keyz);
      assert.lengthOf(keyz, 3);
    });
    it("should have keys n1 n2 n3", async function() {
      const keyz = await model.keylist();
      assert.exists(keyz);
      assert.isArray(keyz);
      assert.lengthOf(keyz, 3);
      for (let key of keyz) {
        assert.match(key, /n[123]/, "correct key");
      }
    });
    it("should have titles Node #", async function() {
      const keyz = await model.keylist();
      assert.exists(keyz);
      assert.isArray(keyz);
      assert.lengthOf(keyz, 3);
      var keyPromises = keyz.map(key => model.read(key));
      const notez = await Promise.all(keyPromises);
      for (let note of notez) {
        assert.match(note.title, /Note [123]/, "correct title");
      }
    });
  });
```

其思想是调用 notesapi 函数，然后测试结果以检查它们是否符合预期结果。

此`describe`块位于外部`describe`块内。描述和`it`块中给出的描述用于使测试报告更具可读性。`it`块沿着*的线条形成一个伪句子，它（被测试的对象）应该做这个或那个*。

It is important with Mocha to not use arrow functions in the `describe` and `it` blocks. By now, you will have grown fond of arrow functions because of how much easier they are to write. But, Mocha calls these functions with a `this` object containing useful functions for Mocha. Because arrow functions avoid setting up a `this` object, Mocha would break.

Even though Mocha requires regular functions for the `describe` and `it` blocks, we can use arrow functions within those functions.

Mocha 如何知道测试代码是否通过？它如何知道测试何时结束？这段代码显示了三种方法之一。

通常，Mocha 会查看函数是否抛出异常，或者测试用例是否需要太长时间才能执行（超时情况）。在任何一种情况下，摩卡咖啡都将表明测试失败。对于非异步代码，这当然很容易确定。但是，Node.js 完全是关于异步代码的，Mocha 有两个用于测试异步代码的模型。在第一个例子中（这里没有看到），Mocha 传入一个回调函数，测试代码是调用回调函数。在第二种情况下，如图所示，它查找测试函数返回的承诺，并确定该承诺是处于*解析*还是*拒绝*状态的通过/失败。

在本例中，我们使用`async`函数，因为它们会自动返回一个承诺。在函数中，我们使用`await,`调用异步函数，以确保任何抛出的异常都被指示为拒绝的承诺

另一个需要注意的问题是前面提出的问题：如果我们正在测试的回调函数从未被调用怎么办？或者，如果承诺从未得到解决怎么办？Mocha 启动一个计时器，如果测试用例没有在计时器到期之前完成，Mocha 会使测试用例失败。

# 配置和运行测试

我们还有更多的测试要写，但是让我们先设置运行测试。要测试的最简单模型是内存模型。让我们将此添加到`notes/test/package.json`的`scripts`部分：

```js
"test-notes-memory": "NOTES_MODEL=memory mocha test-model",
```

要安装依赖项，我们必须在`notes/test`和`notes`目录中运行`npm install`。这样，测试代码的依赖项和 Notes 的依赖项都安装在正确的位置。

然后，我们可以按如下方式运行它：

```js
$ npm run test-notes-memory

> notes-test@1.0.0 test-notes-memory /Users/david/chap11/notes/test
> NOTES_MODEL=memory mocha test-model

 Model Test
 check keylist
 √ should have three entries
 √ should have keys n1 n2 n3
 √ should have titles Node #

 3 passing (18ms)
```

`mocha`命令用于运行测试套件

输出的结构遵循`describe`和`it`块的结构。您应该设置描述性文本字符串，使其可读性良好。

# Notes 模型的更多测试

这还不足以进行大量测试，所以让我们继续添加一些测试：

```js
describe("read note", function() {
    it("should have proper note", async function() {
        const note = await model.read("n1");
        assert.exists(note);
        assert.deepEqual({ key: note.key, title: note.title, body: 
        note.body }, {
          key: "n1", title: "Note 1 FAIL", body: "Note 1"
        });
    });

    it("Unknown note should fail", async function() {
        try {
          const note = await model.read("badkey12");
          assert.notExists(note);
          throw new Error("should not get here");
        } catch(err) {
          // this is expected, so do not indicate error
          assert.notEqual(err.message, "should not get here");
        }
    });
});

describe("change note", function() {
    it("after a successful model.update", async function() {
        const newnote = await model.update("n1", "Note 1 title 
        changed", "Note 1 body changed");
        const note = await model.read("n1");
        assert.exists(note);
        assert.deepEqual({ key: note.key, title: note.title, body: 
        note.body }, {
          key: "n1", title: "Note 1 title changed", body: "Note 1 body 
        changed"
        });
    });
});

describe("destroy note", function() {
    it("should remove note", async function() {
        await model.destroy("n1");
        const keyz = await model.keylist();
        assert.exists(keyz);
        assert.isArray(keyz);
        assert.lengthOf(keyz, 2);
        for (let key of keyz) {
          assert.match(key, /n[23]/, "correct key");
        }
    });
    it("should fail to remove unknown note", async function() {
        try {
          await model.destroy("badkey12");
          throw new Error("should not get here");
        } catch(err) {
            // this is expected, so do not indicate error
            assert.notEqual(err.message, "should not get here");
        }
    });
  });

  after(function() {  model.close(); });
}); 
```

注意，对于否定测试——如果抛出错误，测试通过——我们在`try/catch`块中运行它。在每种情况下，`throw new Error`行都不应该执行，因为前面的代码应该抛出一个错误。因此，我们可以检查抛出错误中的消息是否是到达的消息，如果是这种情况，则测试失败。

现在，测试报告：

```js
$ npm run test-notes-memory

> notes-test@1.0.0 test-notes-memory /Users/david/chap11/notes/test
> NOTES_MODEL=memory mocha test-model

  Model Test
    check keylist
      √ should have three entries
      √ should have keys n1 n2 n3
      √ should have titles Node #
    read note
      √ should have proper note
      √ Unknown note should fail
    change note
      √ after a successful model.update
    destroy note
      √ should remove note
      √ should fail to remove unknown note

  8 passing (17ms) 
```

在这些附加测试中，我们有两个阴性测试。在我们预期失败的每个测试中，我们提供一个我们知道不在数据库中的`notekey`，然后我们确保模型给我们一个错误。

Chai 断言 API 包括一些非常有表现力的断言。在本例中，我们使用了`deepEqual`方法对两个对象进行了深入比较。在我们的例子中，它看起来是这样的：

```js
assert.deepEqual({ key: note.key, title: note.title, body: note.body }, {
   key: "n1", title: "Note 1", body: "Note 1"
 });
```

这在测试代码中读起来很好，但更重要的是，报告的测试失败看起来很好。由于这些字符串当前正在传递，请尝试通过更改其中一个期望值字符串来引入错误。重新运行测试后，您将看到：

```js
 Model Test 
 check keylist 
 √ should have three entries 
 √ should have keys n1 n2 n3 
 √ should have titles Node # 
 read note 
 1) should have proper note 
 √ Unknown note should fail 
 change note 
 √ after a successful model.update 
 destroy note 
 √ should remove note 
 √ should fail to remove unknown note 

 7 passing (42ms) 
 1 failing 

 1) Model Test 
 read note 
 should have proper note: 
 AssertionError: expected { Object (key, title, ...) } to deeply 
 equal { Object (key, title, ...) } 
 + expected - actual 

 { 
 "body": "Note 1" 
 "key": "n1" 
 -  "title": "Note 1" 
 +  "title": "Note 1 FAIL" 
 } 

 at Context.<anonymous> (test-model.js:53:16) 
 at <anonymous> 

```

顶部是每个测试用例的状态报告。对于一个测试，不是复选标记而是一个数字，该数字对应于底部报告的详细信息。当使用`spec`报告器时，Mocha 以这种方式表示测试失败。Mocha 支持其他测试报告格式，其中一些生成的数据可以发送到测试状态报告系统。更多信息请参见[https://mochajs.org/#reporters](https://mochajs.org/#reporters) 。

在这种情况下，故障是通过`deepEqual`方法检测到的，该方法以这种方式表示检测对象的不平等性。

# 测试数据库模型

这很好，但我们显然不会在生产中使用内存中的 Notes 模型运行 Notes。这意味着我们需要测试所有其他模型

测试 LevelUP 和文件系统模型很容易，只需将其添加到`package.json`的脚本部分：

```js
"test-notes-levelup": "NOTES_MODEL=levelup mocha",
"test-notes-fs": "NOTES_MODEL=fs mocha", 
```

然后运行以下命令：

```js
$ npm run test-notes-fs 
$ npm run test-notes-levelup 
```

这将产生一个成功的测试结果。

要测试的最简单的数据库是 SQLite3，因为它需要零设置。我们有两个 SQLite3 模型要测试，让我们从`notes-sqlite3.js`开始。将以下内容添加到`package.json`的脚本部分：

```js
"test-notes-sqlite3": "rm -f chap11.sqlite3 && sqlite3 chap11.sqlite3 --init ../models/chap07.sql </dev/null && NOTES_MODEL=sqlite3 SQLITE_FILE=chap11.sqlite3 mocha test-model", 
```

此命令序列将测试数据库放入`chap11.sqlite3`文件中。它首先使用`sqlite3`命令行工具初始化该数据库。注意，我们已经将其输入连接到了`/dev/null`，因为`sqlite3`命令将提示输入，否则。然后，它运行测试套件，传入针对 SQLite3 模型运行所需的环境变量。

运行测试套件会发现两个错误：

```js
$ npm run test-notes-sqlite3 

> notes-test@1.0.0 test-notes-sqlite3 /Users/david/chap11/notes/test 
> rm -f chap11.sqlite3 && sqlite3 chap11.sqlite3 --init ../models/chap07.sql </dev/null && NOTES_MODEL=sqlite3 SQLITE_FILE=chap11.sqlite3 mocha test-model 

  Model Test 
    check keylist 
      √ should have three entries 
      √ should have keys n1 n2 n3 
      √ should have titles Node # 
    read note 
      √ should have proper note 
      1) Unknown note should fail 
    change note 
      √ after a successful model.update (114ms) 
    destroy note 
      √ should remove note (103ms) 
      2) should fail to remove unknown note 

  6 passing (6s) 
  2 failing 

  1) Model Test 
       read note 
         Unknown note should fail: 
     Uncaught TypeError: Cannot read property 'notekey' of undefined 
      at Statement.db.get (/home/david/nodewebdev/node-web-development-
  code-4th-edition/chap11/notes/models/notes-sqlite3.mjs:64:39)                               

  2) Model Test 
       destroy note 
         should fail to remove unknown note: 

      AssertionError: expected 'should not get here' to not equal 
  'should not get here' 
      + expected - actual 
```

失败的测试调用了`model.read("badkey12")`，一个我们知道不存在的`key`。写否定测试是有回报的。`models/notes-sqlite3.mjs`处的失败代码行（第 64 行）如下所示：

```js
const note = new Note(row.notekey, row.title, row.body);
```

在这之前插入`console.log(util.inspect(row));`并了解到，对于失败的调用，SQLite3 为`row`提供了`undefined`，解释了错误消息。

测试套件使用确实存在的`notekey`值多次调用`read`函数。显然，当给定一个无效的`notekey`值时，查询将给出一个空的结果集，SQLite3 使用`undefined`错误和`undefined`行值调用回调。这是数据库模块的常见行为。空结果集不是错误，因此我们没有收到错误和未定义的`row`。

事实上，我们在前面的`models/notes-sequelize.mjs`中看到了这种行为。`models/notes-sequelize.mjs`中的等价代码做了正确的事情，并且它有一个检查，我们可以进行调整。让我们将`models/notes-sqlite.mjs`中的`read`函数重写为：

```js
export async function read(key) {
  var db = await connectDB();
  var note = await new Promise((resolve, reject) => {
    db.get("SELECT * FROM notes WHERE notekey = ?", [ key ], (err, row) 
    => {
        if (err) return reject(err);
        if (!row) { reject(new Error(`No note found for ${key}`)); } 
        else {
            const note = new Note(row.notekey, row.title, row.body);
            resolve(note);
        }
    });
  });
  return note;
}
```

这很简单，我们只需检查`row`是否为`undefined`，如果是，则抛出一个错误。虽然数据库不会将空结果集视为错误，但 Notes 会将其视为错误。此外，Notes 已经知道如何处理本例中抛出的错误。进行此更改，特定测试用例就会通过

`destroy`逻辑中还有第二个类似错误。销毁不存在的便笺的测试无法在此行生成错误：

```js
await model.destroy("badkey12");
```

如果我们检查其他模型，它们会为不存在的密钥抛出错误。在 SQL 中，如果此 SQL（从`models/notes-sqlite3.mjs`开始）没有删除任何内容，则显然不是错误：

```js
db.run("DELETE FROM notes WHERE notekey = ?;", ... );
```

不幸的是，如果此 SQL 语句不删除任何记录，则没有使其失败的 SQL 选项。因此，我们必须添加一个检查来查看记录是否存在。即：

```js
export async function destroy(key) {
    const db = await connectDB();
    const note = await read(key);
    return await new Promise((resolve, reject) => {
        db.run("DELETE FROM notes WHERE notekey = ?;", [ key ], err => 
       {
            if (err) return reject(err);
            resolve();
        });
    });
}
```

因此，我们阅读了注释，并作为副产品验证了注释的存在。如果该便笺不存在，`read`将抛出错误，`DELETE`操作甚至不会运行。

这些就是我们在[第 7 章](07.html)、*数据存储和检索*中提到的 bug。我们只是忘记了在这个特定的模型中检查这些条件。谢天谢地，我们勤奋的测试解决了这个问题。至少，这是告诉经理们的故事，而不是告诉他们我们忘记检查我们已经知道可能发生的事情。

既然我们已经修复了`models/notes-sqlite3.mjs`，那么让我们也使用 SQLite3 数据库测试`models/notes-sequelize.mjs`。为此，我们需要在`SEQUELIZE_CONNECT`变量中指定一个连接对象。虽然我们可以重用现有的，但让我们创建一个新的。创建一个名为`test/sequelize-sqlite.yaml`的文件，其中包含：

```js
dbname: notestest 
username: 
password: 
params: 
    dialect: sqlite 
    storage: notestest-sequelize.sqlite3 
    logging: false 
```

这样，我们就不会用测试套件覆盖生产数据库实例。因为测试套件会破坏它测试的数据库，所以它必须针对我们正在破坏的数据库运行。记录参数关闭`Sequelize`产生的大量输出，以便我们可以读取测试结果报告。

将以下内容添加到`package.json`的脚本部分：

```js
"test-notes-sequelize-sqlite": "NOTES_MODEL=sequelize SEQUELIZE_CONNECT=sequelize-sqlite.yaml mocha test-model" 
```

然后运行测试套件：

```js
$ npm run test-notes-sequelize-sqlite 
.. 
 8 passing (2s) 
```

我们飞驰而过！我们已经能够针对多个 Notes 模型利用相同的测试套件。我们甚至在一个模型中发现了两个 bug。但是，我们还有两个测试配置需要测试。

我们的测试结果矩阵如下：

*   `models-fs`：通过
*   `models-memory`：通过
*   `models-levelup`：通过
*   `models-sqlite3`：2 次故障，现已修复
*   `models-sequelize`：带 SQLite3:通过
*   `models-sequelize`：使用 MySQL：未测试
*   `models-mongodb`：未经测试

这两个未经测试的模型都需要设置数据库服务器。我们避免了测试这些组合，但我们的经理不会接受这个借口，因为首席执行官需要知道我们已经完成了测试周期。必须在与生产环境类似的配置中测试 Notes。

在生产中，我们将使用常规数据库服务器，当然，MySQL 或 MongoDB 是主要选择。因此，我们需要一种低开销的方法来对这些数据库运行测试。针对生产配置的测试必须非常容易，这样做时我们就不会感到阻力，以确保测试的运行频率足以产生预期的影响。

幸运的是，我们已经拥有了一种支持轻松创建和销毁部署基础设施的技术的经验。你好，Docker！

# 使用 Docker 管理测试基础架构

Docker 的一个优势是能够在笔记本电脑上安装生产环境。然后，将相同的 Docker 设置推送到云托管环境以进行登台或生产部署非常容易

在本节中，我们将演示如何重用前面为测试基础架构定义的 Docker Compose 配置，并使用 shell 脚本在容器中自动执行 Notes 测试套件。一般来说，在运行测试时复制生产环境是很重要的。Docker 可以让这件事变得简单。

使用 Docker，我们将能够轻松地对数据库进行测试，并有一个简单的方法来启动和停止生产环境的测试版本。

# Docker Compose 协调测试基础架构

我们在使用 Docker Compose 协调 Notes 应用程序部署方面有着丰富的经验。整个系统有四个独立的服务，在`compose/docker-compose.yml`中很容易描述。我们要做的是复制 Compose 文件，然后做一些支持测试执行所需的小更改。

让我们首先创建一个新目录`test-compose`，作为`notes`、`users`和`compose`目录的同级目录。将`compose/docker-compose.yml`复制到新创建的`test-compose`目录中。我们将对此文件进行一些更改，并对现有 DockerFile 进行一些小更改。

我们希望更改容器和网络名称，以便我们的测试基础设施不会影响生产基础设施。我们将不断删除和重新创建测试容器，以便让开发人员满意，我们将不使用开发基础设施，而是在单独的基础设施上执行测试。通过维护独立的测试容器和网络，我们的测试脚本可以在不干扰开发或生产容器的情况下做任何事情。

把这个变化考虑到：

```js
db-userauth-test:
  build: ../authnet
  container_name: db-userauth-test
  networks:
    - authnet-test
  environment:
    MYSQL_RANDOM_ROOT_PASSWORD: "true"
    MYSQL_USER: userauth-test
    MYSQL_PASSWORD: userauth-test
    MYSQL_DATABASE: userauth-test
  volumes:
    - db-userauth-test-data:/var/lib/mysql
  restart: always
.. 
db-notes-test:
  build: ../frontnet
  container_name: db-notes-test
  networks:
    - frontnet-test
  environment:
    MYSQL_RANDOM_ROOT_PASSWORD: "true"
    MYSQL_USER: notes-test
    MYSQL_PASSWORD: notes12345
    MYSQL_DATABASE: notes-test
  volumes:
    - db-notes-test-data:/var/lib/mysql
  restart: always
```

这与前面的相同，但在容器和网络名称后面附加了`-test`。

这是我们必须做的第一个更改，在`test-compose/docker-compose.yml`中的每个容器和网络名称后面附加`-test`。我们对测试所做的一切都将在与开发实例完全不同的容器、主机名和网络上运行。

此更改将影响`notes-test`和`userauth-test`服务，因为数据库服务器主机名现在是`db-auth-test`和`db-notest-test`。有几个环境变量或配置文件需要更新。

另一个考虑因素是配置服务所需的环境变量，我们在 DockerFile 中定义了所有环境变量。重用这些 DockerFile 非常有用，因此我们知道我们正在测试生产中使用的相同部署。但我们需要调整配置设置以匹配测试基础结构。

这里显示的数据库配置就是一个示例。使用相同的 DockerFile，但我们也在`test-compose/docker-compose.yml`中定义了环境变量。如您所料，这将使用此处设置的值覆盖 Dockerfile 环境变量：

```js
userauth-test:
  build: ../users
  container_name: userauth-test
  depends_on:
    - db-userauth-test
  networks:
    - authnet-test
    - frontnet-test
  environment:
    DEBUG: ""
    NODE_ENV: "test"
    SEQUELIZE_CONNECT: "sequelize-docker-test-mysql.yaml"
    HOST_USERS_TEST: "localhost"
  restart: always
  volumes:
    - ./reports-userauth:/reports
.. 
notes-test:
  build: ../notes
  container_name: notes-test
  depends_on:
    - db-notes-test
  networks:
    - frontnet-test
  ports:
    - "3000:3000"
  restart: always
  environment:
    NODE_ENV: "test"
    SEQUELIZE_CONNECT: "test/sequelize-mysql.yaml"
    USER_SERVICE_URL: "http://userauth-test:3333"
  volumes:
    - ./reports-notes:/reports
...
networks:
  frontnet-test:
    driver: bridge
  authnet-test:
    driver: bridge

volumes: 
  db-userauth-test-data: 
  db-notes-test-data: 
```

再次，我们将容器和网络名称更改为追加`-test`。我们将一些环境变量从 Dockerfile 移到了`test-compose/docker-compose.yml`。最后，我们添加了一些数据卷来装载容器中的主机目录。

另一件事是设置目录来存储测试代码。Node.js 项目中的一种常见做法是将测试代码与应用程序代码放在同一目录中。在本章前面，我们这样做了，在`notes/test`目录中实现了一个小测试套件。目前，`notes/Dockerfile`没有将该目录复制到容器中。测试代码必须存在于容器中才能执行测试。另一个问题是，不在生产环境中部署测试代码是有帮助的。

我们所能做的是确保`test-compose/docker-compose.yml`将`notes/test`装入容器中：

```js
notes-test:
  ...
  volumes:
    - ./reports-notes:/reports
    - ../notes/test:/notesapp/test
```

这给了我们两全其美的东西。

*   测试代码在它所属的`notes/test`中
*   测试代码不会复制到生产容器中
*   在测试模式下，`test`目录出现在它所属的位置

我们还有几个配置文件要设置`Sequelize`数据库连接。

对于`userauth-test`容器，`SEQUELIZE_CONNECT`变量现在指的是一个不存在的配置文件，这要感谢在`user/Dockerfile`中重写了该变量。让我们将该文件创建为`test-compose/userauth/sequelize-docker-mysql.yaml`，包含以下内容：

```js
dbname: userauth-test
username: userauth-test
password: userauth-test
params:
    host: db-userauth-test
    port: 3306
    dialect: mysql
```

这些值与传递到`db-userauth-test`容器的变量相匹配。然后我们必须确保将此配置文件装载到`userauth-test`容器中：

```js
userauth-test:
  ...
  volumes:
    - ./reports-userauth:/reports
    - ./userauth/sequelize-docker-test-mysql.yaml:/userauth/sequelize-
  docker-test-mysql.yaml
```

对于`notes-test`我们有一个配置文件`test/sequelize-mysql.yaml`放在`notes/test`目录中：

```js
dbname: notes-test 
username: notes-test
password: notes12345
params: 
    host: db-notes-test
    port: 3306 
    dialect: mysql 
    logging: false 
```

同样，这与`db-notes-test`中的配置变量相匹配。在`test-compose/docker-compose.yml`中，我们将该文件装载到容器中。

# 在 Docker Compose 下执行测试

现在我们准备在容器中执行一些测试。我们使用 Docker Compose 文件来描述 Notes 应用程序的测试环境，使用与生产环境相同的体系结构。测试脚本和配置已经注入到容器中。问题是，我们如何自动化测试执行？

我们将使用的技术是运行 shell 脚本，并使用`docker exec -it`执行命令来运行测试脚本。这在某种程度上是自动化的，通过更多的工作，它可以完全自动化。

在`test-compose`中，让我们制作一个名为`run.sh`的 shell 脚本（在 Windows 上，`run.ps1`：

```js
docker-compose stop

docker-compose build
docker-compose up --force-recreate -d
docker ps
docker network ls

sleep 20
docker exec -it --workdir /notesapp/test -e DEBUG= notes-test npm install

docker exec -it --workdir /notesapp/test -e DEBUG= notes-test npm run test-notes-memory
docker exec -it --workdir /notesapp/test -e DEBUG= notes-test npm run test-notes-fs
docker exec -it --workdir /notesapp/test -e DEBUG= notes-test npm run test-notes-levelup
docker exec -it --workdir /notesapp/test -e DEBUG= notes-test npm run test-notes-sqlite3
docker exec -it --workdir /notesapp/test -e DEBUG= notes-test npm run test-notes-sequelize-sqlite
docker exec -it --workdir /notesapp/test -e DEBUG= notes-test npm run test-notes-sequelize-mysql

docker-compose stop 
```

It's common practice to run tests out of a continuous integration system such as Jenkins. Continuous integration systems automatically run builds or tests against software products. The build and test results data is used to automatically generate status pages.  Visit [https://jenkins.io/index.html](https://jenkins.io/index.html), which is a good starting point for a Jenkins job.

这是构建容器的第一个真正步骤，然后再将其提出来。脚本休眠几秒钟，让容器有时间完全实例化它们自己。

随后的命令都遵循一种特定的模式，这一模式需要理解。由于有了`--workdir`选项，这些命令在`/notesapp/test`目录中执行。请记住，目录是由 Docker Compose 文件注入容器的。

使用`-e DEBUG=`我们已禁用`DEBUG`选项。如果设置了这些选项，测试结果中会有多余的不需要的输出，因此使用此选项可以确保不会出现调试输出

现在您已经了解了这些选项，您可以看到后续的命令都是在`test`目录中使用该目录中的`package.json`执行的。首先运行`npm install`，然后运行测试矩阵中的每个场景。

要运行测试，只需键入：

```js
$ sh -x run.sh 
```

这很好，我们已经将大部分测试矩阵自动化，并进行了很好的处理。测试矩阵中有一个明显的漏洞，堵住这个漏洞让我们看看如何在 Docker 下设置 MongoDB。

# Docker 下的 MongoDB 设置和 MongoDB 测试说明

在[第 7 章](07.html)、*数据存储和检索*中，我们开发了 MongoDB 对 Notes 的支持，从那时起我们就专注于`Sequelize`。为了弥补这一不足，让我们确保至少测试我们的 MongoDB 支持。在 MongoDB 上测试只需要为 MongoDB 数据库定义一个容器和一点配置。

访问[https://hub.docker.com/_/mongo/](https://hub.docker.com/_/mongo/) 用于官方 MongoDB 容器。您可以对其进行改装，以允许部署运行在 MongoDB 上的 Notes 应用程序。

将此添加到`test-compose/docker-compose.yml`：

```js
db-notes-mongo-test:
  image: mongo:3.6-jessie
  container_name: db-notes-mongo-test
  networks:
    - frontnet-test
  volumes:
    - ./db-notes-mongo:/data/db
```

这就是将 MongoDB 容器添加到 Docker Compose 文件所需的全部内容。我们已将其连接到`frontnet`，以便`notes`（`notes-test`容器可以访问该服务。

然后在`notes/test/package.json`中，我们添加了一行，以便于在 MongoDB 上运行测试：

```js
"test-notes-mongodb": "MONGO_URL=mongodb://db-notes-mongo-test/ MONGO_DBNAME=chap11-test NOTES_MODEL=mongodb mocha --no-timeouts test-model"
```

只需将 MongoDB 容器添加到`frontnet-test`中，数据库就可以在此处显示的 URL 处使用。因此，现在使用 Notes MongoDB 模型运行测试套件很简单

在针对 MongoDB 测试套件时，`--no-timeouts`选项是必要的，以避免出现虚假错误。此选项指示 Mocha 不要检查测试用例执行是否花费太长时间。

最终要求在`run.sh`（或`run.ps1`窗口中增加此行）：

```js
docker exec -it --workdir /notesapp/test -e DEBUG= notes-test npm run test-notes-mongodb
```

这样就确保了 MongoDB 在每次测试运行期间都得到测试

我们现在可以向经理报告最终测试结果矩阵：

*   `models-fs`：通过
*   `models-memory`：通过
*   `models-levelup`：通过
*   `models-sqlite3`：两次失败，现已修复，通过
*   `models-sequelize`带 SQLite3：通过
*   `models-sequelize`使用 MySQL：通过
*   `models-mongodb`：通过

经理会告诉您“干得好”，然后记住模型只是 Notes 应用程序的一部分。我们留下了两个完全未经测试的领域：

*   用户身份验证服务的 RESTAPI
*   用户界面的功能测试

让我们继续进行这些测试区域

# 测试 REST 后端服务

现在是时候将注意力转向用户身份验证服务了。我们已经提到了这项服务的测试，并说我们稍后会进行测试。我们已经为特别测试开发了一些脚本，这些脚本一直都很有用。但现在是晚些时候了，是时候开始进行一些真正的测试了。

有一个问题是使用哪种工具来测试身份验证服务。Mocha 在组织一系列测试用例方面做得很好，我们应该在这里重用它。但我们必须测试的是 REST 服务。该服务的客户 Notes 应用程序通过 REST API 使用它，这给了我们在 REST 接口进行测试的完美合理化。我们的特别脚本使用 SuperAgent 库简化了 REST API 调用。碰巧有一个配套库 SuperTest，用于 RESTAPI 测试。请在此处阅读其文档：[https://www.npmjs.com/package/supertest](https://www.npmjs.com/package/supertest) 。

我们已经建立了`test-compose/userauth`目录。在该目录中，创建一个名为`test.js`的文件：

```js
'use strict';

const assert = require('chai').assert;
const request = require('supertest')(process.env.URL_USERS_TEST);
const util = require('util');
const url = require('url');
const URL = url.URL;

const authUser = 'them';
const authKey = 'D4ED43C0-8BD6-4FE2-B358-7C0E230D11EF';

describe("Users Test", function() {
    ... Test code follows
});
```

这将设置 Mocha 和 SuperTest 客户端。`URL_USERS_TEST`环境变量指定要运行测试的服务器的基本 URL。考虑到我们在本书前面使用的配置，您几乎肯定会使用`http://localhost:3333`。SuperTest 的初始化方式与 SuperAgent 略有不同。SuperTest 模块公开了一个我们使用`URL_USERS_TEST`环境变量调用的函数，然后我们在脚本的其余部分使用该`request`对象来发出 rest API 请求。

此变量已在`test-compose/docker-compose.yml`中设置为所需值。另一件重要的事情是存储身份验证用户 ID 和密钥的一对变量：

```js
beforeEach(async function() {
  await request.post('/create-user')
       .send({ 
          username: "me", password: "w0rd", provider: "local",
          familyName: "Einarrsdottir", givenName: "Ashildr", 
          middleName: "",
          emails: [], photos: []
        })
        .set('Content-Type', 'application/json')
        .set('Acccept', 'application/json')
        .auth(authUser, authKey);
});

afterEach(async function() {
  await request.delete('/destroy/me')
        .set('Content-Type', 'application/json')
        .set('Acccept', 'application/json')
        .auth(authUser, authKey);
}); 
```

如果您还记得，`beforeEach`函数在每个测试用例之前立即运行，`afterEach`在之后运行。这些函数在运行测试之前使用 RESTAPI 创建测试用户，然后在运行测试之后销毁测试用户。这样，我们的测试可以假设该用户将存在：

```js
describe("List user", function() {
   it("list created users", async function() {
     const res = await request.get('/list')
          .set('Content-Type', 'application/json')
          .set('Acccept', 'application/json')
          .auth(authUser, authKey);
    assert.exists(res.body);
    assert.isArray(res.body);
    assert.lengthOf(res.body, 1);
    assert.deepEqual(res.body[0], { 
          username: "me", id: "me", provider: "local",
          familyName: "Einarrsdottir", givenName: "Ashildr", 
          middleName: "",
          emails: [], photos: []
    });
  });
});
```

现在，我们可以开始测试一些 API 方法，比如`/list`操作。

我们已经保证在`beforeEach`方法中有账户，所以`/list`应该给我们一个有一个条目的数组。

这遵循使用 Mocha 测试 RESTAPI 方法的一般模式。首先，我们使用 SuperTest 的`request`对象调用 API 方法，`await`调用其结果。一旦我们得到结果，我们使用`assert`方法验证它是否符合预期：

```js
describe("find user", function() {
  it("find created users", async function() {
    const res = await request.get('/find/me')
            .set('Content-Type', 'application/json')
            .set('Acccept', 'application/json')
            .auth(authUser, authKey);
    assert.exists(res.body);
    assert.isObject(res.body);
    assert.deepEqual(res.body, { 
            username: "me", id: "me", provider: "local",
            familyName: "Einarrsdottir", givenName: "Ashildr", 
            middleName: "",
            emails: [], photos: []
    });
});
it("fail to find non-existent users", async function() {
    var res;
    try {
      res = await request.get('/find/nonExistentUser')
            .set('Content-Type', 'application/json')
            .set('Acccept', 'application/json')
            .auth(authUser, authKey);
    } catch(e) {
      return; // Test is okay in this case
    }
    assert.exists(res.body);
    assert.isObject(res.body);
    assert.deepEqual(res.body, {});
  });
});    
```

我们通过两种方式检查`/find`操作：

*   查找我们知道存在的帐户–如果未找到用户帐户，则指示失败
*   查找我们知道不存在的对象–如果我们接收到错误或空对象以外的内容，则指示失败

添加此测试用例：

```js
describe("delete user", function() {
  it("delete nonexistent users", async function() {
    var res;
    try {
      res = await request.delete('/destroy/nonExistentUser')
              .set('Content-Type', 'application/json')
              .set('Acccept', 'application/json')
              .auth(authUser, authKey);
    } catch(e) {
      return; // Test is okay in this case
    }
    assert.exists(res);
    assert.exists(res.error);
    assert.notEqual(res.status, 200);
  });
}); 
```

最后，我们应该检查`/destroy`操作。我们已经在`afterEach`方法中检查了这个操作，在这里我们`destroy`使用了一个已知的用户帐户。我们还需要执行否定测试，并根据我们知道不存在的帐户验证其行为。

期望的行为是抛出错误，或者结果显示指示错误的 HTTP`status`。事实上，当前的身份验证服务器代码提供了一个 500 状态代码以及一些其他信息。

在`test-compose/docker-compose.yml`中，我们需要将这个脚本`test.js`注入`userauth-test`容器中。我们将在此处添加：

```js
userauth-test:
  ...
  volumes:
    - ./reports-userauth:/reports
    - ./userauth/sequelize-docker-test-mysql.yaml:/userauth/sequelize-docker-test-mysql.yaml
    - ./userauth/test.js:/userauth/test.js
```

我们有一个测试脚本，并且已经将该脚本注入到所需的容器中（`userauth-test`。下一步是自动运行此测试。一种方法是将其添加到`run.sh`（即 Windows 上的`run.ps1`：

```js
docker exec -it -e DEBUG= userauth-test npm install supertest mocha chai
docker exec -it -e DEBUG= userauth-test ./node_modules/.bin/mocha test.js
```

现在，如果您运行`run.sh`测试脚本，您将看到安装了所需的包，然后执行此测试套件。

# 自动化测试结果报告

很酷，我们有自动测试执行，Mocha 通过所有这些复选标记使测试结果看起来很好。如果管理层想要一个测试失败趋势随时间变化的图表，或者有很多理由将测试结果报告为数据，而不是控制台上用户友好的打印输出，该怎么办。

摩卡使用所谓的记者来报告测试结果。Mocha Reporter 是以其支持的任何格式打印数据的模块。有关信息，请访问摩卡网站：[https://mochajs.org/#reporters](https://mochajs.org/#reporters) 。

您会发现当前可用的`reporters`列表如下：

```js
# mocha --reporters

 dot - dot matrix
 doc - html documentation
 spec - hierarchical spec list
 json - single json object
 progress - progress bar
 list - spec-style listing
 tap - test-anything-protocol
...
```

然后你用一个特定的`reporter`像这样：

```js
# mocha --reporter tap test
1..4
ok 1 Users Test List user list created users
ok 2 Users Test find user find created users
ok 3 Users Test find user fail to find non-existent users
ok 4 Users Test delete user delete nonexistent users
# tests 4
# pass 4
# fail 0
```

**测试任何东西协议**（**TAP**）是一种广泛使用的测试结果格式，增加了寻找更高级别报告工具的可能性。显然，下一步是在将主机目录装入容器后，将结果保存到某个文件中。

# 使用 Puppeter 进行前端无头浏览器测试

测试中的一大成本领域是手动用户界面测试。因此，已经开发了各种各样的工具来自动运行 HTTP 级别的测试。例如，Selenium 是一个用 Java 实现的流行工具。在 Node.js 世界中，我们有几个有趣的选择。chai 的*chai http*插件允许我们在 http 级别与 Notes 应用程序交互，同时保持在现在熟悉的 chai 环境中

然而，在本节中，我们将使用木偶演员（[https://github.com/GoogleChrome/puppeteer](https://github.com/GoogleChrome/puppeteer) ）。此工具是一个高级 Node.js 模块，用于使用 DevTools 协议控制无头 Chrome 或 Chrome 浏览器。该协议允许工具对 Chrome 或 Chrome 进行检测、检查、调试和配置

Puppeter 是一种通用测试自动化工具，具有强大的功能集。因为用 Puppeter 制作网页截图很容易，所以它也可以用于截图服务。

因为 Puppeter 正在控制一个真正的 web 浏览器，所以您的用户界面测试将非常接近于实时浏览器测试，而无需雇佣一个人来完成这项工作。因为它使用的是 Chrome 的无头版本，所以屏幕上不会显示任何可见的浏览器窗口，测试可以在后台运行。这个吸引人的故事的一个缺点是，木偶演员只对 Chrome 起作用。这意味着针对 Chrome 的自动测试不会针对其他浏览器（如 Opera 或 Firefox）测试您的应用程序

# 布偶

让我们首先设置目录并安装软件包：

```js
$ mkdir test-compose/notesui
$ cd test-compose/notesui
$ npm init
... answer the questions
$ npm install puppeteer@1.1.x mocha@5.x chai@4.1.x --save
```

在安装过程中，您将看到 Puppeter 导致 Chromium 的下载，如下所示：

```js
Downloading Chromium r497674 - 92.5 Mb [====================] 100% 0.0s 
```

`puppeteer`模块将根据需要启动 Chromium 实例，将其作为后台进程进行管理，并使用 DevTools 协议与之通信。

在我们即将编写的脚本中，我们需要一个用户帐户，可以用来登录和执行一些操作。幸运的是，我们已经有了一个脚本来设置测试帐户。在`users/package.json`中，将此行添加到脚本部分：

```js
"setupuser": "PORT=3333 node users-add", 
```

我们即将编写此测试脚本，但让我们完成设置，最后一点是将这些行添加到`run.sh`：

```js
docker exec -it userauth-test npm run setupuser 
docker exec -it notesapp-test npm run test-docker-ui 
```

执行时，这两行确保设置了测试用户，然后运行用户界面测试。

# 改进 Notes UI 中的可测试性

当 Notes 应用程序在浏览器中显示良好时，我们如何编写测试软件来区分一个页面和另一个页面？关键要求是测试脚本检查页面，确定显示的页面，并读取页面上的数据。这意味着每个 HTML 元素必须使用 CSS 选择器轻松寻址

在开发 Notes 应用程序时，我们忘记了这样做，**软件质量工程**（**SQE**经理请求我们的帮助。这关系到测试预算，SQE 团队自动化测试的程度越高，测试预算就越大。

需要做的就是为 HTML 元素添加一些`id`或`class`属性，以提高可测试性。有了一些标识符，并承诺维护这些标识符，SQE 团队就可以编写可重复的测试脚本来验证应用程序。

在`notes/partials/header.hbs`中，更改以下行：

```js
...
<a id="btnGoHome" class="navbar-brand" href='/'>
...
{{#if user}}
...
<a class="nav-item nav-link btn btn-dark col-auto" id="btnLogout" href="/users/logout">...</a>
<a class="nav-item nav-link btn btn-dark col-auto" id="btnAddNote" href='/notes/add'>...</a>
{{else}}
...
<a class="nav-item nav-link btn btn-dark col-auto" id="btnloginlocal" href="/users/login">..</a>
<a class="nav-item nav-link btn btn-dark col-auto" 
                        id="btnLoginTwitter" href="/users/auth/twitter">...</a>
...
{{/if}}
...
```

在`notes/views/index.hbs`中，进行以下更改：

```js
<div id="notesHomePage" class="container-fluid">
  <div class="row">
    <div id="notetitles" class="col-12 btn-group-vertical" role="group">
      {{#each notelist}}
      <a id="{{key}}" class="btn btn-lg btn-block btn-outline-dark" 
          href="/notes/view?key={{ key }}">...</a>
      {{/each}}
    </div>
  </div>
</div>
```

在`notes/views/login.hbs`中，进行以下更改：

```js
<div id="notesLoginPage" class="container-fluid">
...
<form id="notesLoginForm" method='POST' action='/users/login'> 
...
<button type="submit" id="formLoginBtn" class="btn btn-default">Submit</button> 
</form>
...
</div>
```

在`notes/views/notedestroy.hbs`中，进行以下更改：

```js
<form id="formDestroyNote" method='POST' action='/notes/destroy/confirm'>
...
<button id="btnConfirmDeleteNote" type="submit" value='DELETE' 
                class="btn btn-outline-dark">DELETE</button>
...
</form>
```

在`notes/views/noteedit.hbs`中，进行以下更改：

```js
<form id="formAddEditNote" method='POST' action='/notes/save'>
...
<button id='btnSave' type="submit" class="btn btn-default">Submit</button>
...
</form>
```

在`notes/views/noteview.hbs`中，进行以下更改：

```js
<div id="noteView" class="container-fluid">
...
<p id="showKey">Key: {{ notekey }}</p>
...
<a id="btnDestroyNote" class="btn btn-outline-dark" 
     href="/notes/destroy?key={{notekey}}" role="button"> ...  </a>
<a id="btnEditNote" class="btn btn-outline-dark" 
     href="/notes/edit?key={{notekey}}" role="button"> ... </a>
<button id="btnComment" type="button" class="btn btn-outline-dark" 
     data-toggle="modal" data-target="#notes-comment-modal"> ... </button> 
...
</div>
```

我们所做的是向模板中选定的元素添加`id=`属性。我们现在可以很容易地编写 CSS 选择器来处理任何元素。工程团队也可以开始在 UI 代码中使用这些选择器。

# 木偶演员笔记测试脚本

在`test-compose/notesui`中，创建一个名为`uitest.js`的文件，其中包含以下内容：

```js
const puppeteer = require('puppeteer');
const assert = require('chai').assert;
const util = require('util');
const { URL } = require('url');

describe('Notes', function() {
    this.timeout(10000);
    let browser;
    let page;

    before(async function() {
        browser = await puppeteer.launch({ slomo: 500 });
        page = await browser.newPage();
        await page.goto(process.env.NOTES_HOME_URL);
    });

    after(async function() {
        await page.close();
        await browser.close();
    });
});
```

这是摩卡测试套件的开始。在`before`函数中，我们通过启动一个 Puppeter 实例，启动一个新页面对象，并告诉该页面转到 Notes 应用程序主页来设置 Puppeter。使用命名的环境变量传入该 URL。

首先考虑一下我们可能希望通过 Notes 应用程序验证的场景是很有用的：

*   登录 Notes 应用程序
*   在应用程序中添加注释
*   查看添加的注释
*   删除添加的注释
*   注销
*   等等

以下是登录场景的实现代码：

```js
describe('Login', function() {
    before(async function() { ... });
    it('should click on login button', async function() {
        const btnLogin = await page.waitForSelector('#btnloginlocal');
        await btnLogin.click();
    });
    it('should fill in login form', async function() {
        const loginForm = await page.waitForSelector('#notesLoginPage 
        #notesLoginForm');
        await page.type('#notesLoginForm #username', "me");
        await page.type('#notesLoginForm #password', "w0rd");
        await page.click('#formLoginBtn');
    });
    it('should return to home page', async function() {
        const home = await page.waitForSelector('#notesHomePage');
        const btnLogout = await page.waitForSelector('#btnLogout');
        const btnAddNote = await page.$('#btnAddNote');
        assert.exists(btnAddNote);
    });
    after(async function() { ... });
});
```

此测试序列处理登录场景。它向您展示了一些 Puppeter API 方法。完整 API 的文档位于[https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md](https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md) 。页面对象将浏览器选项卡的等效项封装在 Chrome/Chrome 中。

`waitForSelector`函数按照它所说的去做——它等待与 CSS 选择器匹配的 HTML 元素出现，并等待一个或多个页面刷新。此函数有多种变体，允许等待多种情况。此函数返回一个承诺，因此值得我们在测试代码中使用异步函数。承诺将解析为一个`ElementHandle`，它是一个 HTML 元素的包装器，或者抛出一个异常，这将方便地使测试失败。

命名元素`#btnloginlocal`位于`partials/header.hbs`中，仅当用户未登录时才会显示。因此，我们将确定浏览器当前正在显示 Notes 页面，并且未登录。

`click`方法按照它的建议执行，并在引用的 HTML 元素上单击鼠标按钮。如果您想要模拟 tap，例如移动设备，那么有一种`tap`方法可用于此目的。

测试序列的下一阶段将从该单击中拾取。浏览器应已转到登录页面，因此此 CSS 选择器应变为有效：`#notesLoginPage #notesLoginForm`。接下来我们要做的是在相应的表单元素中键入测试用户 ID 和密码的文本，然后单击登录按钮。

下一个测试阶段从那里开始，浏览器应该位于主页上，由这个 CSS 选择器决定：`#notesHomePage`。如果我们成功登录，页面应该有注销（`#btnLogout`和添加注释按钮（`#btnAddNote`

在本例中，我们使用了一个不同的函数`$`来检查添加注释按钮是否存在。与`wait`函数不同，`$`只需在不等待的情况下查询当前页面。如果命名的 CSS 选择器不在当前页面中，它只返回`null`，而不是抛出异常。因此，为了确定元素是否存在，我们使用`assert.exists`而不是依赖抛出的异常。

# 运行登录场景

现在我们已经输入了一个测试场景，让我们试一试。在一个窗口中，启动 Notes 测试基础结构：

```js
$ cd test-compose
$ docker-compose up --force-rebuild
```

然后在另一个窗口中：

```js
$ docker exec -it userauth bash
userauth# PORT=3333 node ./users-add.js
userauth# exit
$ cd test-compare/notesui
$ NOTES_HOME_URL=http://localhost:3000 mocha --no-timeouts uitest.js 

 Notes
 Login
 √ should click on login button
 √ should fill in login form (72ms)
 √ should return to home page (1493ms)

 3 passing (3s)
```

`NOTES_HOME_URL`变量是脚本寻找的，用于引导 Chromium 浏览器使用 Notes 应用程序。要运行测试，我们应该使用 Docker Compose 启动测试基础结构，然后确保测试用户安装在用户数据库中。

# 添加注释场景

将此添加到`uitest.js`：

```js
describe('Add Note', function() {
    // before(async function() { ... });
    it('should see Add Note button', async function() {
        const btnAddNote = await page.waitForSelector('#btnAddNote');
        await btnAddNote.click();
    });
    it('should fill in Add Note form', async function() {
        const formAddEditNote = await 
        page.waitForSelector('#formAddEditNote');
        await page.type('#notekey', 'key42');
        await page.type('#title', 'Hello, world!');
        await page.type('#body', 'Lorem ipsum dolor');
        await page.click('#btnSave');
    });
    it('should view note', async function() {
        await page.waitForSelector('#noteView');
        const shownKey = await page.$eval('#showKey', el => 
        el.innerText);
        assert.exists(shownKey);
        assert.isString(shownKey);
        assert.include(shownKey, 'key42');
        const shownTitle = await page.$eval('#notetitle', el => 
        el.innerText);
        assert.exists(shownTitle);
        assert.isString(shownTitle);
        assert.include(shownTitle, 'Hello, world!');
        const shownBody = await page.$eval('#notebody', el => 
        el.innerText);
        assert.exists(shownBody);
        assert.isString(shownBody);
        assert.include(shownBody, 'Lorem ipsum dolor');
    });
    it('should go to home page', async function() {
        await page.waitForSelector('#btnGoHome');
        await page.goto(process.env.NOTES_HOME_URL);
        // await page.click('#btnGoHome');
        await page.waitForSelector('#notesHomePage');
        const titles = await page.$('#notetitles');
        assert.exists(titles);
        const key42 = await page.$('#key42');
        assert.exists(key42);
        const btnLogout = await page.$('#btnLogout');
        assert.exists(btnLogout);
        const btnAddNote = await page.$('#btnAddNote');
        assert.exists(btnAddNote);
    });
    // after(async function() { ... });
});
```

这是一个更复杂的场景，其中我们：

*   单击添加注释按钮
*   等待注释编辑屏幕显示
*   填写注释文本，然后单击“保存”按钮
*   验证便笺查看页面以确保其正确性
*   验证主页以确保其正确性。

其中大部分都使用了与以前相同的木偶演员功能，但有一些附加功能。

`$eval`函数查找与 CSS 选择器匹配的元素，并调用该元素上的回调函数。如果未找到任何元素，则会引发错误。正如这里所使用的，我们从屏幕上的某些元素中检索文本，并验证它是否与作为注释输入的测试匹配。这是添加和检索注释的端到端测试。

下一个区别是使用`goto`而不是点击`#btnGoHome`。

当您将测试场景添加到测试脚本中时，您会发现 Puppeter 很容易出现虚假超时，或者登录过程神秘地不工作，或者其他虚假错误

我们将在下一节讨论如何缓解这些问题，而不是讨论其余的场景。但首先，我们需要证明该场景确实有效，即使我们必须运行测试 10 次才能获得此结果：

```js
$ NOTES_HOME_URL=http://localhost:3000 ./node_modules/.bin/mocha --no-timeouts uitest3.js 

 Notes
 Login
 √ should click on login button (50ms)
 √ should fill in login form (160ms)
 √ should return to home page (281ms)
 Add Note
 √ should see Add Note button
 √ should fill in Add Note form (1843ms)
 √ should view note
 √ should go to home page (871ms)

 7 passing (5s)
```

# 减轻/防止木偶演员脚本中的虚假测试错误

我们的目标是完全自动化测试运行，以避免由于虚假错误而不得不雇佣人员来照看测试执行并花费时间重新运行测试。要做到这一点，测试必须是可重复的，没有任何虚假错误。Puppeter 是一个复杂的系统——有一个 Node.js 模块与后台运行的 Chromium 实例进行通信——计时问题似乎很容易导致虚假错误。

# 配置超时

Mocha 和 Puppeter 都允许您设置超时值，如果某些操作只需要长时间运行，长超时值可以避免触发错误。在测试套件的顶部，我们使用了此 Mocha 功能：

```js
this.timeout(10000);
```

这给了每个测试用例 10 秒的时间。如果要使用更长的超时，请增加该数字。

`puppeteer.launch`函数可以在其选项对象中获取超时值。默认情况下，Puppeter 在大多数操作中使用 30 秒超时，并且它们都使用带有设置的选项对象来更改超时时间。在本例中，我们添加了`slowMo`选项来降低浏览器上的操作速度。

# 跟踪页面上的事件和 Puppeter 实例

另一个有用的策略是对发生的事情进行跟踪，这样你就可以解开谜团了。插入`console.log`语句很乏味，会使代码看起来有点难看。Puppeter 提供了两种方法来跟踪动作和动态关闭跟踪。

在`uitest.js,`中添加此代码：

```js

function frameEvent(evtname, frame) {
    console.log(`${evtname} ${frame.url()} ${frame.title()}`);
}

function ignoreURL(url) {
    if (url.match(/\/assets\//) === null 
     && url.match(/\/socket.io\//) === null
     && url.match(/fonts.gstatic.com/) === null
     && url.match(/fonts.googleapis.com/) === null) {
        return false;
    } else {
        return true;
    }
}
...
before(async function() {
    browser = await puppeteer.launch({ slomo: 500 });
    page = await browser.newPage();
    page.on('console', msg => {
        console.log(`${msg.type()} ${msg.text()} ${msg.args().join(' ')}`);
    });
    page.on('error', err => {
        console.error(`page ERROR ${err.stack}`);
    });
    page.on('pageerror', err => {
        console.error(`page PAGEERROR ${err.stack}`);
    });
    page.on('request', req => {
        if (ignoreURL(req.url())) return;
        console.log(`page request ${req.method()} ${req.url()}`);
    });
    page.on('response', async (res) => {
        if (ignoreURL(res.url())) return;
        console.log(`page response ${res.status()} ${res.url()}`);
    });
    page.on('frameattached', async (frame) => frameEvent('frameattached', await frame));
    page.on('framedetached', async (frame) => frameEvent('framedetached', await frame));
    page.on('framenavigated', async (frame) => frameEvent('framenavigated', await frame));
    await page.goto(process.env.NOTES_HOME_URL);
});
...
```

也就是说，Page 对象提供了几个事件侦听器，在这些侦听器中，我们可以输出有关各种事件的详细信息，包括 HTTP 请求和响应。我们甚至可以打印出响应的 HTML 文本。`ignoreURL`函数允许我们抑制一些选定的 URL，这样我们就不会被不重要的请求和响应淹没。

您可以使用其调试环境变量跟踪木偶演员本身。更多信息请参见自述：[https://github.com/GoogleChrome/puppeteer.](https://github.com/GoogleChrome/puppeteer)

# 插入暂停

在某些点上插入长时间的暂停会很有用，这样浏览器就有时间做一些事情了。尝试此功能：

```js
function waitFor(timeToWait) {
    return new Promise(resolve => {
      setTimeout(() => { resolve(true); }, timeToWait);
    });
};
```

这就是我们如何使用承诺实现`sleep`函数的等价物。使用`setTimeOut`这种方式，加上超时值，只会导致给定毫秒数的延迟

要使用此功能，只需将其插入测试场景：

```js
await waitFor(3000);
```

这方面的一个变体是等待东西在浏览器中完全呈现。例如，在左上角的主图标完全渲染之前，您可能会看到暂停。该暂停可能会导致虚假错误，此函数可以等待按钮完全呈现自身：

```js
async function waitForBtnGoHome() {
    return page.waitForSelector('#btnGoHome');
}
```

要使用它：

```js
await waitForBtnGoHome();
```

如果您不想维护这个额外的函数，那么将`waitForSelector`调用添加到您的测试用例中就足够简单了。

# 避免 WebSocket 冲突

木偶师可以抛出一个错误`Cannot find context with specified id undefined`。根据 Puppeter 问题队列中的一个问题，这可能是由于 Puppeter 和 WebSocket 之间的意外交互引起的：[https://github.com/GoogleChrome/puppeteer/issues/1325](https://github.com/GoogleChrome/puppeteer/issues/1325) 此问题反过来影响 Notes 应用程序中的 Socket.IO 支持，因此，在测试运行期间禁用 Socket.IO 支持可能很有用。

允许禁用 Socket.IO 相当简单。在`app.mjs,`中增加此导出功能：

```js
export function enableSocketio() {
  var ret = true;
  const env = process.env.NOTES_DISABLE_SOCKETIO;
  if (!env || env !== 'true') {
    ret = true;
  }
  return ret;
}
```

这将查找环境变量以使函数返回`true`或`false`。

在`routes/index.mjs`和`routes/notes.mjs,`中增加该行：

```js
import { enableSocketio, sessionCookieName } from '../app';
```

我们这样做是为了导入前面的函数。它还展示了我们从 ES6 模块获得的一些灵活性，因为我们可以只导入所需的函数。

在`routes/index.mjs`和`routes/notes.mjs`中，对于调用`res.render`发送结果的每个路由函数，使用`enableSocketio`函数如下：

```js
res.render('*view-name*', { 
  ...
  enableSocketio: enableSocketio()
});
```

因此，我们导入了该函数，并将每个视图的`enableSocketio`作为数据传递给视图模板。

在`views/index.hbs`和`views/noteview.hbs`中，我们有一段 JavaScript 代码来实现基于 SocketIO 的半实时特性。将每个这样的部分环绕如下：

```js
{{#if enableSocketio}}
...  JavaScript code for SocketIO support
{{/if}}
```

通过消除客户端 SocketIO 代码，我们可以确保用户界面不会打开到 SocketIO 服务的连接。这个练习的目的是避免使用 WebSocket 来避免木偶演员的问题。

同样，在`views/noteview.hbs`中，支持如下禁用注释按钮：

```js
{{#if enableSocketio}}
    <button id="btnComment" type="button" class="btn btn-outline-dark" 
        data-toggle="modal" data-target="#notes-comment-modal">Comment</button>
{{/if}}
```

最后一步是在 Docker Compose 文件中设置环境变量`NOTES_DISABLE_SOCKETIO`。

# 截图

木偶演员的核心功能之一是拍摄截图，可以是 PNG 文件，也可以是 PDF 文件。在我们的测试脚本中，我们可以截图来跟踪测试期间任何给定时间屏幕上的内容。例如，如果登录场景错误地未能登录，我们可以在屏幕截图中看到：

```js
await page.screenshot({
      type: 'png',
      path: `./screen/login-01-start.png`
});
```

只需在整个测试脚本中添加这样的代码片段。此处显示的文件名遵循一种约定，其中第一段命名测试场景，数字是测试场景中的序列号，最后一段描述测试场景中的步骤。

截图还提供了另一个验证阶段。您可能还需要对应用程序进行可视化验证。`pixelmatch`模块可以比较两个 PNG 文件，因此可以维护一组所谓的黄金图像，以便在测试运行期间进行比较

有关以这种方式使用木偶演员的示例，请参见：[https://meowni.ca/posts/2017-puppeteer-tests/](https://meowni.ca/posts/2017-puppeteer-tests/) 。

# 总结

在本章中，我们涵盖了很多领域，考察了三个不同的测试领域：单元测试、RESTAPI 测试和 UI 功能测试。确保应用程序经过良好测试是软件成功道路上的重要一步。不遵循良好测试实践的团队经常陷入一次又一次修复回归的困境。

我们已经讨论了简单使用 assert 模块进行测试的潜在简单性。虽然测试框架（如 Mocha）提供了很好的特性，但我们可以通过一个简单的脚本走很长的路。

如果只是为了规范我们的测试用例，并生成测试结果报告，那么测试框架（如 Mocha）就有了一席之地。我们使用了摩卡咖啡和柴，这些工具非常成功。我们甚至在一个小测试套件中发现了几个 bug。

当开始单元测试时，一个设计考虑是模拟依赖关系。但用模拟版本替换每个依赖项并不总是很好地利用我们的时间。

为了减轻运行测试的管理负担，我们使用 Docker 自动设置和拆除测试基础结构。正如 Docker 在自动化 Notes 应用程序的部署方面很有用一样，它在自动化测试基础设施部署方面也很有用。

最后，我们能够在真实的 web 浏览器中测试 Notes web 用户界面。我们不能相信单元测试会发现每一个 bug；有些 bug 只会出现在 web 浏览器中。即便如此，我们只触及了 Notes 中可以测试的内容的开始。

在本书中，我们已经涵盖了 NoDE.js 开发的范围，为您开始开发 No.js 应用程序提供了坚实的基础。

在下一章中，我们将探讨另一个关键领域——安全。我们将首先使用 HTTPS 加密和验证用户对 Notes 的访问。并且，我们将使用几个 Node.js 包来限制安全入侵的机会