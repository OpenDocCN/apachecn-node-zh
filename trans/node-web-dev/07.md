# 七、数据存储和检索

在前两章中，我们构建了一个用于存储笔记的小而有用的应用，然后使其在移动设备上工作。虽然应用运行得相当好，但它不会长期将这些笔记存储在任何地方，这意味着当您停止服务器时，笔记会丢失，并且，如果您运行多个笔记实例，每个实例都有自己的笔记集。典型的下一步是引入数据库层

在本章中，我们将研究 Node.js 中的数据库支持，这样用户就可以看到所访问的任何 notes 实例的同一组 notes，并可靠地存储 notes 以供长期检索。

我们将从上一章中使用的*Notes*应用代码开始。我们从一个简单的内存数据模型开始，该模型使用一个数组来存储笔记，然后使其便于移动。在本章中，我们将：

*   发现日志记录操作和调试信息
*   开始使用 ES6 模块格式
*   使用多个数据库引擎实现 Notes 对象的数据持久性

让我们开始吧！

第一步是复制上一章中的代码。例如，如果您在`chap06/notes`工作，请将其复制为`chap07/notes`。

# 数据存储和异步代码

根据定义，外部数据存储系统需要 Node.js 体系结构中的异步代码。从磁盘、其他进程或数据库检索数据的访问时间总是需要足够的时间来要求延迟执行

现有的`Notes`数据模型是内存中的数据存储。理论上，内存中的数据访问不需要异步代码，因此，现有的模型模块可以使用常规函数而不是`async`函数。

我们知道 Notes 必须转向使用数据库，并且需要一个异步 API 来访问 Notes 数据。因此，现有 Notes 模型 API 使用`async`函数，因此在本章中，我们可以将 Notes 数据持久化到数据库中。

# 登录中

在进入数据库之前，我们必须解决高质量软件系统的一个属性：管理记录的信息，包括正常的系统活动、系统错误和调试信息。日志使我们能够深入了解系统的行为。交通量有多大？如果是一个网站，人们访问最多的是哪些页面？发生了多少错误？错误类型是什么？攻击发生了吗？是否发送格式错误的请求？

日志管理也是一个问题。日志轮换意味着定期将日志文件移开，从新的日志文件开始。您应该处理记录的数据以生成报告。必须高度重视安全漏洞的筛选。

12 因素应用模型建议只需将日志信息发送到控制台，然后其他一些软件系统捕获该输出并将其定向到日志服务。遵循他们的建议可以减少系统的复杂性，因为系统中可能出现的故障更少。在后面的章节中，我们将使用 PM2 来实现这一目的。

让我们首先完成一次信息记录之旅，它现在位于 Notes 中。

当我们使用 Express Generator 最初创建*Notes*应用时，它使用`morgan`配置了一个活动日志系统：

```js
const logger = require('morgan'); 
.. 
app.use(logger('dev')); 
```

这是在终端窗口上打印请求的内容。访问[https://github.com/expressjs/morgan](https://github.com/expressjs/morgan) 了解更多信息。

在内部，Express 使用**调试**包进行调试跟踪。您可以使用`DEBUG`环境变量打开这些。我们应该尝试在应用代码中使用这个包。欲了解更多信息，请访问[https://www.npmjs.com/package/debug](https://www.npmjs.com/package/debug) 。

最后，应用可能会生成未捕获的异常。`uncaughtException`错误需要捕获、记录并适当处理。

# 向 Morgan 请求日志记录

Morgan 软件包有两个一般配置区域：

*   日志格式
*   日志位置

目前，Notes 使用`dev`格式，该格式被描述为供开发人员使用的简明状态输出。这可以用来记录 web 请求，作为衡量网站活动和受欢迎程度的一种方法。Apache 日志格式已经有了大量的报告工具，Morgan 可以用这种格式生成日志文件

要更改格式，只需在`app.js`中更改此行：

```js
app.use(logger(process.env.REQUEST_LOG_FORMAT || 'dev')); 
```

然后运行*注释*如下：

```js
$ REQUEST_LOG_FORMAT=common npm start

> notes@0.0.0 start /Users/david/chap07/notes
> node ./bin/www
::1 - - [12/Feb/2016:05:51:21 +0000] "GET / HTTP/1.1" 304 -
::1 - - [12/Feb/2016:05:51:21 +0000] "GET /vendor/bootstrap/css/bootstrap.min.css HTTP/1.1" 304 -
::1 - - [12/Feb/2016:05:51:21 +0000] "GET /stylesheets/style.css HTTP/1.1" 304 -
::1 - - [12/Feb/2016:05:51:21 +0000] "GET /vendor/bootstrap/js/bootstrap.min.js HTTP/1.1" 304 -  
```

要恢复到以前的日志输出，只需不设置此环境变量即可。如果您看过 Apache 访问日志，那么这种日志格式看起来会很熟悉。行首的`::1`符号是`localhost`的 IPV6 符号，您可能更熟悉的是`127.0.0.1`。

我们可以在请求日志记录中宣布胜利，并继续调试消息。但是，让我们看看如何直接将其记录到文件中。虽然可以通过单独的过程捕获`stdout`，但 Morgan 已经安装在 Notes 中，它确实提供了将其输出定向到文件的功能。

摩根的文件表明：

```js
// create a write stream (in append mode) 
var accessLogStream = fs.createWriteStream(__dirname + '/access.log', {flags: 'a'}) 

// setup the logger 
app.use(morgan('combined', {stream: accessLogStream})); 
```

但这有一个问题；如果不停止并重新启动服务器，就不可能执行日志循环。相反，我们将使用他们的`rotating-file-stream`包。

首先，安装软件包：

```js
$ npm install rotating-file-stream --save  
```

然后我们将此代码添加到`app.js`：

```js
const fs = require('fs-extra');
...
const rfs = require('rotating-file-stream');
var logStream;
// Log to a file if requested
if (process.env.REQUEST_LOG_FILE) {
  (async () => {
    let logDirectory = path.dirname(process.env.REQUEST_LOG_FILE); 
    await fs.ensureDir(logDirectory);
    logStream = rfs(process.env.REQUEST_LOG_FILE, {
        size: '10M',     // rotate every 10 MegaBytes written
        interval: '1d',  // rotate daily
        compress: 'gzip' // compress rotated files
    });
  })().catch(err => { console.error(err); });
}
.. 
app.use(logger(process.env.REQUEST_LOG_FORMAT || 'dev', { 
    stream: logStream ? logStream : process.stdout 
})); 
```

这里，我们使用一个环境变量`REQUEST_LOG_FILE`来控制是将日志发送到`stdout`还是发送到文件。日志可以进入一个目录，如果该目录不存在，代码将自动创建该目录。使用`rotating-file-stream`（[https://www.npmjs.com/package/rotating-file-stream](https://www.npmjs.com/package/rotating-file-stream) ），我们保证在不需要额外系统的情况下进行日志文件轮换。

之所以使用`fs-extra`模块，是因为它在`fs`模块（[中添加了基于承诺的功能 https://www.npmjs.com/package/fs-extra](https://www.npmjs.com/package/fs-extra) ）。在本例中，`fs.ensureDir`检查命名目录结构是否存在，如果不存在，则创建目录路径

# 调试消息

您可以通过以下方式运行*Notes*来生成 Express 的详细功能：

```js
$ DEBUG=express:* npm start  
```

如果要调试 Express，这非常有用。但是，我们也可以在自己的代码中使用它。这类似于插入`console.log`语句，但不必记住注释掉调试代码。

在模块中启用调试非常简单：

```js
const debug = require('debug')('module-name'); 
.. 
debug('some message'); 
.. 
debug(`got file ${fileName}`); 
```

# 捕获 stdout 和 stderr

重要消息可以打印到`process.stdout`或`process.stderr`，如果不捕获输出，这些消息可能会丢失。十二因素模型建议使用系统设施来捕获这些输出流。注意，我们将使用 PM2 实现这一目的，我们将在[第 10 章](10.html)、*部署 Node.js 应用*中介绍。

`logbook`模块（[https://github.com/jpillora/node-logbook](https://github.com/jpillora/node-logbook) 提供了一些有用的功能，不仅可以捕获`process.stdout`和`process.stderr`，还可以将输出发送到有用的地方。

# 未捕获的例外

未捕获异常是重要信息可能丢失的另一个领域。这在*Notes*应用中很容易修复：

```js
const error = require('debug')('notes:error'); 

process.on('uncaughtException', function(err) { 
  error("I've crashed!!! - "+ (err.stack || err)); 
}); 
.. 
if (app.get('env') === 'development') { 
  app.use(function(err, req, res, next) { 
    // util.log(err.message); 
    res.status(err.status || 500); 
    error((err.status || 500) +' '+ error.message); 
    res.render('error', { 
      message: err.message, 
      error: err 
    }); 
  }); 
} 
.. 
app.use(function(err, req, res, next) { 
  // util.log(err.message); 
  res.status(err.status || 500); 
  error((err.status || 500) +' '+ error.message); 
  res.render('error', { 
    message: err.message, 
    error: {} 
  }); 
}); 
```

`debug`套餐有一个我们遵循的惯例。对于具有多个模块的应用，所有调试器对象都应使用命名模式`app-name:module-name`。在本例中，我们使用了将用于所有错误消息的`notes:error`。我们也可以使用`notes:memory-model`或`notes:mysql-model`来调试不同的模型。

当我们为未捕获异常设置处理程序时，将错误日志添加到错误处理程序中也是一个好主意。

# 未经处理的拒绝承诺

使用 Promise 和`async`函数会自动将错误引导到有用的方向。错误会导致 Promise 转换为*拒绝*状态，最终必须通过`.catch`方法进行处理。因为我们都是人，我们肯定会忘记确保所有代码路径都能处理被拒绝的承诺。

当前，如果 Node.js 检测到未处理的承诺拒绝，则会打印以下警告：

```js
(node:4796) UnhandledPromiseRejectionWarning: Unhandled promise rejection 
```

警告接着指出，未经处理的承诺拒绝的默认处理程序已被弃用，此类承诺拒绝将使节点进程崩溃，而不是打印此消息。在这种情况下，内置的`process`模块确实会发出一个事件，因此添加一个处理程序非常简单：

```js
import util from 'util';
...
process.on('unhandledRejection', (reason, p) => {
  error(`Unhandled Rejection at: ${util.inspect(p)} reason: ${reason}`);
});
```

我们至少可以打印以下错误消息：

```js
notes:error Unhandled Rejection at: Promise {
  notes:error <rejected> TypeError: model(...).keylist is not a function
  ... full stack trace
} reason: TypeError: model(...).keylist is not a function +3s
```

# 使用 ES6 模块格式

我们使用 CommonJS 模块（传统的 Node.js 模块格式）编写了*Notes*应用。虽然应用可以继续使用该格式，但 JavaScript 社区选择在 browser 和 Node.js 代码中切换到 ES6 模块，因此切换 ES6 模块非常重要，这样我们就可以使用通用的模块格式。让我们使用 ES6 模块重写应用，然后为我们添加的任何新内容编写 ES6 模块。

所需的更改很大，可以将`require`语句替换为`import`语句，并将文件从`foo.js`重命名为`foo.mjs`。让我们开始吧。

# 将 app.js 重写为 ES6 模块

让我们从`app.js`开始，将其名称更改为`app.mjs`：

```js
$ mv app.js app.mjs
```

将顶部的`require`语句块更改为以下内容：

```js
import fs from 'fs-extra';
import url from 'url';
import express from 'express';
import hbs from 'hbs';
import path from 'path';
import util from 'util';
import favicon from 'serve-favicon';
import logger from 'morgan';
import cookieParser from 'cookie-parser';
import bodyParser from 'body-parser';
import DBG from 'debug';
const debug = DBG('notes:debug'); 
const error = DBG('notes:error'); 
import { router as index } from './routes/index';
// const users = require('./routes/users');
import { router as notes } from './routes/notes'; 

// Workaround for lack of __dirname in ES6 modules
const __dirname = path.dirname(new URL(import.meta.url).pathname);

const app = express();

import rfs from 'rotating-file-stream';
```

然后，在脚本底部进行以下更改：

```js
export default app;
```

让我们谈谈这里提到的解决方法。Node.js 自动将几个全局变量注入 CommonJS 模块。ES6 模块不支持这些变量。*注释*的关键变量为`__dirname`，在`app.mjs`中有多处使用。此处显示的代码更改包括一个基于全新 JavaScript 功能的变通方法，该功能从 Node.js 10.x 开始提供，`import.meta.url`变量。

`import.meta`对象用于将有用信息注入 ES6 模块。顾名思义，`import.meta.url`变量包含描述模块从何处加载的 URL。对于 Node.js，此时 ES6 模块只能从本地文件系统上的`file://`URL 加载。这意味着，如果我们提取该 URL 的`pathname`，我们可以很容易地计算包含模块的目录，如下所示。

为什么要采用这种解决方案？为什么不使用以`./`开头的路径名？答案是`./`文件名是相对于进程的当前工作目录计算的。该目录通常与包含正在执行的 Node.js 模块的目录不同，因此 Node.js 团队添加了`import.meta.url`功能更加方便。

大多数情况下遵循的模式是这种变化：

```js
const moduleName = require('moduleName');  // in CommonJS modules
import moduleName from 'moduleName';       // in ES6 modules
```

记住，Node.js 在 ES6 和 CommonJS 模块中使用相同的模块查找算法。Node.js`require`语句是同步的，这意味着在`require`完成时，它已经执行了模块并返回其`module.exports`。相比之下，ES6 模块是异步的，这意味着模块可能尚未完成加载，您可以只导入模块所需的位。

此处显示的大多数模块导入是针对安装在`node_modules`目录中的常规 Node.js 模块，其中大多数是 CommonJS 模块。将`import`与 CommonJS 模块一起使用的规则是，将`module.exports`对象视为默认导出。前面显示的`import`语句命名了`import`语句中显示的默认导出（或`module.exports`对象）。对于以这种方式导入的 CommonJS 模块，您可以像在 CommonJS 上下文中一样使用它，`moduleName.functionName()`。

`debug`模块的用法实际上相同，但编码不同。在 CommonJS 上下文中，我们被告知按如下方式使用该模块：

```js
const debug = require('debug')('notes:debug'); 
const error = require('debug')('notes:error'); 
```

换句话说，这个模块的`module.exports`是一个函数，我们会立即调用它。ES6 模块没有以这种方式使用`debug`模块的语法。因此，我们必须如图所示将其拆分，并显式调用该函数。

讨论的最后一点是两个路由模块的`import`。最初尝试让这些模块将`router`导出为默认值，但 Express 在这种情况下抛出了一个错误。相反，我们将重写这些模块，将`router`导出为命名导出，然后使用命名导出，如图所示。

# 将 bin/www 重写为 ES6 模块

请记住，`bin/www`是用于启动应用的脚本。它是作为 CommonJS 脚本编写的，但由于`app.mjs`现在是 ES6 模块，`bin/www`也必须重写为 ES6 模块。编写本文时，CommonJS 模块无法导入 ES6 模块。

更改文件名：

```js
$ mv bin/www bin/www.mjs
```

然后，在顶部，将`require`语句更改为`import`语句：

```js
import app from '../app.mjs';
import DBG from 'debug';
const debug = DBG('notes:server-debug'); 
const error = DBG('notes:server-error'); 
import http from 'http';
```

我们已经在这里讨论了所有内容，除了`app.mjs`将其`app`对象导出为默认导出。因此，我们使用它，如图所示。

# 将模型代码重写为 ES6 模块

models 目录包含两个模块：`Note.js`定义`Note`类，`notes-memory.js`包含内存中的数据模型。两者都易于转换为 ES6 模块。

更改文件名：

```js
$ cd models
$ mv Note.js Note.mjs
$ mv notes-memory.js notes-memory.mjs
```

在`Note.mjs`中，只需进行以下更改：

```js
export default class Note {
  ...
}
```

这使得`Note`类成为默认导出

然后，在`notes-memory.mjs`中进行以下更改：

```js
import Note from './Note';

var notes = [];

async function crupdate(key, title, body) {
  notes[key] = new Note(key, title, body);
  return notes[key];
}

export function create(key, title, body) { return crupdate(key, title, body); }
export function update(key, title, body) { return crupdate(key, title, body); }

export async function read(key) {
  if (notes[key]) return notes[key];
  else throw new Error(`Note ${key} does not exist`);
}

export async function destroy(key) {
  if (notes[key]) {
    delete notes[key];
  } else throw new Error(`Note ${key} does not exist`);
}

export async function keylist() { return Object.keys(notes); }
export async function count() { return notes.length; }
export async function close() { }

```

这是一个简单的音译，将函数分配给`module.exports`以使用命名导出。

通过将`Note`类定义为`Note.mjs`模块的默认导出，它可以`import`很好地导入到使用该类的任何模块中。

# 将路由模块重写为 ES6 模块

`routes`目录包含两个路由模块。目前，每个路由模块创建一个`router`对象，向该对象添加路由函数，然后将其分配给`module.exports`字段。这表明我们应该将`router`导出为默认导出，但正如我们前面所说的，这并不正确。相反，我们将`router`作为命名导出导出。

更改文件名：

```js
$ cd routes
$ mv index.js index.mjs
$ mv notes.js notes.mjs
```

然后，在每个语句的顶部，将`require`语句块更改为以下内容：

```js
import util from 'util';
import express from 'express';
import * as notes from '../models/notes-memory';

export const router = express.Router();
```

在两个文件中都是相同的。然后，在每个文件的底部，删除分配给`module.exports`的`router`行。

让我们转到`app.mjs`并更改路由模块的导入方式。

因为`router`是一个命名的导出，所以默认情况下您会在`app.mjs`中导入`router`对象，如下所示：

```js
import { router } from './routes/index';
```

但是，由于两个模块都定义了一个`router`对象，因此我们会有冲突。相反，我们使用`as`子句更改了此对象的名称：

```js
import { router as index } from './routes/index';
import { router as notes } from './routes/notes'; 
```

因此，每个模块的`router`对象都有一个合适的名称。

# 在文件系统中存储注释

文件系统是一个经常被忽略的数据库引擎。虽然文件系统没有数据库引擎支持的那种查询功能，但它们是存储文件的可靠场所。notes 模式非常简单，因此文件系统可以轻松地用作其数据存储层。

让我们先在`Note.mjs`中添加一个函数：

```js
export default class Note {
   ...
   get JSON() { 
      return JSON.stringify({ 
        key: this.key, title: this.title, body: this.body 
      }); 
   }

   static fromJSON(json) { 
       var data = JSON.parse(json); 
       var note = new Note(data.key, data.title, data.body); 
       return note; 
   } 
}
```

`JSON`是一个 getter，这意味着它获取对象的值。在本例中，`note.JSON`属性/getter（不带括号）将简单地为我们提供注释的 JSON 表示。稍后我们将使用它来写入 JSON 文件。

`fromJSON`是一个静态函数或工厂方法，如果我们有一个 JSON 字符串，它可以帮助构造`Note`对象。区别在于`JSON`与`Note`类的实例相关联，而`fromJSON`与该类本身相关联。二者可按如下方式使用：

```js
const note = new Note("key", "title", "body"); 
const json = note.JSON;    // produces JSON text
const newnote = Note.fromJSON(json); // produces new Note instance
```

现在，让我们创建一个新模块`models/notes-fs.mjs`，以保存文件系统模型：

```js
import fs from 'fs-extra';
import path from 'path';
import util from 'util';
import Note from './Note';
import DBG from 'debug';
const debug = DBG('notes:notes-fs');
const error = DBG('notes:error-fs');

async function notesDir() { 
    const dir = process.env.NOTES_FS_DIR || "notes-fs-data"; 
    await fs.ensureDir(dir);
    return dir;
} 

function filePath(notesdir, key) { return path.join(notesdir, `${key}.json`); } 

async function readJSON(notesdir, key) { 
    const readFrom = filePath(notesdir, key); 
    var data = await fs.readFile(readFrom, 'utf8');
    return Note.fromJSON(data);
}
```

`notesDir`功能将在整个`notes-fs`中使用，以确保目录存在。为了简单起见，我们使用了`fs-extra`模块，因为它向`fs`模块（[模块）添加了基于承诺的函数 https://www.npmjs.com/package/fs-extra](https://www.npmjs.com/package/fs-extra) ）。在本例中，`fs.ensureDir`验证命名目录结构是否存在，如果不存在，则创建目录路径

环境变量`NOTES_FS_DIR`配置一个目录，在其中存储注释。我们将为每个注释创建一个文件，并将注释存储为 JSON。如果没有指定环境变量，我们将使用`notes-fs-data`作为目录名。

因为我们正在添加另一个依赖项：

```js
$ npm install fs-extra --save 
```

每个数据文件的文件名为`key`并附加了`.json`。这就产生了一个限制，即文件名不能包含`/`字符，因此我们使用以下代码进行测试：

```js
async function crupdate(key, title, body) { 
    var notesdir = await notesDir();
    if (key.indexOf('/') >= 0) 
        throw new Error(`key ${key} cannot contain '/'`); 
    var note = new Note(key, title, body); 
    const writeTo = filePath(notesdir, key); 
    const writeJSON = note.JSON; 
    await fs.writeFile(writeTo, writeJSON, 'utf8');
    return note;
}

export function create(key, title, body) { return crupdate(key, title, body); }
export function update(key, title, body) { return crupdate(key, title, body); }
```

与`notes-memory`模块一样，`create`和`update`函数使用完全相同的代码。`notesDir`函数用于确保目录存在，然后我们创建一个`Note`对象，然后将数据写入文件

请注意，由于`async`函数，代码非常简单。我们不检查错误，因为它们会被`async`函数自动捕获并冒泡出来给我们的调用者：

```js
export async function read(key) { 
    var notesdir = await notesDir();
    var thenote = await readJSON(notesdir, key);
    return thenote; 
}
```

使用`readJSON`从磁盘读取文件。它已经生成了`Note`对象，所以我们所要做的就是返回该对象：

```js
export async function destroy(key) { 
    var notesdir = await notesDir();
    await fs.unlink(filePath(notesdir, key)); 
}
```

`fs.unlink`函数删除我们的文件。由于此模块使用文件系统，因此删除文件是删除`note`对象所需的全部操作：

```js
export async function keylist() { 
    var notesdir = await notesDir();
    var filez = await fs.readdir(notesdir);
    if (!filez || typeof filez === 'undefined') filez = []; 
    var thenotes = filez.map(async fname => { 
        var key = path.basename(fname, '.json');
        var thenote = await readJSON(notesdir, key);
        return thenote.key; 
    }); 
    return Promise.all(thenotes); 
}
```

`keylist`的合同是返回一个承诺，该承诺将解析为现有 Notes 对象的一个密钥数组。由于它们作为单个文件存储在`notesdir`中，因此我们必须读取该目录中的每个文件以检索其密钥。

`Array.map`从现有数组构造一个新数组，即`fs.readdir`返回的文件名数组。构造的数组中的每个条目都是`async`函数，它读取注释，返回`key`：

```js
export async function count() { 
    var notesdir = await notesDir();
    var filez = await fs.readdir(notesdir); 
    return filez.length;
}

export async function close() { }
```

计算笔记的数量只是计算`notesdir`中的文件数量。

# ES6 模块的动态导入

在开始修改路由功能之前，我们必须考虑如何解释多个模型。目前，我们的数据模型有两个模块，`notes-memory`和`notes-fs`，在本章结束时，我们将实现更多的模块。我们需要一个简单的方法来选择所使用的模型。

有几种可能的方法可以做到这一点。例如，在 CommonJS 模块中，可以执行以下操作：

```js
const path  = require('path'); 
const notes = require(process.env.NOTES_MODEL  
                  ? path.join('..', process.env.NOTES_MODEL)  
                  : '../models/notes-memory'); 
```

这允许我们设置一个环境变量`NOTES_MODEL`，以选择用于数据模型的模块。

这种方法不适用于常规的`import`语句，因为`import`语句中的模块名不能是这样的表达式。Node.js 中现在的动态导入功能提供了一种类似于刚才显示的代码段的机制

动态导入是一个`import()`函数，它返回一个将解析为导入模块的承诺。作为一个函数返回承诺，`import()`作为模块中的顶级代码不会有用。但是，考虑一下：

```js
var NotesModule;

async function model() {
  if (NotesModule) return NotesModule;
  NotesModule = await import(`../models/notes-${process.env.NOTES_MODEL}`);
  return NotesModule;
}

export async function create(key, title, body) { 
    return (await model()).create(key, title, body); 
}
export async function update(key, title, body) { 
    return (await model()).update(key, title, body); 
}
export async function read(key) { return (await model()).read(key); }
export async function destroy(key) { return (await model()).destroy(key); }
export async function keylist() { return (await model()).keylist(); }
export async function count() { return (await model()).count(); }
export async function close() { return (await model()).close(); }
```

将该模块保存在文件`models/notes.mjs`中。此模块实现的 API 与我们将用于所有 Notes 模型模块的 API 相同。`model()`函数是基于环境变量动态选择 notes 模型实现的关键。

这是一个`async`函数，因此其返回值是一个承诺。该承诺的值为所选模块，由`import()`加载。因为`import()`返回了一个承诺，所以我们使用`await`来判断它是否正确加载。

每个 API 方法都遵循以下模式：

```js
export async function methodName(args) { 
    return (await model()).methodName(args); 
}
```

因为`model()`返回一个承诺，所以使用`async`函数并使用`await`解析承诺是最简洁的。一旦承诺得到解决，我们只需调用`methodName`函数即可开始我们的业务。否则，这些 API 方法函数将如下所示：

```js
export function methodName(args) {
    return model().then(notes => { return notes.*methodName*(args); });
}
```

这两个实现是等效的，很明显哪一个更简洁。

由于`async`函数返回了所有这些`await`ing on Promise，因此值得讨论开销。最坏的情况是第一次调用`model()`，因为所选 notes 模型尚未加载。第一次，调用流程如下所示：

*   API 方法调用`model()`，后者调用`import()`，然后`await`将模块加载完成
*   API 方法`await`从`model()`返回承诺，获取模块对象，然后调用 API 函数
*   调用方还使用`await`接收最终结果

第一次，主要是等待`import()`完成模块加载。在后续调用中，模块已经加载，第一步是简单地形成包含模块的已解析承诺。然后，API 方法可以快速地将任务委托给实际的 API 方法。

为了使用这个，在`routes/index.mjs`和`routes/notes.mjs`中，我们做了如下更改：

```js
import util from 'util';
import express from 'express';
import * as notes from '../models/notes';

export const router = express.Router();
```

# 使用文件系统存储运行 Notes 应用

在`package.json`中，将其添加到`scripts`部分：

```js
"start-fs": "DEBUG=notes:* NOTES_MODEL=fs node --experimental-modules ./bin/www.mjs", 
```

When you put these entries in `package.json`, make sure that you use correct JSON syntax. In particular, if you leave a comma at the end of the `scripts` section, it will fail to parse and npm will throw up an error message.

有了这段代码，我们现在可以按如下方式运行*Notes*应用：

```js
$ DEBUG=notes:* npm run start-fs

> notes@0.0.0 start-fs /Users/david/chap07/notes
> NOTES_MODEL=models/notes-fs node --experimental-modules./bin/www.mjs

  notes:server Listening on port 3000 +0ms
  notes:fs-model keylist dir=notes-fs-data files=[  ] +4s  
```

然后我们可以像以前一样在`http://localhost:3000`使用该应用。因为我们没有更改任何模板或 CSS 文件，所以该应用的外观将与您在[第 6 章](06.html)*实现移动第一范式*结尾时留下的一模一样。

因为`notes:*`的调试已打开，所以我们将看到*Notes*应用正在执行的任何操作的日志。只需不设置`DEBUG`变量即可轻松关闭此功能。

您现在可以关闭并重新启动*Notes*应用，并查看完全相同的 Notes。您还可以使用常规文本编辑器（如`vi`）在命令行编辑注释。现在，您可以在不同端口上启动多台服务器，并查看完全相同的注释：

```js
"server1": "NOTES_MODEL=fs PORT=3001 node --experimental-modules./bin/www.mjs", 
"server2": "NOTES_MODEL=fs PORT=3002 node --experimental-modules./bin/www.mjs", 
```

然后您在单独的命令窗口中启动`server1`和`server2`，就像我们在[第 5 章](05.html)中所做的一样，*您的第一个快速应用*。然后，在单独的浏览器窗口中访问这两个服务器，您将看到两个浏览器窗口显示相同的注释。

最后一项检查是创建一个注释，其中键具有`/`字符。请记住，该键用于生成存储注释的文件名，因此该键不能包含`/`字符。在浏览器打开的情况下，单击添加注释并输入注释，确保在`key`字段中使用`/`字符。单击 Submit 按钮时，您将看到一个错误，表明这是不允许的。

# 使用 LevelUP 数据存储存储笔记

为了开始实际的数据库，让我们看看一个非常轻量级、占用空间小的数据库引擎：**LevelUP**。这是一个 Node.js 友好的包装器，围绕着 Google 开发的 LevelDB 引擎，它通常在 web 浏览器中用于本地数据持久化。它是一个非索引的 NoSQL 数据存储，最初设计用于浏览器。No.js 模块，Lead 使用 LealDB API，并支持多个后端，包括 AuthT0}，它集成了 C++LealDB 数据库到 NoDE.js。

访问[https://www.npmjs.com/package/level](https://www.npmjs.com/package/level) 获取有关模块的信息。`level`包自动设置`levelup`和`leveldown`包

要安装数据库引擎，请运行以下命令：

```js
$ npm install level@2.1.x --save
```

然后，开始创建`models/notes-level.mjs`模块：

```js
import fs from 'fs-extra';
import path from 'path';
import util from 'util';
import Note from './Note';
import level from 'level';
import DBG from 'debug';
const debug = DBG('notes:notes-level'); 
const error = DBG('notes:error-level'); 

var db;

async function connectDB() { 
    if (typeof db !== 'undefined' || db) return db;
    db = await level(
        process.env.LEVELDB_LOCATION || 'notes.level', { 
            createIfMissing: true, 
            valueEncoding: "json" 
    }); 
    return db;
} 
```

`level`模块为我们提供了一个`db`对象，通过它与数据库进行交互。为了便于使用，我们将该对象作为全局对象存储在模块中。如果设置了`db`对象，我们可以立即返回它。否则，我们将使用`createIfMissing`打开数据库，并在需要时创建数据库。

数据库在当前目录中的位置默认为`notes.level`。顾名思义，可以设置环境变量`LEVELDB_LOCATION`来指定数据库位置：

```js
async function crupdate(key, title, body) { 
    const db = await connectDB();
    var note = new Note(key, title, body); 
    await db.put(key, note.JSON);
    return note;
}

export function create(key, title, body) {
    return crupdate(key, title, body);
}

export function update(key, title, body) {
    return crupdate(key, title, body);
}
```

调用`db.put`可以创建新的数据库条目，也可以替换现有的数据库条目。因此，将`update`和`create`设置为相同的功能。我们将注释转换为 JSON，以便轻松存储在数据库中：

```js
export async function read(key) {
    const db = await connectDB();
    var note = Note.fromJSON(await db.get(key));
    return new Note(note.key, note.title, note.body);
}
```

阅读注释很容易：只需调用`db.get`即可检索数据，数据必须从 JSON 表示中解码

注意，`db.get`和`db.put`没有使用回调函数，我们使用`await`来获取结果值。`level`导出的函数可以采用回调函数，在回调函数中调用回调。或者，如果没有提供回调函数，`level`函数将返回与`async`函数兼容的承诺：

```js
export async function destroy(key) { 
    const db = await connectDB();
    await db.del(key);
}
```

`db.destroy`功能从数据库中删除一条记录：

```js
export async function keylist() { 
    const db = await connectDB();
    var keyz = [];
    await new Promise((resolve, reject) => { 
        db.createKeyStream()
        .on('data', data => keyz.push(data)) 
        .on('error', err => reject(err)) 
        .on('end', () => resolve(keyz));
    }); 
    return keyz;
}

export async function count() { 
    const db = await connectDB();
    var total = 0;
    await new Promise((resolve, reject) => { 
        db.createKeyStream()
        .on('data', data => total++) 
        .on('error', err => reject(err)) 
        .on('end', () => resolve(total));
    }); 
    return total;
}

export async function close() {
    var _db = db;
    db = undefined;
    return _db ? _db.close() : undefined;
}
```

`createKeyStream`函数使用类似于 Streams API 的面向事件的接口。它将流经每个数据库条目，并在运行时发出事件。数据库中的每个键都会发出一个`data`事件，而`end`事件会在数据库末尾发出，错误时会发出`error`事件。其结果是，没有简单的方法将此作为一个简单的承诺来表达。取而代之的是，我们调用`createKeyStream`，让它自己运行，一边收集数据。我们必须将其封装在承诺对象中，并在`end`事件中调用 resolve。

然后我们将其添加到`scripts`部分的`package.json`：

```js
"start-level": "DEBUG=notes:* NOTES_MODEL=level node --experimental-modules ./bin/www.mjs",
```

最后，您可以运行*Notes*应用：

```js
$ DEBUG=notes:* npm run start-level
> notes@0.0.0 start /Users/david/chap07/notes
> node ./bin/www

  notes:server Listening on port 3000 +0ms 
```

控制台中的打印输出将是相同的，应用的外观也将是相同的。您可以对其进行测试，并确保一切正常。

由于`level`不支持从多个实例同时访问数据库，您将无法使用多个*Notes*应用场景。但是，您可以随意停止并重新启动应用，而不会丢失任何笔记。

# 使用 SQLite3 在 SQL 中存储注释

要开始使用更普通的数据库，让我们看看如何使用 Node.js 中的 SQL。首先，我们将使用 SQLite3，这是一个轻量级、易于设置的数据库引擎，非常适合于许多应用。

To learn about that database engine, visit [http://www.sqlite.org/](http://www.sqlite.org/).

To learn about the Node.js module, visit [https://github.com/mapbox/node-sqlite3/wiki/API](https://github.com/mapbox/node-sqlite3/wiki/API) or [https://www.npmjs.com/package/sqlite3](https://www.npmjs.com/package/sqlite3).

SQLite3 的主要优点是它不需要服务器；它是一个独立的、无需设置的 SQL 数据库。

第一步是安装模块：

```js
$ npm install sqlite3@3.x --save
```

# SQLite3 数据库模式

接下来，我们需要确保数据库已配置。我们正在为模式使用此 SQL 表定义（另存为`models/schema-sqlite3.sql`：

```js
CREATE TABLE IF NOT EXISTS notes (
    notekey VARCHAR(255),
    title VARCHAR(255),
    body TEXT
);
```

在编写代码之前，我们如何初始化这个模式？一种方法是确保通过您的操作系统包管理系统安装`sqlite3`包，例如在 Ubuntu/Debian 上使用`apt-get`，在 macOS 上使用 MacPorts。安装后，可以运行以下命令：

```js
$ sqlite3 chap07.sqlite3 
SQLite version 3.21.0 2017-10-24 18:55:49
Enter ".help" for usage hints.
sqlite> CREATE TABLE IF NOT EXISTS notes (
 ...> notekey VARCHAR(255),
 ...> title VARCHAR(255),
 ...> body TEXT
 ...> );
sqlite> .schema notes
CREATE TABLE notes (
 notekey VARCHAR(255),
 title VARCHAR(255),
 body TEXT
);
sqlite> ^D
$ ls -l chap07.sqlite3 
-rwx------ 1 david staff 8192 Jan 14 20:40 chap07.sqlite3  
```

虽然我们可以做到这一点，但 12 因素应用模型表示，我们必须以这种方式自动化任何管理流程。为此，我们应该编写一个小脚本，在 SQLite3 上运行 SQL 操作，并使用它初始化数据库。

幸运的是，`sqlite3`命令为我们提供了一种方法。在`package.json`的`scripts`部分增加以下内容：

```js
"sqlite3-setup": "sqlite3 chap07.sqlite3 --init models/schema-sqlite3.sql", 
```

运行安装脚本：

```js
$ npm run sqlite3-setup

> notes@0.0.0 sqlite3-setup /Users/david/chap07/notes
> sqlite3 chap07.sqlite3 --init models/schema-sqlite3.sql 

-- Loading resources from models/schema-sqlite3.sql

SQLite version 3.10.2 2016-01-20 15:27:19
Enter ".help" for usage hints.
sqlite> .schema notes
CREATE TABLE notes (
    notekey VARCHAR(255),
    title   VARCHAR(255),
    body    TEXT
);
sqlite> ^D
```

我们可以编写一个小的 Node.js 脚本来实现这一点，而且很容易做到。然而，通过使用包提供的工具，我们在自己的项目中可以维护的代码更少。

# SQLite3 模型代码

现在，我们可以在*Notes*应用中编写使用该数据库的代码。

创建`models/notes-sqlite3.mjs`文件：

```js
import util from 'util';
import Note from './Note';
import sqlite3 from 'sqlite3';
import DBG from 'debug';
const debug = DBG('notes:notes-sqlite3'); 
const error = DBG('notes:error-sqlite3'); 

var db; // store the database connection here 

async function connectDB() { 
    if (db) return db; 
    var dbfile = process.env.SQLITE_FILE || "notes.sqlite3"; 
    await new Promise((resolve, reject) => {
        db = new sqlite3.Database(dbfile, 
            sqlite3.OPEN_READWRITE | sqlite3.OPEN_CREATE, 
            err => { 
                if (err) return reject(err); 
                resolve(db);
        });
    });
    return db;
}
```

这与`notes-level.mjs`中的`connectDB`功能相同：管理数据库连接。如果数据库没有打开，它将继续这样做，甚至确保创建了数据库文件（如果它不存在）。但如果已经打开，则会立即返回：

```js
export async function create(key, title, body) { 
    var db = await connectDB();
    var note = new Note(key, title, body); 
    await new Promise((resolve, reject) => { 
        db.run("INSERT INTO notes ( notekey, title, body) "+ 
            "VALUES ( ?, ? , ? );", [ key, title, body ], err => { 
                if (err) return reject(err); 
                resolve(note); 
        }); 
    });
    return note;
}

export async function update(key, title, body) { 
    var db = await connectDB();
    var note = new Note(key, title, body); 
    await new Promise((resolve, reject) => { 
        db.run("UPDATE notes "+ 
            "SET title = ?, body = ? WHERE notekey = ?", 
            [ title, body, key ], err => { 
                if (err) return reject(err); 
                resolve(note); 
        }); 
    });
    return note;
}
```

这些是我们的`create`和`update`函数。正如所承诺的，我们现在有理由将 Notes 模型定义为具有用于`create`和`update`操作的单独函数，因为每个操作的 SQL 语句都不同。

调用`db.run`执行 SQL 查询，让我们有机会在查询字符串中插入参数。

`sqlite3`模块使用 SQL 编程接口中常见的参数替换范例。程序员将 SQL 查询放入一个字符串中，然后在每个地方放置一个问号，目的是在查询字符串中插入一个值。查询字符串中的每个问号必须与程序员提供的数组中的值匹配。该模块负责正确编码值，以便正确格式化查询字符串，同时防止 SQL 注入攻击。

`db.run`函数只运行给定的 SQL 查询，不检索任何数据。由于`sqlite3`模块不产生任何承诺，我们必须将函数调用包装在`Promise`对象中：

```js
export async function read(key) {
  var db = await connectDB();
  var note = await new Promise((resolve, reject) => {
    db.get("SELECT * FROM notes WHERE notekey = ?", [key], (err,row) => {
        if (err) return reject(err);
        const note = new Note(row.notekey, row.title, row.body);
        resolve(note);
     });
  });
  return note;
}
```

要使用`sqlite3`模块检索数据，您可以使用`db.get`、`db.all`或`db.each`功能。此处使用的`db.get`函数仅返回结果集的第一行。`db.all`函数一次返回结果集的所有行，如果结果集很大，这可能是可用内存的问题。`db.each`函数一次检索一行，同时仍允许处理整个结果集。

对于*Notes*应用，使用`db.get`检索一张便笺就足够了，因为每个`notekey`只有一张便笺。因此，我们的`SELECT`查询无论如何最多返回一行。但是如果您的应用在结果集中看到多行呢？我们马上就来看看该怎么办。

顺便说一下，这个`read`函数有一个 bug。看看你是否能发现错误。我们将在[第 11 章](11.html)、*单元测试和功能测试*中了解更多关于这一点的信息，当我们的测试工作发现缺陷时：

```js
export async function destroy(key) {
  var db = await connectDB();
  return await new Promise((resolve, reject) => {
    db.run("DELETE FROM notes WHERE notekey = ?;", [key], err => {
        if (err) return reject(err);
        resolve();
    });
  });
}
```

要销毁便笺，我们只需执行`DELETE FROM`语句：

```js
export async function keylist() {
    var db = await connectDB();
    var keyz = await new Promise((resolve, reject) => {
        var keyz = [];
        db.all("SELECT notekey FROM notes", (err, rows) => {
                if (err) return reject(err);
                resolve(rows.map(row => row.notekey ));
            });
    });
    return keyz;
}
```

`db.all`函数检索结果集的所有行

此函数的约定是返回注释键数组。`rows`对象是来自数据库的结果数组，其中包含我们要返回的数据，但格式不同。因此，我们使用`map`函数将数组转换为履行合同所需的格式：

```js
export async function count() {
    var db = await connectDB();
    var count = await new Promise((resolve, reject) => {
        db.get("select count(notekey) as count from notes",(err, row) 
        => {
                if (err) return reject(err);
                resolve(row.count);
            });
    });
    return count;
}

export async function close() {
    var _db = db;
    db = undefined;
    return _db ? new Promise((resolve, reject) => {
            _db.close(err => {
                if (err) reject(err);
                else resolve();
            });
        }) : undefined;
}
```

我们可以简单地使用 SQL 来计算笔记的数量。在本例中，`db.get`返回一行和一列`count`，这是我们想要返回的值。

# 使用 SQLite3 运行 Notes

最后，我们准备使用 SQLite3 运行*Notes*应用。将以下代码添加到`package.json`的`scripts`部分：

```js
"start-sqlite3": "SQLITE_FILE=chap07.sqlite3 NOTES_MODEL=sqlite3 node --experimental-modules ./bin/www.mjs",
```

运行*Notes*应用：

```js
$ DEBUG=notes:* npm run start-sqlite3

> notes@0.0.0 start-sqlite3 /Users/david/chap07/notes
> SQLITE_FILE=chap07.sqlite3 NOTES_MODEL=models/notes-sqlite3 node ./bin/www.mjs

  notes:server Listening on port 3000 +0ms
  notes:sqlite3-model Opened SQLite3 database chap07.sqlite3 +5s  
```

您现在可以在`http://localhost:3000`浏览应用，并像以前一样运行它。

由于 SQLite3 支持从多个实例同时访问，您可以通过将其添加到`package.json`的`scripts`部分来运行多服务器示例：

```js
"server1-sqlite3": "SQLITE_FILE=chap07.sqlite3 NOTES_MODEL=sqlite3 PORT=3001 node ./bin/www.mjs", 
"server2-sqlite3": "SQLITE_FILE=chap07.sqlite3 NOTES_MODEL=sqlite3 PORT=3002 node ./bin/www.mjs", 
```

然后，像前面一样，在单独的命令窗口中运行这些命令。

因为我们仍然没有对视图模板或 CSS 文件进行任何更改，所以应用看起来和以前一样。

当然，您可以使用`sqlite`命令或其他 SQLite3 客户端应用来检查数据库：

```js
$ sqlite3 chap07.sqlite3 
SQLite version 3.10.2 2016-01-20 15:27:19
Enter ".help" for usage hints.
sqlite> select * from notes;
hithere|Hi There||ho there what there
himom|Hi Mom||This is where we say thanks  
```

# 使用 Sequelize 以 ORM 方式存储笔记

有几种流行的 SQL 数据库引擎，如 PostgreSQL、MySQL（[https://www.npmjs.com/package/mysql](https://www.npmjs.com/package/mysql) 和 MariaDB（[https://www.npmjs.com/package/mariasql](https://www.npmjs.com/package/mariasql) ）。与每个节点相对应的是 Node.js 客户端模块，其性质与我们刚才使用的`sqlite3`模块类似。程序员很接近 SQL，这可以很好，就像驾驶手动换档汽车很有趣一样。但是，如果我们想要一个更高层次的数据库视图，这样我们就可以从对象而不是数据库表的行的角度来思考问题，该怎么办呢？**对象关系映射**（**ORM**系统提供了这样一个更高层次的接口，甚至提供了在多个数据库中使用相同数据模型的能力。

**续集**模块（[http://www.sequelizejs.com/](http://www.sequelizejs.com/) 基于承诺，提供强大、完善的 ORM 功能，可以连接 SQLite3、MySQL、PostgreSQL、MariaDB 和 MSSQL。因为 Sequelize 是基于承诺的，所以它自然适合我们正在编写的基于承诺的应用代码。

大多数 SQL 数据库引擎的先决条件是访问数据库服务器。在上一节中，我们使用 SQLite3 绕过了这个问题，它不需要数据库服务器设置。虽然可以在笔记本电脑上安装数据库服务器，但我们希望避免这样做的复杂性，并将使用 Sequelize 来管理 SQLite3 数据库。我们还将看到，对托管数据库（如 MySQL）运行相同的 Sequelize 代码只是一个配置文件的问题。在[第 10 章](10.html)*部署 Node.js 应用*中，我们将学习如何使用 Docker 在笔记本电脑上轻松设置任何服务，包括数据库服务器，并将完全相同的配置部署到实时服务器。大多数 web 托管提供商都提供 MySQL 或 PostgreSQL 作为服务的一部分。

在开始编写代码之前，我们先安装两个模块：

```js
$ npm install sequelize@4.31.x --save
$ npm install js-yaml@3.10.x --save
```

第一个显然安装了 Sequelize 包。第二个，`js-yaml`已安装，以便我们可以实现 YAML 格式的文件来存储 Sequelize 连接配置。YAML 是一种人类可读的*数据序列化语言*，这意味着 YAML 是一种易于使用的文本文件格式，用于描述数据对象。也许了解 YAML 最好的地方是它的维基百科页面[https://en.wikipedia.org/wiki/YAML](https://en.wikipedia.org/wiki/YAML) 。

# Notes 应用的 Sequelize 模型

让我们创建一个新文件，`models/notes-sequelize.mjs`：

```js
import fs from 'fs-extra';
import util from 'util';
import jsyaml from 'js-yaml';
import Note from './Note';
import Sequelize from 'sequelize';
import DBG from 'debug';
const debug = DBG('notes:notes-sequelize'); 
const error = DBG('notes:error-sequelize'); 

var SQNote; 
var sequlz;

async function connectDB() { 
  if (typeof sequlz === 'undefined') {
    const YAML = await fs.readFile(process.env.SEQUELIZE_CONNECT,'utf8');
    const params = jsyaml.safeLoad(YAML, 'utf8'); 
    sequlz = new Sequelize(params.dbname, params.username,
                           params.password, params.params); 
  }
  if (SQNote) return SQNote.sync(); 
  SQNote = sequlz.define('Note', { 
        notekey: { type: Sequelize.STRING, primaryKey: true, unique: 
        true }, 
        title: Sequelize.STRING, 
        body: Sequelize.TEXT 
  }); 
  return SQNote.sync();
}
```

数据库连接存储在`sequlz`对象中，通过读取一个配置文件（稍后我们将讨论该文件）并实例化一个 Sequelize 实例来建立。数据模型`SQNote`描述了要续集的对象结构，以便定义相应的数据库表。如果已经定义了`SQNote`，我们只返回它，否则我们定义并返回`SQNote`

Sequelize 连接参数存储在我们在`SEQUELIZE_CONNECT`环境变量中指定的 YAML 文件中。行`new Sequelize(..)`打开数据库连接。这些参数显然包含连接数据库所需的任何数据库名称、用户名、密码和其他选项。

第`sequlz.define`行是我们定义数据库模式的地方。我们不是将模式定义为创建数据库表的 SQL 命令，而是对字段及其特征进行高级描述。Sequelize 将对象属性映射到表中的列中

我们告诉 Sequelize 调用这个模式注释，但我们使用一个`SQNote`变量来引用该模式。这是因为我们已经将 Note 定义为一个表示 notes 的类。为了避免名称冲突，我们将继续使用`Note`类，并使用 SQNote 与 Sequelize 交互数据库中存储的注释。

Online documentation can be found at the following locations:
Sequelize class: [http://docs.sequelizejs.com/en/latest/api/sequelize/](http://docs.sequelizejs.com/en/latest/api/sequelize/). [](http://docs.sequelizejs.com/en/latest/api/sequelize/) Defining models: [http://docs.sequelizejs.com/en/latest/api/model/](http://docs.sequelizejs.com/en/latest/api/model/).

将这些功能添加到`models/notes-sequelize.mjs`：

```js
export async function create(key, title, body) { 
    const SQNote = await connectDB();
    const note = new Note(key, title, body); 
    await SQNote.create({ notekey: key, title: title, body: body });
    return note;
}

export async function update(key, title, body) { 
    const SQNote = await connectDB();
    const note = await SQNote.find({ where: { notekey: key } }) 
    if (!note) { throw new Error(`No note found for ${key}`); } else { 
        await note.updateAttributes({ title: title, body: body });
        return new Note(key, title, body);
    } 
}
```

有几种方法可以在 Sequelize 中创建新的对象实例。最简单的方法是调用对象的`create`函数（在本例中为`SQNote.create`。该函数将另外两个函数折叠在一起，`build`（用于创建对象）和`save`（用于将其写入数据库）。

更新对象实例有点不同。首先，我们必须使用`find`操作从数据库中检索它的条目。`find`操作被赋予一个指定查询的对象。使用`find`检索一个实例，`findAll`操作检索所有匹配实例。

有关 Sequelize 查询的文档，请访问[http://docs.sequelizejs.com/en/latest/docs/querying/](http://docs.sequelizejs.com/en/latest/docs/querying/) 。

与大多数或所有其他 Sequelize 函数一样，`SQNote.find`返回一个承诺。因此，在`async`函数中，我们`await`操作的结果

更新操作需要两个步骤，第一步是`find`相应的对象从数据库中读入。一旦找到实例，我们可以通过`updateAttributes`函数简单地更新其值：

```js
export async function read(key) { 
    const SQNote = await connectDB();
    const note = await SQNote.find({ where: { notekey: key } }) 
    if (!note) { throw new Error(`No note found for ${key}`); } else { 
        return new Note(note.notekey, note.title, note.body); 
    } 
}
```

为了阅读注释，我们再次使用`find`操作。有可能是一个空结果，我们必须抛出一个错误来匹配。

此函数的约定是返回一个`Note`对象。这意味着获取使用 Sequelize 检索到的字段，并使用该字段创建一个`Note`对象：

```js
export async function destroy(key) { 
    const SQNote = await connectDB();
    const note = await SQNote.find({ where: { notekey: key } }) 
    return note.destroy(); 
}
```

为了销毁一张便笺，我们使用`find`操作来检索它的实例，然后调用它的`destroy()`方法：

```js
export async function keylist() { 
    const SQNote = await connectDB();
    const notes = await SQNote.findAll({ attributes: [ 'notekey' ] });
    return notes.map(note => note.notekey); 
}
```

因为`keylist`函数作用于所有`Note`对象，所以我们使用`findAll`操作。我们在所有注释上查询`notekey`属性。我们得到了一个名为`notekey`的字段的对象数组，我们使用`.map`函数将其转换为注释键数组：

```js
export async function count() { 
    const SQNote = await connectDB();
    const count = await SQNote.count();
    return count; 
}

export async function close() {
    if (sequlz) sequlz.close();
    sequlz = undefined;
    SQNote = undefined;
}
```

对于`count`函数，我们可以使用`count()`方法来计算所需的结果。

# 配置 Sequelize 数据库连接

Sequelize 在多个 SQL 数据库引擎上支持相同的 API。使用 Sequelize 构造函数上的参数初始化数据库连接。十二因素应用模型建议这样的配置数据应该保存在代码之外，并使用环境变量或类似机制注入。我们将使用 YAML 格式的文件来存储连接参数，并使用环境变量指定文件名。

Sequelize 库没有定义用于存储连接参数的任何此类文件。但是开发这样一个文件非常简单。让我们这样做吧。

Sequelize 构造函数的 API 为：`constructor(database: String, username: String, password: String, options: Object)`。

在`connectDB`函数中，我们编写了如下构造函数：

```js
sequlz = new Sequelize(params.dbname, params.username, params.password, params.params); 
```

这个名为`models/sequelize-sqlite.yaml`的文件为我们提供了一个简单的映射，对于 SQLite3 数据库，该映射如下所示：

```js
dbname: notes 
username: 
password: 
params: 
    dialect: sqlite 
    storage: notes-sequelize.sqlite3 
```

YAML 文件是 Sequelize 构造函数参数的直接映射。此文件中的`dbname`、`username`和`password`字段直接对应于连接凭据，`params`对象提供了额外的参数。在`params`字段中有很多、很多、可能的属性可供使用，您可以在[的 Sequelize 文档中了解这些属性 http://docs.sequelizejs.com/manual/installation/usage.html](http://docs.sequelizejs.com/manual/installation/usage.html) 。

`dialect`字段告诉 Sequelize 要使用哪种数据库。对于 SQLite 数据库，`storage`字段中给出了数据库文件名

我们首先使用 SQLite3，因为不需要进一步的设置。之后，我们将大胆尝试，重新配置 Sequelize 模块以使用 MySQL

如果已经有不同的数据库服务器可用，那么创建相应的配置文件就很简单了。对于笔记本电脑上看似合理的 MySQL 数据库，请创建一个新文件，如`models/sequelize-mysql.yaml`，其中包含以下代码：

```js
dbname: notes 
username: .. user name 
password: .. password 
params: 
    host: localhost 
    port: 3306 
    dialect: mysql 
```

这很简单。`username`和`password`必须对应数据库凭证，`host`和`port`会指定数据库的托管位置，设置数据库`dialect`等连接信息，就可以了。

要使用 MySQL，您需要安装基本 MySQL 驱动程序，以便 Sequelize 可以使用 MySQL：

```js
$ npm install mysql@2.x --save
```

在它支持的其他数据库（如 PostgreSQL）上运行 Sequelize 也同样简单。只需创建一个配置文件，安装 Node.js 驱动程序，并安装/配置数据库引擎。

# 使用 Sequelize 运行 Notes 应用

现在我们可以使用 Sequelize 运行*Notes*应用了。我们可以对 SQLite3 和 MySQL 运行这个，但是让我们从 SQLite 开始。将此条目添加到`package.json`中的`scripts`条目：

```js
"start-sequelize": "SEQUELIZE_CONNECT=models/sequelize-sqlite.yaml NOTES_MODEL=sequelize node  --experimental-modules ./bin/www.mjs" 
```

然后按如下方式运行它：

```js
$ DEBUG=notes:* npm run start-sequelize

> notes@0.0.0 start-sequelize /Users/david/chap07/notes
> SEQUELIZE_CONNECT=models/sequelize-sqlite.yaml NOTES_MODEL=sequelize node --experimental-modules./bin/www.mjs

  notes:server Listening on port 3000 +0ms 
```

与之前一样，应用看起来完全相同，因为我们没有更改视图模板或 CSS 文件。按照它的节奏去做，一切都会好起来的。

使用 Sequelize，多个*Notes*应用实例非常简单，只需将这些行添加到`package.json`的`scripts`部分，然后像以前一样启动两个实例：

```js
"server1-sequelize": "SEQUELIZE_CONNECT=models/sequelize-sqlite.yaml NOTES_MODEL=sequelize PORT=3001 node --experimental-modules ./bin/www.mjs", 
"server2-sequelize": "SEQUELIZE_CONNECT=models/sequelize-sqlite.yaml NOTES_MODEL=sequelize PORT=3002 node --experimental-modules ./bin/www.mjs",
```

您将能够启动这两个实例，使用单独的浏览器窗口访问这两个实例，并看到它们显示相同的注释集。

要在给定数据库服务器上重复使用基于 Sequelize 的模型，请执行以下操作：

1.  安装并设置数据库服务器实例，或者获取已设置的数据库服务器的连接参数。
2.  安装相应的 Node.js 驱动程序。
3.  编写与连接参数对应的 YAML 配置文件。
4.  在`package.json`中创建新的`scripts`条目，以根据该数据库自动开始注释。

# 在 MongoDB 中存储笔记

MongoDB 广泛用于 Node.js 应用，其标志是流行的缩写词：MongoDB（或 MySQL）、Express、Angular 和 Node.js。MongoDB 是领先的 NoSQL 数据库之一。它被描述为一个*可扩展、高性能、开源、面向文档的数据库*。它使用 JSON 样式的文档，没有预定义的、僵化的模式和大量高级功能。您可以访问他们的网站以获取更多信息和文档，网址为[http://www.mongodb.org](http://www.mongodb.org) 。

Documentation on the Node.js driver for MongoDB can be found at [https://www.npmjs.com/package/mongodb](https://www.npmjs.com/package/mongodb) and [http://mongodb.github.io/node-mongodb-native/](http://mongodb.github.io/node-mongodb-native/).

Mongoose 是 MongoDB 的流行 ORM（[http://mongoosejs.com/](http://mongoosejs.com/) ）。在本节中，我们将使用本机 MongoDB 驱动程序，但 Mongoose 是一个有价值的替代方案。

您将需要一个正在运行的 MongoDB 实例。`compose.io`（[https://www.compose.io/](https://www.compose.io/) 和`ScaleGrid.io`（[https://scalegrid.io/](https://scalegrid.io/) 托管服务提供商提供托管 MongoDB 服务。如今，作为由其他 Docker 容器构建的系统的一部分，将 MongoDB 作为 Docker 容器托管是很简单的。我们将在[第 11 章](11.html)、*单元测试和功能测试*中进行。

可以设置一个临时 MongoDB 实例，以便在笔记本电脑上进行测试。在所有操作系统包管理系统中都可以使用，MongoDB 网站上有说明（[https://docs.mongodb.org/manual/installation/](https://docs.mongodb.org/manual/installation/) ）。

安装后，无需将 MongoDB 设置为后台服务。相反，您可以运行几个简单的命令，让 MongoDB 实例在命令窗口的前台运行，您可以随时终止并重新启动它。

在一个命令窗口中，运行以下命令：

```js
$ mkdir data
$ mongod --dbpath data
```

在另一个命令窗口中，可以按如下方式对其进行测试：

```js
$ mongo
MongoDB shell version: 3.0.8
connecting to: test
Welcome to the MongoDB shell.
For interactive help, type "help".
For more comprehensive documentation, see
  http://docs.mongodb.org/
Questions? Try the support group
  http://groups.google.com/group/mongodb-user
> db.foo.save({ a: 1});
WriteResult({ "nInserted" : 1 })
> db.foo.find();
{ "_id" : ObjectId("56c0c98673f65b7988a96a77"), "a" : 1 }
> 
bye
```

这将在名为`foo`的集合中保存一个*文档*。第二个命令找到`foo`中的所有文档，为您打印出来。`_id`字段由 MongoDB 添加，用作文档标识符。这对于测试和调试非常有用。对于真正的部署，必须在服务器上正确安装 MongoDB 服务器。有关这些说明，请参阅 MongoDB 文档。

# Notes 应用的 MongoDB 模型

现在，您已经证明您有一个工作的 MongoDB 服务器，让我们开始工作吧。

安装 Node.js 驱动程序非常简单，只需运行以下命令：

```js
$ npm install mongodb@3.x --save
```

现在创建一个新文件`models/notes-mongodb.mjs`：

```js
import util from 'util';
import Note from './Note';
import mongodb from 'mongodb'; 
const MongoClient = mongodb.MongoClient;
import DBG from 'debug';
const debug = DBG('notes:notes-mongodb'); 
const error = DBG('notes:error-mongodb'); 

var client;

async function connectDB() { 
    if (!client) client = await MongoClient.connect(process.env.MONGO_URL);
    return { 
        db: client.db(process.env.MONGO_DBNAME), 
        client: client
    };
}
```

`MongoClient`类用于连接 MongoDB 实例。所需的 URL 将通过环境变量指定，使用简单的格式：`mongodb://localhost/`。数据库名称是通过另一个环境变量指定的。

Documentation for the corresponding objects can be found at
[http://mongodb.github.io/node-mongodb-native/2.2/api/MongoClient.html](http://mongodb.github.io/node-mongodb-native/2.2/api/MongoClient.html) for MongoClient and [http://mongodb.github.io/node-mongodb-native/2.2/api/Db.html](http://mongodb.github.io/node-mongodb-native/2.2/api/Db.html) for Db

这将创建数据库客户端，然后打开数据库连接。这两个对象都是从匿名对象中的`connectDB`返回的。MongoDB 操作的一般模式如下：

```js
(async () => {
  const client = await MongoClient.connect(process.env.MONGO_URL);
  const db = client.db(process.env.MONGO_DBNAME);
  // perform database operations using db object
  client.close();
})();
```

因此，我们的模型方法同时需要`client`和`db`对象，因为它们将同时使用这两种对象。让我们看看这是怎么做到的：

```js
export async function create(key, title, body) { 
    const { db, client } = await connectDB();
    const note = new Note(key, title, body); 
    const collection = db.collection('notes'); 
    await collection.insertOne({ notekey: key, title, body });
    return note;
}

export async function update(key, title, body) { 
    const { db, client } = await connectDB();
    const note = new Note(key, title, body); 
    const collection = db.collection('notes'); 
    await collection.updateOne({ notekey: key }, { $set: { title, body } });
    return note;
}
```

我们使用解构赋值将`db`和`client`检索到单个变量中

MongoDB 将所有文档存储在集合中。*集合*是一组相关文档，集合类似于关系数据库中的表。这意味着创建新文档或更新现有文档首先将其构造为 JavaScript 对象，然后要求 MongoDB 将该对象保存到数据库中。MongoDB 自动将对象编码为其内部表示形式。

`db.collection`方法为我们提供了一个`Collection`对象，我们可以使用它操作命名集合。参见[中的文件 http://mongodb.github.io/node-mongodb-native/2.2/api/Collection.html](http://mongodb.github.io/node-mongodb-native/2.2/api/Collection.html) 。

正如方法名称所示，`insertOne`将一个文档插入到集合中。类似地，`updateOne`方法首先查找文档（在本例中，通过查找具有匹配`notekey`字段的文档），然后根据指定更改文档中的字段。

您将看到这些方法返回一个承诺。`mongodb`驱动程序支持回调和承诺。如果提供了回调函数，许多方法将调用该回调函数，否则它将返回一个承诺，该承诺将传递结果或错误。当然，由于我们使用的是`async`函数，`await`关键字使得这一点非常清晰。

Further documentation can be found at the following links:
Insert: [https://docs.mongodb.org/getting-started/node/insert/](https://docs.mongodb.org/getting-started/node/insert/). [](https://docs.mongodb.org/getting-started/node/insert/) Update: [https://docs.mongodb.org/getting-started/node/update/](https://docs.mongodb.org/getting-started/node/update/).

接下来，让我们看一下阅读 MongoDB 的一篇文章：

```js
export async function read(key) { 
    const { db, client } = await connectDB();
    const collection = db.collection('notes');
    const doc = await collection.findOne({ notekey: key });
    const note = new Note(doc.notekey, doc.title, doc.body);
    return note; 
}
```

`mongodb`驱动程序支持多种`find`操作。在这种情况下，*Notes*应用确保只有一个文档与给定的密钥匹配。因此，我们可以使用`findOne`方法。顾名思义，`findOne`将返回第一个匹配的文档。

`findOne`的参数是一个查询描述符。这个简单的查询查找其`notekey`字段与请求的`key`匹配的文档。当然，空查询将匹配集合中的所有文档。您可以以类似的方式与其他字段进行匹配，查询描述符可以做更多的工作。有关查询的文档，请访问[https://docs.mongodb.org/getting-started/node/query/](https://docs.mongodb.org/getting-started/node/query/) 。

我们前面使用的`insertOne`方法也采用了相同的查询描述符。

为了满足此函数的约定，我们创建一个`Note`对象，然后将其返回给调用者。因此，我们使用从数据库检索到的数据创建注释：

```js
export async function destroy(key) { 
    const { db, client } = await connectDB();
    const collection = db.collection('notes'); 
    await collection.findOneAndDelete({ notekey: key });
}
```

`find`变体之一是`findOneAndDelete`。顾名思义，它会找到一个与查询描述符匹配的文档，然后删除该文档：

```js
export async function keylist() { 
    const { db, client } = await connectDB();
    const collection = db.collection('notes'); 
    const keyz = await new Promise((resolve, reject) => { 
        var keyz = []; 
        collection.find({}).forEach( 
            note => { keyz.push(note.notekey); }, 
            err => { 
                if (err) reject(err); 
                else resolve(keyz); 
            } 
        ); 
    }); 
    return keyz;
}
```

在这里，我们使用 base`find`操作并给它一个空查询，以便它匹配每个文档。我们要返回的是一个数组，其中包含每个文档的`notekey`。

所有的`find`操作都返回一个`Cursor`对象。文件可在[中找到 http://mongodb.github.io/node-mongodb-native/2.1/api/Cursor.html](http://mongodb.github.io/node-mongodb-native/2.1/api/Cursor.html) 。

顾名思义，游标对象是指向查询结果集的指针。它有许多与对结果集进行操作相关的有用函数。例如，您可以跳过结果中的前几项，或者限制结果集的大小，或者执行`filter`和`map`操作。

`Cursor.forEach`方法采用两个回调函数。对结果集中的每个元素调用第一个。在这种情况下，我们可以使用它来记录数组中的`notekey`。处理完结果集中的所有元素后，将调用第二个回调。我们用它来表示成功或失败，并返回`keyz`数组。

因为`forEach`使用了这种模式，所以它没有提供承诺的选项，我们必须自己创建承诺，如下所示：

```js
export async function count() { 
    const { db, client } = await connectDB();
    const collection = db.collection('notes');
    const count = await collection.count({});
    return count;
}

export async function close() {
    if (client) client.close();
    client = undefined;
}
```

`count`方法采用一个查询描述符，顾名思义，它统计匹配文档的数量。

# 运行 MongoDB Notes 的应用

现在我们有了 MongoDB 模型，我们可以准备使用它运行*Notes*。

现在你已经知道该怎么做了；将此添加到`package.json`的`scripts`部分：

```js
"start-mongodb": "MONGO_URL=mongodb://localhost/ MONGO_DBNAME=chap07 NOTES_MODEL=mongodb node --experimental-modules ./bin/www.mjs", 
```

`MONGO_URL`环境变量是连接 MongoDB 数据库的 URL。

您可以按如下方式启动*Notes*应用：

```js
$ DEBUG=notes:* npm run start-mongodb
> notes@0.0.0 start-mongodb /Users/david/chap07/notes
> MONGO_URL=mongodb://localhost/ MONGO_DBNAME=chap07 NOTES_MODEL=mongodb node --experimental-modules ./bin/www

  notes:server Listening on port 3000 +0ms 
```

您可以在`http://localhost:3000`浏览应用，并对其进行测试。您可以关闭并重新启动应用，您的笔记仍将保留。

将此添加到`package.json`的`scripts`部分：

```js
"server1-mongodb": "MONGO_URL=mongodb://localhost/ MONGO_DBNAME=chap07 NOTES_MODEL=mongodb PORT=3001 node --experimental-modules ./bin/www.mjs", 
"server2-mongodb": "MONGO_URL=mongodb://localhost/ MONGO_DBNAME=chap07 NOTES_MODEL=mongodb PORT=3002 node --experimental-modules ./bin/www.mjs",
```

您将能够启动两个*Notes*应用实例，并看到它们共享同一组 Notes。

# 总结

在本章中，我们经历了一场不同数据库技术的旋风。虽然我们一遍又一遍地看了同样的七个函数，但了解各种数据存储模型和完成任务的方法是很有用的。即便如此，我们只触及了从 Node.js 访问数据库和数据存储引擎的选项的表面。

通过正确地抽象模型实现，我们能够轻松地切换数据存储引擎，同时不改变应用的其余部分。我们确实跳过了设置数据库服务器的问题。正如我们所承诺的，我们将在[第 10 章](10.html)*部署 Node.js 应用*中探讨 Node.js 应用的生产部署。

通过将模型代码集中于存储数据的目的，模型和应用都应该更容易测试。可以使用模拟数据模块测试应用，该模块提供已知的可预测注释，这些注释可以进行可预测的检查。我们将在[第 11 章](11.html)、*单元测试和功能测试*中更深入地了解这一点。

在下一章中，我们将重点介绍使用 OAuth2 对用户进行身份验证。